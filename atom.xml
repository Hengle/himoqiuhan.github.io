<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楸涵の小窝</title>
  
  <subtitle>祝你天天开心！</subtitle>
  <link href="https://himoqiuhan.github.io/atom.xml" rel="self"/>
  
  <link href="https://himoqiuhan.github.io/"/>
  <updated>2023-06-03T05:32:03.720Z</updated>
  <id>https://himoqiuhan.github.io/</id>
  
  <author>
    <name>楸涵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://himoqiuhan.github.io/2023/05/30/hello-world/"/>
    <id>https://himoqiuhan.github.io/2023/05/30/hello-world/</id>
    <published>2023-05-29T16:00:00.000Z</published>
    <updated>2023-06-03T05:32:03.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-Butterfly"><a href="#Hello-Butterfly" class="headerlink" title="Hello Butterfly"></a>Hello Butterfly</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment">#日期</span></span><br><span class="line"><span class="attr">tags:</span> <span class="comment">#标签</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span></span><br><span class="line"><span class="attr">categories:</span> <span class="comment">#种类</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">#关键词</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#封面处的描述</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment">#日期</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="comment">#文章顶部图片</span></span><br><span class="line"><span class="attr">cover:</span> <span class="comment">#封面图片</span></span><br><span class="line"><span class="attr">swiper_index:</span> <span class="number">1</span> <span class="comment">#置顶轮播图顺序，非负整数，数字越大越靠前 （目前暂时还没有开）</span></span><br></pre></td></tr></table></figure><h1 id="主页双行显示"><a href="#主页双行显示" class="headerlink" title="主页双行显示"></a>主页双行显示</h1><p>博客的config文件（不是主题的）中的buterfly_article_double_row</p><h1 id="代码自动换行"><a href="#代码自动换行" class="headerlink" title="代码自动换行"></a>代码自动换行</h1><p>主题配置文件中的code_word_wrap</p><h1 id="副标题打字效果"><a href="#副标题打字效果" class="headerlink" title="副标题打字效果"></a>副标题打字效果</h1><p>主题配置文件中的subtitle</p><h1 id="折叠框使用"><a href="#折叠框使用" class="headerlink" title="折叠框使用"></a>折叠框使用</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab active"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">Front Matter范式及一些备注</summary>
    
    
    
    
    <category term="Butterfly" scheme="https://himoqiuhan.github.io/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>CPP软光栅渲染器</title>
    <link href="https://himoqiuhan.github.io/2023/04/29/CPPSoftRasterizerRenderer/"/>
    <id>https://himoqiuhan.github.io/2023/04/29/CPPSoftRasterizerRenderer/</id>
    <published>2023-04-29T00:54:04.000Z</published>
    <updated>2023-06-03T05:10:49.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>学习完<a href="https://games-cn.org/intro-graphics/">Games101</a>一段时间后，发现自己对一些基础知识掌握得不够牢固，就从零手搓了一个软光栅渲染器。</p><p>目标是过一遍光栅化渲染管线，所以不考虑算法优化，以及例如图片解码读取这些细分内容。</p><p>用glfw实现窗口创建和像素点绘制，基础的数学库和TGA图片读取类改写自<a href="https://github.com/ssloy/tinyrenderer">TinyRenderer</a>教程提供的数学库，其余实现流程全是自己手搓的。</p><blockquote><p>项目地址：<a href="https://github.com/himoqiuhan/QiuHRenderer">https://github.com/himoqiuhan/QiuHRenderer</a></p></blockquote><p>部分效果图：</p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_TextureMapping.png" style="zoom:33%;" /><figcaption>贴图读取与映射</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_bat.png" style="zoom:50%;" /><figcaption>“伪后处理”描边效果</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_Normal.png" style="zoom: 33%;" /><figcaption>平滑法线</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_Depth.png" style="zoom: 50%;" /><figcaption>深度图渲染</figcaption><h1 id="渲染器整体架构"><a href="#渲染器整体架构" class="headerlink" title="渲染器整体架构"></a>渲染器整体架构</h1><ul><li>传入模型、读取光照信息</li><li>-–for(每个面)<ul><li>定义v2f结构体数组vertexout[3]</li><li>–for(3个顶点)<ul><li>GetVertexData获取当前顶点appdate_base顶点信息(顶点位置、顶点UV、顶点法线)</li><li>VertexShader给v2f赋值(裁剪空间坐标、世界空间坐标、世界空间法线、顶点UV)</li></ul></li><li>透视除法-&gt;齐次裁剪空间：简单粗暴的放弃这个面片 continue!(因为写渲染器的目标在于捋清楚渲染流水线，所以不做深挖)</li><li>屏幕映射-&gt;屏幕空间：三角形设置(基于三角形GetAABB获取BoudingBox)</li><li>–for(BoundingBox)三角形遍历<ul><li>IsInTriangle叉乘判断片元是否在三角形内</li><li>-if(在三角形内部)<ul><li>GetBarycentric获取屏幕上的重心坐标</li><li>插值计算出该片元在candidate cube 中的z值-&gt;获取candidate cube 中的坐标</li><li>齐次裁剪空间的坐标转换到相机空间中</li><li>利用透视除法系数，反推出裁剪空间中的深度值fragDepth</li><li>判断fragDepth与zbuffer内的深度值<ul><li>if(fragDepth.abs &lt; zbuffer[])<ul><li>写入当前深度值</li><li>FragmentShader输出片元颜色color4</li><li>DrawPixel</li></ul></li><li>else<ul><li>不进行任何处理</li></ul></li></ul></li></ul></li><li>-else<ul><li>continue</li></ul></li></ul></li></ul></li></ul><h1 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h1><h2 id="类、结构体的设计"><a href="#类、结构体的设计" class="headerlink" title="类、结构体的设计"></a>类、结构体的设计</h2><h3 id="Rasterizer类"><a href="#Rasterizer类" class="headerlink" title="Rasterizer类"></a>Rasterizer类</h3><p>实际的每一帧的渲染是在Rasterizer类中实现的，其中包含渲染前对模型变换、摄像机的设置，以及对渲染流程的执行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rasterizer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Transform transform;</span><br><span class="line">Camera camera;</span><br><span class="line">Screen screen;</span><br><span class="line"></span><br><span class="line">Matrix Matrix_M;</span><br><span class="line">Matrix Matrix_V;</span><br><span class="line">Matrix Matrix_P;</span><br><span class="line">Matrix Matrix_MVP;</span><br><span class="line"></span><br><span class="line">Vec3f worldLightDir;</span><br><span class="line"></span><br><span class="line">TGAImage* diffuseTex;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; ZBuffer;</span><br><span class="line">std::vector&lt;color4&gt; FrameBuffer;</span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; LuminanceBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DEBUG</span></span><br><span class="line"><span class="type">int</span> fragCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rasterizer</span>(<span class="type">const</span> Screen&amp; screen);<span class="comment">//构造对象，指定摄像机</span></span><br><span class="line">~<span class="built_in">Rasterizer</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTransform</span><span class="params">(Vec3f transition, Vec3f rotation, Vec3f scale)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPerspective</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetOrthogonal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position, Vec3f _lookAt, Vec3f _lookUp, <span class="type">float</span> _FOV, <span class="type">float</span> _aspect, <span class="type">float</span> _near, <span class="type">float</span> _far)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position, Vec3f _lookAt, Vec3f _lookUp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExeRenderPipeline</span><span class="params">(Model* model, TGAImage* diffuse, Vec3f light_dir)</span></span>;<span class="comment">//执行渲染管线，其中包含模型的读取、顶点着色器、图片的读取和片元着色器，并且最终渲染到RenderTarget上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Used In RenderPipeline</span></span><br><span class="line"><span class="function">appdata_base <span class="title">GetVertexData</span><span class="params">(Model* model, Vec3i faceIndex)</span></span>;</span><br><span class="line"><span class="function">v2f <span class="title">VertexShader</span><span class="params">(appdata_base v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canClip</span><span class="params">(Vec3f* homogeneousPos)</span></span>;</span><br><span class="line"><span class="function">Vec3f <span class="title">ScreenMapping</span><span class="params">(Vec3f screen_coord)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInTriangle</span><span class="params">(Vec2i frag, Vec3f* triangleVertex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetFragHomogeneousDepth</span><span class="params">(<span class="type">float</span>* triangleVertexDepths, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetFragW</span><span class="params">(<span class="type">float</span>* triangleVertexW, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="function">color4 <span class="title">FragmentShader</span><span class="params">(v2f* i, <span class="type">float</span> fragW, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="comment">//Used In Vertex Shader</span></span><br><span class="line"><span class="function">Vec3f <span class="title">ObjectToWorldNormal</span><span class="params">(Vec3f normal)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">GetFragNormalByVertNormal</span><span class="params">(Vec3f* triangleVertexNormals, Vec3f barycoord)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrag</span><span class="params">(Vec2f pos, color4 color)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基础信息结构体"><a href="#基础信息结构体" class="headerlink" title="基础信息结构体"></a>基础信息结构体</h3><h4 id="屏幕-x2F-窗口信息"><a href="#屏幕-x2F-窗口信息" class="headerlink" title="屏幕&#x2F;窗口信息"></a>屏幕&#x2F;窗口信息</h4><p>用于存储所创建窗口的长、宽信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> width = <span class="number">640</span>;</span><br><span class="line"><span class="type">int</span> height = <span class="number">480</span>;</span><br><span class="line"><span class="built_in">Screen</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Screen</span>(<span class="type">int</span> w, <span class="type">int</span> h) :<span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="变换信息"><a href="#变换信息" class="headerlink" title="变换信息"></a>变换信息</h4><p>用于存放物体在世界空间下的变换（平移、旋转和缩放），其中由于后续在矩阵设置过程中进行了角度值到弧度值的转换，所以这里的旋转所用的是角度值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Transform</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f transition = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vec3f rotate = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vec3f scale = <span class="built_in">Vec3f</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTransform</span><span class="params">(Vec3f _transition, Vec3f _rotation, Vec3f _scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">transition = _transition;</span><br><span class="line">rotate = _rotation;</span><br><span class="line">scale = _scale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="相机信息"><a href="#相机信息" class="headerlink" title="相机信息"></a>相机信息</h4><p>有关信息见如下注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f position = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//世界空间位置</span></span><br><span class="line">Vec3f g = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>); <span class="comment">//摄像机看向方向</span></span><br><span class="line">Vec3f t = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//摄像机向上方向</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> FOV = <span class="number">60</span>; <span class="comment">//Field of view</span></span><br><span class="line"><span class="type">float</span> aspect = <span class="number">16</span> / (<span class="type">float</span>)<span class="number">9</span>; <span class="comment">//宽高比</span></span><br><span class="line"><span class="type">float</span> near = <span class="number">0.1f</span>; <span class="comment">//近裁剪面距离</span></span><br><span class="line"><span class="type">float</span> far = <span class="number">100.f</span>;<span class="comment">//远裁剪面距离</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="颜色信息"><a href="#颜色信息" class="headerlink" title="颜色信息"></a>颜色信息</h4><p>用于对颜色的RGBA值进行存储，加入一些简单的相加、相乘和增加对比度的功能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">color4</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> g;</span><br><span class="line"><span class="type">float</span> b;</span><br><span class="line"><span class="type">float</span> a;</span><br><span class="line"><span class="built_in">color4</span>() : <span class="built_in">r</span>(<span class="number">1</span>), <span class="built_in">g</span>(<span class="number">1</span>), <span class="built_in">b</span>(<span class="number">1</span>), <span class="built_in">a</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">color4</span>(<span class="type">float</span> R, <span class="type">float</span> G, <span class="type">float</span> B, <span class="type">float</span> A) : <span class="built_in">r</span>(R), <span class="built_in">g</span>(G), <span class="built_in">b</span>(B), <span class="built_in">a</span>(A) &#123;&#125;</span><br><span class="line">color4 <span class="keyword">operator</span>*(<span class="type">float</span> num) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r * num, g * num, b * num, a * num); &#125;</span><br><span class="line">color4 <span class="keyword">operator</span>*(color4 other) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r * other.r, g * other.g, b * other.b, a * other.a); &#125;</span><br><span class="line">color4 <span class="keyword">operator</span>+(color4 other) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r + other.r, g + other.g, b + other.b, a + other.a); &#125;</span><br><span class="line"><span class="function">color4 <span class="title">AddContrast</span><span class="params">(<span class="type">float</span> power)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">color4</span>(std::<span class="built_in">pow</span>(r, power), std::<span class="built_in">pow</span>(g, power), std::<span class="built_in">pow</span>(b, power), <span class="number">1.f</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信息传递结构体"><a href="#信息传递结构体" class="headerlink" title="信息传递结构体"></a>信息传递结构体</h3><h4 id="appdate-base"><a href="#appdate-base" class="headerlink" title="appdate_base"></a>appdate_base</h4><p>用于将模型信息传输给顶点着色器</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata_base</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f vertex;<span class="comment">//顶点数据</span></span><br><span class="line">Vec3f normal;<span class="comment">//顶点法线</span></span><br><span class="line">Vec2f texcoord;<span class="comment">//顶点UV坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="v2f"><a href="#v2f" class="headerlink" title="v2f"></a>v2f</h4><p>用于将顶点着色器传出的数据发送给片元着色器</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">&#123;</span><br><span class="line">Vec4f clipPos;<span class="comment">//裁剪空间坐标</span></span><br><span class="line">Vec3f worldPos;<span class="comment">//世界空间坐标</span></span><br><span class="line">Vec3f worldNromal;<span class="comment">//世界空间顶点法线</span></span><br><span class="line">Vec2f uv;<span class="comment">//顶点UV坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><p>矩阵相关的内容在&#x2F;scr&#x2F;Support&#x2F;Math中的Matrx.cpp中，只做了更常用的透视投影，没有做正交投影的矩阵变换</p><h3 id="Model-Matrix"><a href="#Model-Matrix" class="headerlink" title="Model Matrix"></a>Model Matrix</h3><p>将顶点数据从Model Space变换到World Space，处理顶点数据的平移、旋转和缩放</p><p>此处使用的变换顺序是旋转-缩放-平移，其中旋转传入的是角度值的数值，在内部进行了角度值到弧度制的转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetModelMatrix</span><span class="params">(<span class="type">const</span> Transform&amp; transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Vec3f <span class="title">rotateRadian</span><span class="params">(transform.rotate.x * <span class="number">3.14f</span> / <span class="number">180</span>, transform.rotate.y * <span class="number">3.14f</span> / <span class="number">180</span>, transform.rotate.z * <span class="number">3.14f</span> / <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetTransition</span>(transform.transition) * <span class="built_in">GetScale</span>(transform.scale) * <span class="built_in">GetRotation</span>(rotateRadian);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="View-Matrix"><a href="#View-Matrix" class="headerlink" title="View Matrix"></a>View Matrix</h3><p>将顶点数据从World Space变换到View Space中，处理摄像机的变换，获得顶点数据在View Space下的坐标信息，确定View Space时使用的是右手系</p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e53ee5c1448108e2d5992e9c6e38126.jpg" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetViewMatrix</span><span class="params">(<span class="type">const</span> Camera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix t = mat&lt;<span class="number">4</span>, <span class="number">4</span>, <span class="type">float</span>&gt;::<span class="built_in">identity</span>();</span><br><span class="line">t[<span class="number">0</span>][<span class="number">3</span>] = -camera.position.x;</span><br><span class="line">t[<span class="number">1</span>][<span class="number">3</span>] = -camera.position.y;</span><br><span class="line">t[<span class="number">2</span>][<span class="number">3</span>] = -camera.position.z;</span><br><span class="line"></span><br><span class="line">Vec3f gxt = <span class="built_in">cross</span>(camera.g, camera.t);</span><br><span class="line"></span><br><span class="line">Matrix r;</span><br><span class="line">r[<span class="number">0</span>][<span class="number">0</span>] = gxt.x;       r[<span class="number">0</span>][<span class="number">1</span>] = gxt.y;       r[<span class="number">0</span>][<span class="number">2</span>] = gxt.z;</span><br><span class="line">r[<span class="number">1</span>][<span class="number">0</span>] = camera.t.x;  r[<span class="number">1</span>][<span class="number">1</span>] = camera.t.y;  r[<span class="number">1</span>][<span class="number">2</span>] = camera.t.z;</span><br><span class="line">r[<span class="number">2</span>][<span class="number">0</span>] = -camera.g.x; r[<span class="number">2</span>][<span class="number">1</span>] = -camera.g.y; r[<span class="number">2</span>][<span class="number">2</span>] = -camera.g.z;</span><br><span class="line">r[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r * t;<span class="comment">//先平移再旋转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Perspective-Matrix"><a href="#Perspective-Matrix" class="headerlink" title="Perspective Matrix"></a>Perspective Matrix</h3><p>将顶点数据从View Space变换到Clip Space裁剪空间中，待后续进行透视除法变换到齐次裁剪空间进行裁剪和屏幕映射</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> Camera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> cot = <span class="number">1.0f</span> / std::<span class="built_in">tan</span>((camera.FOV / <span class="number">2.0f</span>) * <span class="number">3.14f</span> / <span class="number">180</span>);</span><br><span class="line">Matrix ret;</span><br><span class="line">ret[<span class="number">0</span>][<span class="number">0</span>] = cot / camera.aspect;</span><br><span class="line">ret[<span class="number">1</span>][<span class="number">1</span>] = cot;</span><br><span class="line">ret[<span class="number">2</span>][<span class="number">2</span>] = -(camera.far + camera.near) / (camera.far - camera.near);</span><br><span class="line">ret[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-2</span> * camera.far * camera.near / (camera.far - camera.near);</span><br><span class="line">ret[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>Rasterizer类中的成员函数ExeRenderPipeline，流程和<a href="#%E6%B8%B2%E6%9F%93%E5%99%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">渲染器架构</a>部分的内容基本相同，只是项目源文件中放了很多用于deBug的宏定义，所以在此留一个纯净版</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rasterizer::ExeRenderPipeline</span><span class="params">(Model* model, TGAImage* diffuse, Vec3f light_dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">worldLightDir = light_dir * <span class="number">-1.f</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;diffuseTex = diffuse;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;|||||||||||||||||||ExeRenderPipeline 单帧开始|||||||||||||||||||&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;||||||||||||||||摄像机基本信息： &quot;</span> &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; camera.position &lt;&lt; <span class="string">&quot; LookAt: &quot;</span> &lt;&lt; camera.g &lt;&lt; <span class="string">&quot; LookUp: &quot;</span> &lt;&lt; camera.t &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;||||||||||||||||光照方向：&quot;</span> &lt;&lt; worldLightDir &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">v2f vertexout[<span class="number">3</span>];</span><br><span class="line">std::vector&lt;Vec3i&gt; face = model-&gt;<span class="built_in">face</span>(i);<span class="comment">//指定当前遍历到的面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历边上的每一个顶点，进行处理</span></span><br><span class="line">appdata_base VertexData = <span class="built_in">GetVertexData</span>(model, face[j]);</span><br><span class="line">vertexout[j] = <span class="built_in">VertexShader</span>(VertexData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="type">float</span> w[<span class="number">3</span>];<span class="comment">//存储透视除法系数</span></span><br><span class="line">Vec3f homogeneousClipPos[<span class="number">3</span>];<span class="comment">//齐次裁剪空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">w[j] = vertexout[j].clipPos.w;</span><br><span class="line">homogeneousClipPos[j] = (vertexout[j].clipPos / w[j]).<span class="built_in">xyz</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础齐次裁剪</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">canClip</span>(homogeneousClipPos)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕映射</span></span><br><span class="line">Vec3f screen_coords[<span class="number">3</span>] = &#123;</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">0</span>]),</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">1</span>]),</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">2</span>])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形设置--&gt;基于三角形获取AABB</span></span><br><span class="line">std::tuple&lt;Vec2i,Vec2i&gt; bbox = <span class="built_in">GetBoudingBox</span>(screen_coords);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//------------------逐顶点的操作结束------------------//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//--------------至此，开始逐片元进行操作--------------//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逐片元执行FragmentShader</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(bbox).y; y &lt;= std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(bbox).y; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(bbox).x; x &lt;= std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(bbox).x; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断是否在三角形内部，如果不在三角形内部，继续遍历下一个frag</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsInTriangle</span>(<span class="built_in">Vec2i</span>(x, y), screen_coords)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取片元中心的重心坐标</span></span><br><span class="line">Vec3f BarycentricCoordinate = <span class="built_in">GetBarycentricCoordinate</span>(screen_coords, <span class="built_in">Vec2f</span>(x+<span class="number">.5</span>, y+<span class="number">.5</span>));<span class="comment">//重心坐标分别对应vertexout[0],vertexout[1],vertexout[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值计算当前frag在candidate cube 中的z值</span></span><br><span class="line"><span class="type">float</span> vertexDepth[<span class="number">3</span>] = &#123; screen_coords[<span class="number">0</span>].z,screen_coords[<span class="number">1</span>].z,screen_coords[<span class="number">2</span>].z &#125;;</span><br><span class="line"><span class="type">float</span> homogeneousDepth = <span class="built_in">GetFragHomogeneousDepth</span>(vertexDepth, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形重心插值，获取当前frag的w值</span></span><br><span class="line"><span class="type">float</span> fragW = <span class="built_in">GetFragW</span>(w, BarycentricCoordinate);</span><br><span class="line"><span class="comment">//获取当前frag在线性空间下（此处用的是裁剪空间）深度值</span></span><br><span class="line"><span class="type">float</span> depth = homogeneousDepth * fragW;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度判断</span></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">abs</span>(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//深度值更小，则更新ZBuffer，计算FragmentShader并渲染当前frag</span></span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = <span class="built_in">FragmentShader</span>(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line">fragCounter++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FragColor.r == <span class="number">-1</span> || FragColor.g == <span class="number">-1</span> || FragColor.b == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓存区</span></span><br><span class="line">std::<span class="built_in">fill</span>(ZBuffer.<span class="built_in">begin</span>(), ZBuffer.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line">std::<span class="built_in">fill</span>(FrameBuffer.<span class="built_in">begin</span>(), FrameBuffer.<span class="built_in">end</span>(), <span class="built_in">color4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">std::<span class="built_in">fill</span>(LuminanceBuffer.<span class="built_in">begin</span>(), LuminanceBuffer.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;执行Fragment Shader 数量：&quot;</span> &lt;&lt; fragCounter &lt;&lt; std::endl;</span><br><span class="line">fragCounter = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;|||||||||||||||||||ExeRenderPipeline 单帧结束|||||||||||||||||||&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h1><h2 id="Frame-Buffer"><a href="#Frame-Buffer" class="headerlink" title="Frame Buffer"></a>Frame Buffer</h2><p>最简易的版本将是直接将当前渲染到的像素直接绘制到屏幕上，后续加入了Frame Buffer，渲染器会先将颜色数据存储到Frame Buffer中，经过处理后再绘制到屏幕。</p><p>使用时直接在上方宏定义处定义#define DEFERREDRENDERING_ON即可</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (std::abs(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = FragmentShader(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line">fragCounter++;</span><br><span class="line"></span><br><span class="line">if (FragColor.r == -1 || FragColor.g == -1 || FragColor.b == -1) continue;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- DrawFrag(Vec2f(x + .5, y + .5), FragColor);</span></span><br><span class="line"><span class="addition">+FrameBuffer[y * screen.width + x] = FragColor;//写入FrameBuffer</span></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line"><span class="addition">+for (int y = 0; y &lt; screen.height; y++)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+for (int x = 0; x &lt; screen.width; x++)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+DrawFrag(Vec2f(x + .5, y + .5), FrameBuffer[y * screen.width + x]);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><h2 id="渲染深度图"><a href="#渲染深度图" class="headerlink" title="渲染深度图"></a>渲染深度图</h2><p>简单的渲染ZBuffer中的信息，在这个渲染器中，我想做出Deferred Render的感觉，所以实现需要#define DEFERREDRENDERING_ON来实现</p><p>只是将绘制Frame Buffer替换成了绘制ZBuffer</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">for (int y = 0; y &lt; screen.height; y++)</span><br><span class="line">&#123;</span><br><span class="line">for (int x = 0; x &lt; screen.width; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="deletion">-DrawFrag(Vec2f(x + .5, y + .5), FrameBuffer[y * screen.width + x]);</span></span><br><span class="line"><span class="addition">+DrawFrag(Vec2f(x + .5, y + .5), color4(ZBuffer[y * screen.width + x] / 120, ZBuffer[y * screen.width + x] / 120, ZBuffer[y * screen.width + x] / 120, 1.f).AddContrast(.5));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="得到亮度图"><a href="#得到亮度图" class="headerlink" title="得到亮度图"></a>得到亮度图</h2><p>亮度计算方法：$Luminance &#x3D; r * 0.2125 + g * 0.7154 + b * 0.0721$</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (std::abs(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = FragmentShader(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line">fragCounter++;</span><br><span class="line">if (FragColor.r == -1 || FragColor.g == -1 || FragColor.b == -1) continue;</span><br><span class="line">FrameBuffer[y * screen.width + x] = FragColor;</span><br><span class="line"><span class="addition">+LuminanceBuffer[y * screen.width + x] = FragColor.r * 0.2125 + FragColor.g * 0.7154 + FragColor.b * 0.0721;//写入亮度LuminanceBuffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于深度-x2F-亮度的简单描边效果"><a href="#基于深度-x2F-亮度的简单描边效果" class="headerlink" title="基于深度&#x2F;亮度的简单描边效果"></a>基于深度&#x2F;亮度的简单描边效果</h2><p>绘制Frame Buffer时，遍历每个像素并判断是否应该进行描边绘制</p><p>此处我使用当前像素周围八个像素，对角及上下左右的颜色信息差距，通过相减除以像素差来模拟颜色信息差的二阶导数，来判断是否描边</p><h4 id="基于深度"><a href="#基于深度" class="headerlink" title="基于深度"></a>基于深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">1</span> &amp;&amp; y &lt; screen.height - <span class="number">1</span> &amp;&amp; x &gt; <span class="number">1</span> &amp;&amp; x &lt; screen.width - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((std::<span class="built_in">abs</span>((ZBuffer[(y + <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - ZBuffer[(y - <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[(y - <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - ZBuffer[(y + <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[y * screen.width + x + <span class="number">1</span>] - ZBuffer[y * screen.width + x - <span class="number">1</span>])) / (<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[(y + <span class="number">1</span>) * screen.width + x] - ZBuffer[(y - <span class="number">1</span>) * screen.width + x])) / (<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.2</span>f))</span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), <span class="built_in">color4</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br></pre></td></tr></table></figure><h4 id="基于亮度"><a href="#基于亮度" class="headerlink" title="基于亮度"></a>基于亮度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">1</span> &amp;&amp; y &lt; screen.height - <span class="number">1</span> &amp;&amp; x &gt; <span class="number">1</span> &amp;&amp; x &lt; screen.width - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((std::<span class="built_in">abs</span>((LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x + <span class="number">1</span> ] - LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[y * screen.width + x + <span class="number">1</span>] - LuminanceBuffer[y * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x] - LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x]))/(<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.05</span>f))</span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), <span class="built_in">color4</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">除窗口创建和像素点的绘制外，不使用任何图形学API制作的软件光栅化渲染器</summary>
    
    
    
    <category term="项目开发" scheme="https://himoqiuhan.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="图形学" scheme="https://himoqiuhan.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://himoqiuhan.github.io/tags/C/"/>
    
    <category term="造轮子" scheme="https://himoqiuhan.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
</feed>

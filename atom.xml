<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楸涵の小窝</title>
  
  <subtitle>祝你天天开心！</subtitle>
  <link href="https://himoqiuhan.github.io/atom.xml" rel="self"/>
  
  <link href="https://himoqiuhan.github.io/"/>
  <updated>2023-09-02T10:53:04.816Z</updated>
  <id>https://himoqiuhan.github.io/</id>
  
  <author>
    <name>楸涵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Unity】URP中的仿原神渲染1.0</title>
    <link href="https://himoqiuhan.github.io/2023/08/31/Projects-GenshinLikeRenderingInURP1/"/>
    <id>https://himoqiuhan.github.io/2023/08/31/Projects-GenshinLikeRenderingInURP1/</id>
    <published>2023-08-31T09:46:40.000Z</published>
    <updated>2023-09-02T10:53:04.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><blockquote><p>展示视频：【【仿原神渲染/MMD】我推的芭芭拉】<a href="https://www.bilibili.com/video/BV1F841167nb">https://www.bilibili.com/video/BV1F841167nb</a></p></blockquote><p>十分喜欢赛璐璐风格的卡通渲染，正好开始那段时间时间在学习HLSL，心想不如基于一个实际落地的效果去边学边练，于是就开启了一段美妙（并且经常痛苦）的学习旅程！</p><p>最终的效果差强人意，但也是很好地标明了一个起点，持续改进中！</p><p>像视频简介里面说的那样，这一段时间为了在已有资源的基础上做好卡通渲染，还简单学了Maya的Python，从MEL到OpenMaya都接触了一点，最后写出了一个用于计算并存储平滑法线信息的小工具。为了在URP里写后处理，去学了URP的RenderFeature，接触了一点点SRP的知识。不过这些学习大多都是基于想要实现的效果去学的，后续还要花一些时间去整理和部分地深入，我也打算一边总结一边写一些分享文章。在这篇文章里，我就简单聊一下我是如何使用手上的资源实现目前渲染效果，关于一些技术他们更深的底层原理以及我对他们运用方式的思考，不久后我也会写出来的。毕竟，卡通渲染无法一概而论，其关注的是最后的效果，对于一个优秀卡通渲染的研究，一定要深入到每一个技术细节存在的前因后果，这样才能一步步做出更好的卡渲。</p><h2 id="总览">总览</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/%E3%80%90%E9%A1%B9%E7%9B%AE%E8%90%BD%E5%9C%B0%E3%80%91%E4%BB%BF%E5%8E%9F%E7%A5%9E%E6%B8%B2%E6%9F%931.0.png" alt="MMD中用到的相关技术"></p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902100453437.png" alt="这次我用到的工作流"></p><h2 id="贴图资源简述">贴图资源简述</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831182658671.png" alt="贴图资源"></p><p>用到的贴图资源如上所示，有basecolor贴图、lightmap贴图、ramp图、matcap贴图和自制的用于存储平滑法线和描边区域信息的outline贴图，简单介绍一下各个贴图的用法</p><h3 id="lightmap-ilmTexture">lightmap - ilmTexture</h3><p>存储一些控制光照的参数信息</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831183602219.png" alt="芭芭拉的ilmTexture各个通道显示结果"></p><ul><li>R：对高光区域进行分组，区分单独Blinn-Phong高光的区域和Matcap+Blinn-phong高光的区域</li><li>G：存储阴影权重，在这里实际上就是AO</li><li>B：存储Blinn-Phong高光的强度，同时作为高光区域遮罩</li><li>A：对材质进行分组，用于读取不同的Ramp图</li></ul><h3 id="Ramp图">Ramp图</h3><p>存储阴影以及亮暗过渡区域的Color Tint颜色</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831184511737.png" alt="处理UV后采样Ramp图的结果"></p><h3 id="SDF面部阴影贴图">SDF面部阴影贴图</h3><p>基于光照的角度存储阴影阈值信息</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831185012391.png" alt="Signed Distance Field阴影贴图"></p><h3 id="MatCap贴图">MatCap贴图</h3><p>存储模拟金属光泽的反射强度信息</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831185316199.png" alt="两个视角下的MatCap模拟效果"></p><h3 id="Diffuse贴图">Diffuse贴图</h3><p>存储模型漫反射颜色</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831185548091.png" alt="非常好看的贴图！"></p><h3 id="Outline贴图">Outline贴图</h3><p>自制的存储切线空间下顶点平滑法线信息的贴图</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831190231498.png" alt="基于RG通道还原切线空间下的平滑法线信息"></p><ul><li>RG通道：存储切线空间下</li><li>B通道：控制描边区域</li><li>A通道：控制Ramp图影响范围（因为游戏中脖子部位和脸的下方是不受到Ramp图影响的，所以利用这个通道标记了一下不绘制ramp的区域。不过代价是在这个Pass中多读了一张贴图，后续再进行优化）</li></ul><h2 id="Diffuse漫反射">Diffuse漫反射</h2><p>Diffuse的表现效果我大概迭代了三个版本，总算是调整到了一个看上去感觉还不错的效果，不过距离游戏里的表现还相去甚远，后续再继续研究分析，做进一步的效果提升。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831194443935.png" alt="目前版本的Diffuse明暗表现"></p><p>几次迭代下来，我认为在Shading阶段的Diffuse关键在于，合适且美观地结合Ramp图做出出色的阴影表现，所以以下我重点说一说我对Ramp效果的处理方式。</p><h3 id="Barbara身体的Ramp">Barbara身体的Ramp</h3><p>身体的Ramp分为三层，上下两个部分分别是白天的ramp和夜间的ramp</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823090627694.png" alt="Babala Body Ramp"></p><p>Body的Lightmap A通道同样是有三层，分为衣领、皮肤和衣服三个部分（以及还有一个胸口的蝴蝶结）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823090522534.png" alt="Body的Lightmap.a"></p><p>再来看看游戏中实际的效果表现：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831193131252.png" alt="游戏中身体的Ramp表现"></p><p>可以根据颜色的偏移得出以下判断：（其中的数字为lightmap.a中对应区域大致的灰度数值）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823101823412.png" alt="Barbara Body Ramp分析"></p><h3 id="Barbara头发的Ramp">Barbara头发的Ramp</h3><p>头发的Ramp分为两层，上下两个部分分别是白天的ramp和夜间的ramp</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823084908444.png" alt="Babala Hiar Ramp"></p><p>再来看看游戏中实际的效果表现：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831193426363.png" alt="游戏中头发和帽子的Ramp表现"></p><p>轻易能看出来，Day/Night的Ramp第一行是头发的（对应Lightmap A通道的数值是0），Ramp第二行是帽子和丝带的（对应Lightmap A通道的数值是1）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823093924706.png" alt="Barbara Hair Ramp分析"></p><h3 id="RampUV-Y">RampUV.Y</h3><p>综合一下可以发现，ramp第一行对应lightmap.a&lt;0的区域，ramp第二行对应lightmap.a&gt;0.7的区域，ramp第三行对应lightmap.a&gt;0.52的区域（我开始思考是不是我的贴图错了，因为同时包含两个白天和夜晚的ramp，这也不能直接利用贴图的repeat来处理0跑到最上面的问题啊QAQ）</p><p>这一次，在百思不得其解之后，我选择了使用if来暴力解决（对不起！但是为了效果目前只能先这样了，一定还有我没摸索到的更深层次的原因，我会继续探究的！）</p><p>所以对于Ramp图UV的V轴处理就如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//处理RampUV的V轴</span><br><span class="line">if (layers &lt;= 0.01)</span><br><span class="line">&#123;</span><br><span class="line">RampTexUV.y = 0.5 * _RampDailyMode + 9 * RampTexelY;</span><br><span class="line">    &#125;</span><br><span class="line">else if (layers &gt;= 0.6)</span><br><span class="line">&#123;</span><br><span class="line">RampTexUV.y = 0.5 * _RampDailyMode + 7 * RampTexelY;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">RampTexUV.y = 0.5 * _RampDailyMode + 5 * RampTexelY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为这次重点针对芭芭拉的ramp图效果进行迭代和优化，所以没有考虑其他角色的通用性，后续整理代码的时候会加上其他角色更多Ramp区域的读取方式。</p><h3 id="RampUV-X-–-Ramp表现的细节分析">RampUV.X – Ramp表现的细节分析</h3><p>迭代着迭代着，再加上一次次地原神启动，我发现了两个问题：为什么Ramp图中过渡的区域是不同的呢？为什么不是在同一个地方进行的明暗交界？</p><p>下面这张图要明显一点，在同样的光照计算中，并且仅仅是透视无法得到同样效果的前提下，可以看出来衣领的<strong>浅阴影-亮面分界</strong>与衣服的<strong>浅阴影-深阴影分界</strong>是接近的</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823103315687.png" alt="衣领和衣服的区域分析"></p><p>再来看之前的Ramp图，在同样的光照信息采样的前提下，不同部分的ramp颜色变化区域是不同的。</p><p>所以，对于光从0到1的变化过程中，衣领的阴影变化会先到来，然后是衣服的阴影变化，最后是皮肤、蝴蝶结的阴影变化</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823104501745.png" alt="整体的阴影过度区间"></p><p>不过再来看看阴影结束（也就是完全亮部的分界线），不同部分几乎是相同的</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823105133188.png" alt="浅阴影和亮面的分界"></p><p>可以分析出来各个Ramp部分截取的都是相同的一段X区间上的Ramp信息，是Ramp颜色过渡部位的不同导致的阴影偏移。不过到现在我还是无法理解为什么要这么处理，等后续再去研究研究色彩和阴影的美术原理，或许能找到一些答案。</p><p>继续分析下去，再看一下游戏中的整体的阴影表现，是接近于对半平分的阴影</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823105738804.png" alt="整体的阴影表现"></p><p>我总结出的个人理解是：阴影可以分为三层，浅阴影、过渡层、深阴影</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823163127135.png" alt="Ramp的过度表现分析"></p><p>放大可以发现，浅阴影层和亮部的区分明显，浅阴影层和过渡层之间有一点点的平滑过渡，过渡层和深阴影层之间有平滑的过度关系，有一种颜色向深阴影层扩散的感觉。</p><p>如果直接用halflamber加step的柔化去采样，即使加上Bloom后细节效果也不够好：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823163611073.png" alt="step处理halflambert后直接采样Ramp(Night)" style="zoom:90%;" /><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823164206533.png" alt="step处理halflambert后直接采样Ramp(Day)"></p><p>肉眼可见有几个问题：</p><ol><li>浅阴影层和过渡层之间的过渡很生硬，并且有“一条一条”的感觉</li><li>过渡层到深阴影层之间，及时加了适度的Bloom也没有那种“扩散过去”的感觉</li><li>总感觉深阴影层的颜色没有那么偏紫</li></ol><p>所以感觉下来，好像深层阴影的颜色像亮部一样，并不是由ramp图控制的，如果这个假设成立，那可以有以下的解决方案：</p><ol><li>深阴影层颜色偏移由另外的参数控制，其与过渡层之间有Lerp的平滑过渡处理，并且Lerp范围比较大</li><li>过渡层只是提取了光照信息的一小个区间，读取了一整张的ramp贴图</li></ol><p>原本浅阴影和亮部之间处理二分的思路是：<code>RampTexUV.x = min(0.99, smoothstep(0.0, 0.5 + _IntermediateToShallowShadowOffset, halfLambert));</code>也就是截取了halfLambert数值<strong>0~0.5+_IntermediateToShallowShadowOffset</strong>之间数值映射到0~1之间，作为ramp的u轴去采样ramp图的横向信息。</p><p>所以直接加入一个参数来对smoothstep的左边界进行控制即可：<code>RampTexUV.x = min(0.99, smoothstep(0.5 - _IntermediateToDarkShadowOffset, 0.5 + _IntermediateToShallowShadowOffset, halfLambert));</code>同时，其中的SmoothStep处理的区间，则被用作平滑处理的遮罩rampSmoothMask，用于后续对DarkShadow区域和Intermediate区域进行融合处理，模拟“扩散过去”的感觉</p><p>最终得到的效果：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831200621359.png" alt="最终的Ramp表现效果"></p><p>总的用于获取RampUV信息的函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//计算一个rampSmoothMask用于平滑DarkShadow与IntermediateShadow之间的分界</span><br><span class="line">float2 GetRampUV(float halfLambert, float layers, out float rampSmoothMask)</span><br><span class="line">&#123;</span><br><span class="line">float2 RampTexUV;</span><br><span class="line">float RampTexelY = 0.05;</span><br><span class="line">    //处理RampUV的V轴</span><br><span class="line">    if (layers &lt;= 0.01)</span><br><span class="line">&#123;</span><br><span class="line">    RampTexUV.y = 0.5 * _RampDailyMode + 9 * RampTexelY;</span><br><span class="line">&#125;</span><br><span class="line">else if (layers &gt;= 0.6)</span><br><span class="line">&#123;</span><br><span class="line">    RampTexUV.y = 0.5 * _RampDailyMode + 7 * RampTexelY;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">RampTexUV.y = 0.5 * _RampDailyMode + 5 * RampTexelY;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理RampUV的U轴</span><br><span class="line">    rampSmoothMask = smoothstep(0.5 - _IntermediateToDarkShadowOffset, 0.5 + _IntermediateToShallowShadowOffset, halfLambert);</span><br><span class="line">    RampTexUV.x = min(0.94, rampSmoothMask);</span><br><span class="line">    return RampTexUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终对diffuse color的计算：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Diffuse:</span><br><span class="line">float lightMapAOMask = 1 - smoothstep(saturate(lightMapTexCol.g), 0.06, 0.6);</span><br><span class="line">float rampSmoothMask;</span><br><span class="line">float2 RampTexUV = GetRampUV(halfLambert, lightMapTexCol.a, rampSmoothMask);</span><br><span class="line">half4 rampCol = SAMPLE_TEXTURE2D(_RampTex, sampler_RampTex, RampTexUV);</span><br><span class="line">//通过rampSmoothMask平滑DarkShadow与IntermediateShadow之间的分界</span><br><span class="line">half4 shadowColorTint = ifRamp * lerp(_DarkShadowColorTint, rampCol, rampSmoothMask) + (1-ifRamp)*_DarkShadowColorTint*1.5;</span><br><span class="line">//通过控制shadowMask来控制ShallowShadow的宽度</span><br><span class="line">float shadowMask = step(_ShallowShadowWidth + 0.5, halfLambert * lightMapAOMask);</span><br><span class="line">//与漫反射贴图融合得到最终的漫反射颜色</span><br><span class="line">half4 diffuseCol = diffuseTexCol * (shadowMask * _BrightAreaColorTint + (1.0 - shadowMask) * shadowColorTint);</span><br></pre></td></tr></table></figure><h2 id="Specular高光反射">Specular高光反射</h2><p>关于Specular其实没有太多自己的创新，就是Blinn-Phong高光与MatCap模拟金属高光的结合。网上也能找到很多大佬的处理思路，等之后有更新的高光处理思路，再多做记录</p><p>其中使用的是lightmap的R通道对高光类型进行区分</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823220128347.png" alt="lightmap的r通道"></p><ul><li>&lt;10的部分是没有高光的部分</li><li>10~100的部分只有Blinn-Phong高光</li><li>&gt;100的部分有Blinn-Phong高光和采样MatCap制作的金属镜面高光</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230823220308139.png" alt="由MatCap控制的金属镜面高光区域"></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Specular:</span><br><span class="line">//通过lightmap的R通道来对高光进行分层</span><br><span class="line">const float specularLayer = lightMapTexCol.r * 255.0;</span><br><span class="line">//lightmap的b通道则是控制blinn-phong高光的强度,并同时作为Specular的遮罩</span><br><span class="line">const float blinnPhongSpecIntensity = lightMapTexCol.b;</span><br><span class="line">//先计算通用的Blinn-Phong高光</span><br><span class="line">float blinnPhongSpec = step(0.75, max(0.0, pow(ndoth, _SpecularExp))) * blinnPhongSpecIntensity;</span><br><span class="line">//specularLayer&gt;100的部分有Blinn-Phong高光和采样MatCap制作的裁边视角光，所以对此部分进行MatCap的计算</span><br><span class="line">float matcapSpec = 0.0;</span><br><span class="line">if (specularLayer &gt; 100)</span><br><span class="line">&#123;</span><br><span class="line">//MatCap需要基于视角空间的法线去读取，并且注意读取发现后需要映射到0-1区间</span><br><span class="line">matcapSpec = saturate(SAMPLE_TEXTURE2D(_MetalTex, sampler_MetalTex,</span><br><span class="line">                  mul((float3x3)UNITY_MATRIX_V, i.normalWS).xy * 0.5 + 0.5).r);</span><br><span class="line">&#125;</span><br><span class="line">//处理头发天使轮的遮罩</span><br><span class="line">matcapSpec *= step(0.25, blinnPhongSpecIntensity);</span><br><span class="line">half4 specularCol = (matcapSpec + blinnPhongSpec) * diffuseTexCol;</span><br></pre></td></tr></table></figure><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230831204549049.png" alt="最终得到的高光区域的效果"></p><h2 id="RimLight边缘光">RimLight边缘光</h2><p>边缘光是在屏幕空间下计算的等距边缘光，制作思路是，开启Depth Texture的Prepass，在Shader中拿到深度图。让模型在齐次裁剪空间下进行一定程度地法线外扩，通过比较外扩前和外扩后模型读取到的深度，如果深度插值达到阈值则判定为边缘光区域，对边缘光区域进行提亮处理。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901091331182.png" alt="线性深度的插值DepthDiff"></p><p>![RimMask](C:\Users\Qui Han\AppData\Roaming\Typora\typora-user-images\image-20230901091415854.png)</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901091543373.png" alt="RimLight混合后的效果"></p><p>【posCS的计算】</p><p>值得提一下的是，需要获得posCS（齐次裁剪空间的坐标），但是这个posCS不能是直接由vertx shader中计算好的用于输出给SV_Target进行屏幕映射的vertexOutput.posCS（fragment中的i.posCS），因为在一定的深度范围中才会有线性的变化，并且在一个区间中会有明显的跳变。目前我还不知道原因是什么。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/iposCSSuddenChanging.gif" alt="使用i.posCS的突变"></p><p>但是如果换作在fragment shader中利用i.posWS计算出来的就可以平滑处理</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/posCSSmoothChanging.gif" alt="在Fragment Shader中计算出posCS后过渡可以很平滑"></p><p>做一下对比探究一下：</p><p>这是vertex shader中计算posCS的方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 TransformObjectToHClip(float3 positionOS)</span><br><span class="line">&#123;</span><br><span class="line">    // More efficient than computing M*VP matrix product</span><br><span class="line">    return mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), float4(positionOS, 1.0)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是fragment shader中计算posCS的方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float3 TransformObjectToWorld(float3 positionOS)</span><br><span class="line">&#123;</span><br><span class="line">    #if defined(SHADER_STAGE_RAY_TRACING)</span><br><span class="line">    return mul(ObjectToWorld3x4(), float4(positionOS, 1.0)).xyz;</span><br><span class="line">    #else</span><br><span class="line">    return mul(GetObjectToWorldMatrix(), float4(positionOS, 1.0)).xyz;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Tranforms position from world space to homogenous space</span><br><span class="line">float4 TransformWorldToHClip(float3 positionWS)</span><br><span class="line">&#123;</span><br><span class="line">    return mul(GetWorldToHClipMatrix(), float4(positionWS, 1.0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上两个方法的计算过程是一致的，只不过在vertex中计算出来的posCS直接插值传递给fragment，而在fragment中利用插值后的WS计算CS是逐fragment去计算的。但是矩阵变换是线性变换的，这些也是在线性空间完成的，按理说插值应该不会影响效果才对。那么感觉就是插值寄存器的问题</p><p>【深度的线性转化】</p><p>我们通过深度图拿到的深度信息实际上是经过透视变换之后的深度，不是线性空间的（这样可以用更高精度存近处的深度，更低精度存远处的深度），但是在进行对比时，我们需要的是线性空间的深度值来作差，所以我们需要对深度进行转化，Unity提供了Linear01Depth和LinearEyeDepth两个函数来进行转换。</p><p>Linear01Depth和LinearEyeDepth最终得到的深度值的区别在于是否压缩到0-1空间中，压缩方法也就是除以far</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Z buffer to linear 0..1 depth (0 at camera position, 1 at far plane).</span><br><span class="line">// Does NOT work with orthographic projections.</span><br><span class="line">// Does NOT correctly handle oblique view frustums.</span><br><span class="line">// zBufferParam = &#123; (f-n)/n, 1, (f-n)/n*f, 1/f &#125;</span><br><span class="line">float Linear01Depth(float depth, float4 zBufferParam)</span><br><span class="line">&#123;</span><br><span class="line">    return 1.0 / (zBufferParam.x * depth + zBufferParam.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Z buffer to linear depth.</span><br><span class="line">// Does NOT correctly handle oblique view frustums.</span><br><span class="line">// Does NOT work with orthographic projection.</span><br><span class="line">// zBufferParam = &#123; (f-n)/n, 1, (f-n)/n*f, 1/f &#125;</span><br><span class="line">float LinearEyeDepth(float depth, float4 zBufferParam)</span><br><span class="line">&#123;</span><br><span class="line">    return 1.0 / (zBufferParam.z * depth + zBufferParam.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而_ProjectionParams.z的值是far</p><p>所以<code>Linear01Depth(offsetDepth, _ZBufferParams)*_ProjectionParams.z</code>和<code>LinearEyeDepth(0ffsetDepth, _ZBufferParams)</code>是等效的</p><p>【最后的代码】</p><p>计算边缘光的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Rim Light</span><br><span class="line">float4 posCS = TransformWorldToHClip(i.posWS);</span><br><span class="line">//获取原本的深度：</span><br><span class="line">float4 orgPosCS = float4(posCS.xy, 0.0, posCS.w);</span><br><span class="line">//很有意思的一点是，这里的orgPosCS需要是由世界空间posWS经过shader内部自己计算出来的posCS，如果用</span><br><span class="line">float4 orgScreenPos = ComputeScreenPos(orgPosCS); //计算出齐次空间下的ScreenPos，注意此处是没有进行透视除法的</span><br><span class="line">float2 orgVPCoord = orgScreenPos.xy / orgScreenPos.w; //进行透视除法，获取屏幕空间坐标</span><br><span class="line">float orgDepth = SampleSceneDepth(orgVPCoord);</span><br><span class="line">//读取没有偏移时的深度信息，使用SampleSceneDepth函数需要引入DeclareDepthTexture.hlsl</span><br><span class="line">float orgLinearDepth = LinearEyeDepth(orgDepth, _ZBufferParams); //将深度信息转换到视角空间下</span><br><span class="line">//获取偏移之后的深度：</span><br><span class="line">float3 normalCS = TransformWorldToHClipDir(i.normalWS, true); //计算出齐次裁剪空间下的法线方向</span><br><span class="line">float4 rimOffsetPosCS = float4(normalCS.xy * _RimLightWidth + posCS.xy, 0.0, posCS.w); //计算出齐次裁剪空间下的偏移位置</span><br><span class="line">float4 rimOffsetScreenPos = ComputeScreenPos(rimOffsetPosCS);</span><br><span class="line">float2 offsetVPCoord = rimOffsetScreenPos.xy / rimOffsetScreenPos.w;</span><br><span class="line">float offsetDepth = SampleSceneDepth(offsetVPCoord); //得到偏移后的深度信息</span><br><span class="line">float offsetLinearDepth = LinearEyeDepth(offsetDepth, _ZBufferParams); //将深度信息转换到视角空间下</span><br><span class="line">//进行比较：</span><br><span class="line">float depthDiff = offsetLinearDepth - orgLinearDepth; //计算出偏移后和偏移前的深度差（Unity中，离摄像机越近，深度值越接近1）</span><br><span class="line">float rimFactor = 1 - smoothstep(60.0, 100.0, orgLinearDepth); //rim factor由距离控制是否需要产生边缘光，并平滑使边缘光消失</span><br><span class="line">float rimEdgeMask = smoothstep(10.0, 20.0, depthDiff) * rimFactor; //得到边缘光遮罩</span><br><span class="line"></span><br><span class="line">return diffuseCol * rimEdgeMask * 1.5 + diffuseCol * (1 - rimEdgeMask);</span><br></pre></td></tr></table></figure><h2 id="SDF制作面部阴影">SDF制作面部阴影</h2><p>【原理浅析】</p><p>为了使面部阴影效果更好（一是二分，二是鼻翼侧边的高光），开发者们根据光照的方向，制作了几张面部的lightmap，作为特定角度下面部的阴影表现。然而，直接把这几张贴图合并在一起使用的话，面部的阴影只能是跳变的效果，也就是阴影表现只有在特定角度才会切换，在某个角度区间内阴影表现是固定的。所以引入了SDF，有向距离场的技术：通过“距离场”，把每一张lightmap从单纯的0或1的区分，处理为了距离阴影分界线从0到1之间的数值，可以理解为特定角度下不同区域的阴影权重。通过“有向”来界定了该区域是在阴影内还是阴影外。最终合并后就得到如下的结果</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Avatar_Girl_Tex_FaceLightmap.png" alt="原神中SDF面部阴影图"></p><p>【实际使用】</p><p>模型的头骨是经过旋转的，直接使用lightDir计算会有问题，不过我因为直接是用的mmd的模型，好像因此差距不是很大。所以我的处理是在用原始的light方向判断完左右信息之后，再利用旋转矩阵对光源的方向进行一定程度的旋转，通过旋转光源来进一步优化一下阴影的表现，也便于在视频中根据内容实时调整阴影。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//获取世界空间下的光照信息，并在世界空间下计算光源与角色forward向量之间的夹角信息，并判断光源此时是在角色的左侧还是右侧</span><br><span class="line">half2 lightDir = mainLight.direction.xz;</span><br><span class="line">float rdotl = dot(rightDirWS.xz, lightDir);</span><br><span class="line">//默认的贴图光是从角色的左侧照射向角色的，所以当点乘小于零的时候用默认uv，当点乘大于0的时候左右翻转uv</span><br><span class="line">//温馨提示：左右翻转uv本来应该是1-uv.x，但是如果把texture的Wrap Mode改为Repeat的话就可以用-uv.x来表示了</span><br><span class="line">float2 shadowmapUV = rdotl &lt; 0 ? i.uv : float2(-i.uv.x, i.uv.y);</span><br><span class="line">float faceSDF = SAMPLE_TEXTURE2D(_FaceSDFTex, sampler_FaceSDFTex, shadowmapUV).x;</span><br><span class="line">//利用SDF计算光照信息时需要对光方向进行偏移</span><br><span class="line">float sinx = sin(_FaceShadowOffset);</span><br><span class="line">float cosx = cos(_FaceShadowOffset);</span><br><span class="line">float2x2 rotationOffset1 = float2x2(cosx, sinx, -sinx, cosx); //顺时针偏移</span><br><span class="line">float2x2 rotationOffset2 = float2x2(cosx, -sinx, sinx, cosx); //逆时针偏移</span><br><span class="line">lightDir = lerp(mul(rotationOffset1, lightDir), mul(rotationOffset2, lightDir), step(0, rdotl));</span><br><span class="line">            </span><br><span class="line">float fdotl = dot(forwardDirWS.xz, lightDir);</span><br><span class="line">float lightMask = step(0.5 * fdotl, faceSDF); //需要去截取出每一个角度的SDF信息，</span><br><span class="line">//SDF信息的变化（即不同距离场贴图的区分）是按照光源与角色左右方向上的轴的夹角区分的</span><br><span class="line">//乘0.5是因为身体和头发使用的是半兰伯特光照模型，为了保持阴影分界线尽可能统一而在fdotl后乘0.5</span><br><span class="line">//原理同faceSDF &gt; 0.5 * fdotl，是同一个算法                </span><br><span class="line">//读取通用贴图</span><br><span class="line">half4 diffuseTexCol = SAMPLE_TEXTURE2D(_DiffuseTex, sampler_DiffuseTex, i.uv);</span><br><span class="line">half4 diffuseCol = lerp(diffuseTexCol * _ShadowAreaColorTint, diffuseTexCol * _BrightAreaColorTint,</span><br><span class="line">                        lightMask);</span><br></pre></td></tr></table></figure><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901094210974.png" alt="使用_FaceShadowOffset偏移阴影"></p><h2 id="BackFace描边">BackFace描边</h2><h3 id="平滑法线处理">平滑法线处理</h3><p>因为直接使用模型的法线进行外扩的话，对于硬边上的顶点，一个位置实际上有多个顶点，每个顶点有其各自的法线朝向。当进行外扩时，就会出现描边断裂的效果。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901100435265.png" alt="左使用平滑法线，右使用模型法线"></p><p>硬边一个顶点有多条法线，导入引擎后实际上就是硬边把一个顶点分成了多个顶点，数量则等于硬边所区分的面的数量（这也是为什么引擎中看模型数据顶点数会大于DCC建模软件中所见的顶点数）：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230729104633539.png" alt="硬边一个顶点有多条法线"></p><p>而软边只有一条法线：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230729105031138.png" alt="软边只有一条法线"></p><p>关于工具的详细内容我放在另一个文章中写</p><p>最后计算出平滑法线后我将这些信息存到了一张贴图里面，也就是一开始说得那几张outline贴图</p><h3 id="描边颜色和区域控制">描边颜色和区域控制</h3><p>描边的颜色我用顶点色来进行控制，描边的区域则是在平滑法线贴图的A通道进行控制</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901101105204.png" alt="Blender中绘制顶点色"></p><h3 id="最终效果">最终效果</h3><p>Unity中的描边内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutlineVaryings NPROutlineVertex(OutlineAttributes vertexInput)</span><br><span class="line">&#123;</span><br><span class="line">    OutlineVaryings vertexOutput;</span><br><span class="line">    float4 pos = TransformObjectToHClip(vertexInput.posOS.xyz);</span><br><span class="line"></span><br><span class="line">    float2 uv = TRANSFORM_TEX(vertexInput.uv, _SmoothNormalTex).xy;</span><br><span class="line">    float3 smoothNormalTexCOl = SAMPLE_TEXTURE2D_LOD(_SmoothNormalTex, sampler_SmoothNormalTex, uv, 0).xyz;</span><br><span class="line">    //构建TBN矩阵，并将平滑法线信息转换到世界空间下</span><br><span class="line">    float3 normalWS = TransformObjectToWorldNormal(vertexInput.nomralOS);</span><br><span class="line">    float3 tangentWS = TransformObjectToWorldDir(vertexInput.tangentOS.xyz);</span><br><span class="line">    float3 bitangentWS = normalize(vertexInput.tangentOS.w * abs(cross(normalWS, tangentWS)));</span><br><span class="line">    float3x3 TBN = float3x3(tangentWS, bitangentWS, normalWS);</span><br><span class="line">    float3 smoothNormalTS = float3(smoothNormalTexCOl.r, smoothNormalTexCOl.g,</span><br><span class="line">                                   sqrt(1 - (dot(smoothNormalTexCOl.r, smoothNormalTexCOl.g))));</span><br><span class="line">    float3 smoothNormalWS = mul(smoothNormalTS, TBN);</span><br><span class="line">    float3 smoothNormalCS = TransformWorldToHClipDir(smoothNormalWS, true);</span><br><span class="line"></span><br><span class="line">    //VertexColor的Blue通道用于控制描边区域</span><br><span class="line">    half toDrawOutline = saturate(1 - step(0.1, smoothNormalTexCOl.b));</span><br><span class="line"></span><br><span class="line">    //计算出屏幕的高/宽的值，用于平衡水平描边和竖直描边因屏幕映射而导致的拉伸</span><br><span class="line">    float4 screenParam = GetScaledScreenParams();</span><br><span class="line">    float HdW = screenParam.y / screenParam.x;</span><br><span class="line">    float2 offset = _OutlineWidth * clamp(0.1, 0.5, pos.w) * 0.01 * float2(</span><br><span class="line">        smoothNormalCS.x * HdW, smoothNormalCS.y);</span><br><span class="line">    pos.xy += offset * toDrawOutline;</span><br><span class="line">    vertexOutput.posCS = pos;</span><br><span class="line"></span><br><span class="line">    vertexOutput.outlineColor = vertexInput.vertexCol;</span><br><span class="line"></span><br><span class="line">    return vertexOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 NPROutlineFragment(OutlineVaryings i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    return i.outlineColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901100959818.png" alt="最终的描边效果"></p><h2 id="后处理">后处理</h2><p>这次后处理没有太考虑性能方面的问题，过程很暴力，后续进行优化，核心就是遮罩、模糊和混合。主要的难点在于URP的后处理比Built-in管线写起来要复杂一些。具体的制作内容我同样会再写其他文章来分享，这里只是做一个总述。</p><h3 id="DOF景深效果">DOF景深效果</h3><p>我对DOF的处理方法是，先利用深度信息去计算出模糊区域的遮罩，通过遮罩提取出模糊区域，进行高斯模糊处理。然后再基于遮罩，对原图和计算后的模糊图像进行混合（如果不利用遮罩的话，背景区域的模糊会扩散进清晰区域，得到的效果就没那么好）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901102726588.png" alt="DOF的过程"></p><p>然后混合后就是如下结果：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901101800276.png" alt="DOF最终的效果"></p><h3 id="Bloom">Bloom</h3><p>Bloom参考了COD在SIGGRAPH 2014 <a href="http://advances.realtimerendering.com/s2014/index.html">Advances in Real-Time Rendering in Games</a>课程中分享的Bloom处理思路。主要借鉴了升采样和降采样的步骤，因为一开始做Bloom都是直接模糊然后混合，得到的效果不太好，所以用升降采样的思路进行处理。</p><p>注：Bloom的输入源是DOF的输出，所以以下是在DOF景深计算后的基础上得到的内容</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901103757021.png" alt="Bloom计算过程"></p><p>然后进行混合：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230901103814492.png" alt="最终Bloom与DOF景深混合的结果"></p><h2 id="Timeline控制自定义后处理中的参数">Timeline控制自定义后处理中的参数</h2><p>十分感谢这位大佬的分享：<a href="https://www.bilibili.com/read/cv4828303/">https://www.bilibili.com/read/cv4828303/</a></p><p>基本就是照着这位大佬的流程制作的，后续我深入研究一下API再整理一遍思路</p>]]></content>
    
    
    <summary type="html">在URP管线下探究原神的卡通渲染实现，并以一个MMD作为成果展示</summary>
    
    
    
    <category term="作品集" scheme="https://himoqiuhan.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Unity" scheme="https://himoqiuhan.github.io/tags/Unity/"/>
    
    <category term="技术美术" scheme="https://himoqiuhan.github.io/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
    <category term="URP管线" scheme="https://himoqiuhan.github.io/tags/URP%E7%AE%A1%E7%BA%BF/"/>
    
    <category term="卡通渲染" scheme="https://himoqiuhan.github.io/tags/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/"/>
    
    <category term="SRP自定义后处理" scheme="https://himoqiuhan.github.io/tags/SRP%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8E%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《青春猪头少年不会梦到兔女郎学姐》观后感</title>
    <link href="https://himoqiuhan.github.io/2023/07/20/Anime_QingChunZhuTouShaoNian_TV/"/>
    <id>https://himoqiuhan.github.io/2023/07/20/Anime_QingChunZhuTouShaoNian_TV/</id>
    <published>2023-07-20T06:31:12.000Z</published>
    <updated>2023-08-11T13:51:40.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>打算开始把自己的一些观后感从笔记里搬到博客上，遇到很有感觉的动漫、书本，甚至是音乐，我都会把自己的想法转换到文字写下来，期待以后能遇到愿意和我做交流的人。我不太想要给这样的感悟撰写，添加一些框架的约束，我更多想去写下的是，自己进入那个世界后所产生的感悟、感受与体验</p><p>不过随着时间的推移，不同时间段的我，看同一部作品的感想有可能会有所不同，所以我会在每一篇思考与感悟的博客前写一写关于我写作时的信息，在添加内容前写一写自己新加内容时的信息。当来的我因看到现在的我写的东西而羞耻这件事难道不是很有趣吗！这也是成长的一段记录，记录的是一生中只能经历一次的现在</p></blockquote><blockquote><p>现在是准大二的暑假，19岁的末尾。这是我大概第三次看春猪，前两次都是在高中时期看的，第一次是直接追着看完的，第二次应该是怀梦美少女上映的那段时间，这次重刷带给我的体验也绝不低于之前两次，看得很开心！</p></blockquote><h2 id="个人感悟">个人感悟</h2><p>（这次只写了关于麻衣和咲太主要感情线的部分，后面的内容拖着拖着就突然懒了，之后缘分到了四刷的时候一定补起来）</p><blockquote><p>图片来源：番剧和<a href="https://ao-buta.com/tv/">官网</a></p></blockquote><p>这次重刷是在看完《Just Because》之后继续接着看的，结合两部作品的体验，我想首先说出的一点是，它们都是在给我一种舒适的、想要去继续看下一集的期待，这份期待与大多数的作品有很大的区别：他不是那种，如果不立刻看下一集就会感觉身上有蚂蚁爬的感觉，他是那种淡淡的，恰到好处的期待。我能够带着这份期待，耐心地看完每一集的每一个角落，包括ED、OP在内，回味过来，这让我觉得他有一种美感。这就是我感受到的第一点，<strong>淡淡的，但是恰到好处</strong>。</p><p>接着说我另一个感受到这份淡淡的美的地方，咲太和麻衣学姐的爱情（说起爱情我又要忍不住嘴角上扬+扭作一团了）。他们的爱情很甜，但给我的感受同样是淡淡的。得益于他们共同过渡了一段极其困难的时期，也得益于他们都有超出常人的思想深度，所以他们能够相互理解，思想能够共鸣，也因此他们的爱情有坚实的基底。我觉得这一份来自爱情的、恰到好处的清淡，就是源自他们坚实的基底，他们对彼此的喜欢，绝对是远超于他们所表现出来的喜欢的。也同样的，他们发糖的片段就会给人一种他们是在高端局对线的感觉。</p><p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/bnr_poster.png" alt=""></p><blockquote><p>“区区咲太，如此嚣张。”</p></blockquote><p>再说我想说的另一点，我对于咲太的理解。结合我最近读一些书的感悟，我觉得咲太有强大的获得幸福的能力，因此在番里和他有过深入接触的人都对他有无与伦比的信任。他相比于其他同龄人，经历了一些匪夷所思的事情，失去了很多东西，但是在被翔子小姐开导后，他想清楚了<strong>如何去把握当下</strong>，<strong>如何把善良传递给他人</strong>，单是这两点就让他的人格魅力达到了一个无与伦比的高度。他善于发现幸福的眼睛，让他能够拥有很强的共情能力，能够察觉到其他人的心理需求，并且做出恰如其分的处理。同时，他还是一个很强大的氛围维护者。我这里所说的氛围不是番里那种团体造就的共同情感倾向，而是与身边人交流时带给周围人轻松感的能力，这也是我特别想学习的一点。</p><p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/bnr_onayami.png" alt=""></p><h2 id="摘抄以及一些有意思的地方">摘抄以及一些有意思的地方</h2><img src="https://ao-buta.com/assets/img/story/01/02.jpg" alt="第1話 先輩はバニーガール" style="zoom: 67%;" /><blockquote><p>“如果你在图书馆里遇到一个魅力十足的兔女郎，你会怎么样呢？”</p><p>“我会多看一眼，然后一直盯着看。”</p></blockquote><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230720181522033.png" alt="第2話 初デートに波乱は付き物" style="zoom: 80%;" /><blockquote><p>“我们去一个远一点的城市，没准还会有人能看得见你，我们去确认一下吧。”</p><p>“确认了又怎么样？只会知道除了你之外的人都看不见我、不记得我，这于事何补？”</p><p>“至少在那段期间，我可以一直陪在你身边。”</p></blockquote><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230720182348020.png" alt="第2話 初デートに波乱は付き物" style="zoom:50%;" /><blockquote><p>”我洗个澡。“</p><p>“不准偷看。”</p><p>“没问题，我光是听淋浴的水声就能下三碗饭。”</p><p>“我觉得只让学弟听个响，任由他痛苦挣扎，才是成熟女性应有的作风。”</p><p>“我知道了，没问题，但你可别一个人干起奇怪的事哦。”</p><p>“奇怪的事？”</p><p>“笨蛋！不理你了！“</p></blockquote><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230720183231660.png" alt="alt=&quot;第2話 初デートに波乱は付き物&quot;" style="zoom:50%;" /><blockquote><p>”谢谢你，谢谢你没有放弃我，谢谢你。“</p></blockquote><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230723175649304.png" alt="第3話 君だけがいない世界" style="zoom:50%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230723180051279.png" alt="第4話 ブタ野郎には明日がない" style="zoom:50%;" /><ul><li>师傅的欲情故纵！</li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230723180807442.png" alt="第4話 ブタ野郎には明日がない" style="zoom:50%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230723181029481.png" alt="第4話 ブタ野郎には明日がない" style="zoom:50%;" /><blockquote><p>区区咲太，如此嚣张</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;打算开始把自己的一些观后感从笔记里搬到博客上，遇到很有感觉的动漫、书本，甚至是音乐，我都会把自己的想法转换到文字写下来，期待以后能遇到愿意和我做交流的人。我不太想要给这样的感悟撰写，添加一些框架的约束，我更多想去写下的是，自己进入那个世界后所产生的</summary>
      
    
    
    
    
    <category term="动漫" scheme="https://himoqiuhan.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
    <category term="感想" scheme="https://himoqiuhan.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【UE5】回合制卡牌游戏《失恒Diseternity》</title>
    <link href="https://himoqiuhan.github.io/2023/07/09/Projects-Game-UE-DET/"/>
    <id>https://himoqiuhan.github.io/2023/07/09/Projects-Game-UE-DET/</id>
    <published>2023-07-09T07:37:03.000Z</published>
    <updated>2023-09-02T10:52:13.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发者信息及游戏链接">开发者信息及游戏链接</h2><ul><li>策划：曾經、一帆</li><li>程序：楸涵、6Д9</li><li>美术：SOMA、子珏、二呈</li></ul><blockquote><p>游戏链接：<a href="https://pan.baidu.com/s/1TbsCvCp66PSYo-kFlkktuQ?pwd=3jj4">https://pan.baidu.com/s/1TbsCvCp66PSYo-kFlkktuQ?pwd=3jj4</a><br>提取码：3jj4</p></blockquote><blockquote><p>展示视频：【【前瞻预告】Rogue卡牌游戏：《失恒》（Diseternity）】 <a href="https://www.bilibili.com/video/BV17c411A7wP">https://www.bilibili.com/video/BV17c411A7wP</a></p></blockquote><h2 id="游戏截图">游戏截图</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709154847462.png" alt="主界面" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709160036364.png" alt="关卡选择" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709160227027.png" alt="卡牌战斗" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709155135109.png" alt="角色对话" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709155207786.png" alt="角色获取" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709160330398.png" alt="角色删除" style="zoom: 40%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709155410847.png" alt="卡牌获取" style="zoom: 40%;" /><h2 id="游戏介绍">游戏介绍</h2><ul><li><p>主题：永生的代价</p></li><li><p>游戏名称解释：Diseternity失·恒，意为失去永恒，dis前缀和eternity永恒，连接而成</p></li></ul><h3 id="游戏类型">游戏类型</h3><p>Roguelike类，卡牌战斗，DBG（deck building game）卡组构筑类游戏</p><h3 id="游戏目标">游戏目标</h3><p>不断前进构筑自己的队伍（增删减查），击败敌人，了解真相，做出抉择</p><h3 id="游戏玩法">游戏玩法</h3><ul><li><p>以卡牌随从战斗为核心，通过控制自己的资源，放置随从，打出卡牌，成长随从，辅助战斗来达到消灭敌人的目标。</p><ul><li>战场之上共有9个格子，玩家与病毒共享这些格子，病毒源会周期性的召唤病毒来充斥这个战场，若是病毒占满所有格子，那么游戏结束。玩家需要打出随从站定一个位置，并且用卡牌强化随从的属性和辅助战斗运转让他来消灭病毒和病毒源并且确保他不会被敌人所击败失去所占位置。</li><li>在玩家游玩的过程中会遇见各式各样前世有血有肉的人以计算机数据类型为载体的角色（如主角int，猫猫float等）他们身怀绝技，是冒险路上的强大助力，但是随从的数量与整个世界的能量挂钩（存在上限），玩家需要在不断前进的道路中不断选择放弃牺牲之前获得的随从来确保整个世界不会崩塌，所以牺牲队友换来永生世界的维持，换来继续前进的可能。</li></ul></li></ul><h3 id="背景设定">背景设定</h3><ul><li><p>世界观</p><ul><li><p>电子意识上传，在一个机房里消耗着<strong>号称无尽的资源</strong>，人们实现了所谓的永生。但是这背后有这一个<strong>骗局</strong>，无尽资源只够少数人消耗，激活使用的电脑越多，资源消耗的越快，若是人数过多，那么资源和意识将面临崩溃。（对标随从数量上限的设定）</p><p>终局涉及到无我概念，多世界的跳脱与冲突矛盾，对于永生的代价的不同答案。</p></li></ul></li><li><p>剧情与反派</p><ul><li>知情的上位者为了达成自己的永生（其实是为了拖缓全局崩坏进程），在全体人类带入这个意识机房之后开始了他的计划，他打算利用病毒一步一步关掉下层人民的机子，减少资源的消耗。</li></ul></li><li><p>主角/玩家任务</p><ul><li>随着病毒的侵蚀，愣头青主角（初始不知道这个能源问题）身边的电脑被一个一个关停，主角意识到事情的严重性，他瞧准时机切入到了一个即将被病毒拿下的电脑中，联合这个电脑里的“人”将病毒击退，赢得他的信任，打算去联合大家一起拯救那些被病毒残害而关机的人并且去“守护”这个我们来之不易的永生家园。</li></ul></li><li><p>矛盾点</p><ul><li>矛盾点在于发现了资源不是无尽的情况下，主角如何<strong>抉择</strong><ul><li><strong>直接告诉</strong>手下的人们真实情况</li><li>编一个<strong>借口</strong>遣散一些人继续前进试图寻找到解决问题的方法</li><li><strong>关闭自己</strong>让他人生存</li><li>成为那个上位者</li></ul></li></ul></li></ul><h2 id="游戏开发">游戏开发</h2><h3 id="分工">分工</h3><p>组内共7名同学，楸涵（我）、SOMA、子珏、二呈、曾經、一帆、6Д9</p><ul><li>我：程序（主要逻辑框架，除战斗系统外各个子系统的全部开发，战斗系统卡牌、角色相关功能开发）、技术美术（交互反馈效果）</li><li>6Д9：程序（战斗系统中角色及病毒的生成、攻击、技能开发）</li><li>曾經：策划（战斗系统、卡牌系统、角色系统、关卡系统）</li><li>一帆：策划（数值调试、剧情系统、音频、背景设定）</li><li>SOMA：美术（原画设计、卡牌牌面绘制、背景绘制、UI绘制、宣传图设计）</li><li>子珏：美术（原画设计、角色设计、角色帧动画制作）</li><li>二呈：美术（宣传图设计、部分角色制作）</li></ul><h3 id="开发过程">开发过程</h3><p>我们使用了Notion这个软件作为多人协同的开发辅助工具，极大地方便了我们进行开发管理以及一些资料的整理与共享</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709162915870.png" alt="部分开发截图-看板"></p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709163033084.png" alt="中期邀请玩家试玩后的反馈总结"></p><p>由于此次我们是两名程序进行开发，所以notion也很大程度上帮助我们处理多人协同的问题，大大降低了我们merge时产生冲突的概率</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709163326261.png" alt="总计250+小时的开发时间最后看来也很有成就感！"></p><p>虽然但是还是因为一些失误有过一两次冲突</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/b70e89011192f319992b5a75ac547f6.jpg" alt="QAQ" style="zoom: 50%;" /><h2 id="收获">收获</h2><p>这次开发是我第一个长线开发的项目（前前后后一共做了接近四个月），自己也摸爬滚打出了一些对于长期开发项目的经验：</p><ol><li><p>一个系统的架构思路一定要写下来，因为你永远都不知道什么时候需要回去看自己以前写的屎山</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230709165053013.png" alt="拆解系统的部分笔记" style="zoom: 33%;" /></li><li><p>一些系统偏向底层的功能一定要在一开始就和策划同学沟通清楚，不然你永远不知道一个系统要重写几遍</p></li><li><p>Git是一个很好的版本管理工具，为了便于组员快速上手还写了一点小入门教学文档：<a href="https://zhuanlan.zhihu.com/p/615928723">https://zhuanlan.zhihu.com/p/615928723</a></p></li><li><p>开发过程最好写一些关于变量和函数用途的文档，否则变量多了起来很容易出现同一个信息有很多个变量在不同的地方存储的问题</p></li></ol><p>总之，做游戏很好玩！</p><p>然后，能遇到一群想做一个好游戏的队友一起做游戏更好玩！</p>]]></content>
    
    
    <summary type="html">大二游戏创作专业课结课作业，一个回合制的卡牌游戏</summary>
    
    
    
    <category term="作品集" scheme="https://himoqiuhan.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="游戏开发" scheme="https://himoqiuhan.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="蓝图" scheme="https://himoqiuhan.github.io/tags/%E8%93%9D%E5%9B%BE/"/>
    
    <category term="UE5" scheme="https://himoqiuhan.github.io/tags/UE5/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（美术2.1 DCC工具链与引擎工具链）</title>
    <link href="https://himoqiuhan.github.io/2023/07/02/Notes-TA100A-4/"/>
    <id>https://himoqiuhan.github.io/2023/07/02/Notes-TA100A-4/</id>
    <published>2023-07-02T11:40:57.000Z</published>
    <updated>2023-07-02T11:54:40.124Z</updated>
    
    <content type="html"><![CDATA[<h1>笔记链接：<a href="https://emerald-sunscreen-d5d.notion.site/2-1-DCC-adb1eb7c05fc4626aeaafb729830d6e5?pvs=4">2.1 DCC工具链与引擎工具链</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;笔记链接：&lt;a href=&quot;https://emerald-sunscreen-d5d.notion.site/2-1-DCC-adb1eb7c05fc4626aeaafb729830d6e5?pvs=4&quot;&gt;2.1 DCC工具链与引擎工具链&lt;/a&gt;&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="美术理论" scheme="https://himoqiuhan.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（美术1.4 场景设计精要）</title>
    <link href="https://himoqiuhan.github.io/2023/07/01/Notes-TA100A-3/"/>
    <id>https://himoqiuhan.github.io/2023/07/01/Notes-TA100A-3/</id>
    <published>2023-07-01T13:08:18.000Z</published>
    <updated>2023-07-20T05:43:20.353Z</updated>
    
    <content type="html"><![CDATA[<h1>笔记链接：<a href="https://emerald-sunscreen-d5d.notion.site/1-4-bb6260de73a444a28bbfa27df35e48c3?pvs=4">1.4 场景设计精要</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;笔记链接：&lt;a href=&quot;https://emerald-sunscreen-d5d.notion.site/1-4-bb6260de73a444a28bbfa27df35e48c3?pvs=4&quot;&gt;1.4 场景设计精要&lt;/a&gt;&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="美术理论" scheme="https://himoqiuhan.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（美术1.3 角色设计精要）</title>
    <link href="https://himoqiuhan.github.io/2023/07/01/Notes-TA100A-2/"/>
    <id>https://himoqiuhan.github.io/2023/07/01/Notes-TA100A-2/</id>
    <published>2023-07-01T09:37:33.185Z</published>
    <updated>2023-07-06T04:04:58.631Z</updated>
    
    <content type="html"><![CDATA[<h1>笔记链接：<a href="https://emerald-sunscreen-d5d.notion.site/1-3-29cc594395f24703b873fd7a0c52c77e?pvs=4">1.3 角色设计精要</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;笔记链接：&lt;a href=&quot;https://emerald-sunscreen-d5d.notion.site/1-3-29cc594395f24703b873fd7a0c52c77e?pvs=4&quot;&gt;1.3 角色设计精要&lt;/a&gt;&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="美术理论" scheme="https://himoqiuhan.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【百人计划】美术1.1-1.2 美术理论基础</title>
    <link href="https://himoqiuhan.github.io/2023/06/25/Notes-TA100A-1/"/>
    <id>https://himoqiuhan.github.io/2023/06/25/Notes-TA100A-1/</id>
    <published>2023-06-25T04:01:11.000Z</published>
    <updated>2023-09-01T13:49:42.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-光影">1 光影</h2><blockquote><p>物体呈现在人们眼前的时候，不同的受光面其明暗变化以及物体的影子</p></blockquote><h3 id="1-1-黑白灰">1.1 黑白灰</h3><p>在美术中黑白灰指亮面、灰面、暗面，属于素描的三大面，主要体现一个物体的整体受光的过程。普遍存在于各种艺术和设计领域。黑白灰作品的出现，源于上世纪80年代的伤痕美术。</p><p>具体表现可以从右图的素描关系中得出。光线照射，受光面为“亮”，形成“白”，背光部为“暗”，形成“黑”，其余为过渡的“灰”色。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/0e2b513d-00fa-458e-ac0e-51adcd3f4a70.png" alt=""></p><h3 id="1-2-明暗五调子">1.2 明暗五调子</h3><ul><li>高光，受光面最亮的那一个点。</li><li>亮面：指受光面的高光与深灰面中间的层次。</li><li>灰面：指亮面与明暗交界线中间的层次。</li><li>明暗交界线：是指亮暗面的转折处，一般明暗交界线是最重的地方。</li><li>暗面：包含物体背光面、反光和投影。</li></ul><h3 id="1-3-游戏中的光影">1.3 游戏中的光影</h3><p>很多时候美术说的一个物体在画面中”飘了“，可能就是阴影或者AO出了问题</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/piok.png" alt="左图脚底没有阴影，看起来就比较”飘“"></p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/66450bda-cf6f-40b6-b9e9-f2739e6afca5.png" alt="右图的光影给角色带来了一种通透感"></p><p>光影的黑白灰变化对于氛围塑造有很大的作用</p><p>![Untitled](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 1.png)</p><h2 id="2-透视">2 透视</h2><p>透视指的是在平面或曲面上描绘物体的空间关系的方法或技术</p><h3 id="2-1-透视的一些基础概念">2.1 透视的一些基础概念</h3><ul><li>视点：人眼睛所在的地方，用S表示。</li><li>视平线：与人眼等高的一条水平线。</li><li>视线：视点与物体任何部位的假象连线。</li><li>视角：视点与任意两条视线之间的夹角</li><li>视距：视点到心点（主点）的垂直距离。</li><li>画面：透视图所在的平面。</li><li>灭点：透视点的消失点。</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e8f8ac47-d8af-4285-9576-5fbbdb5060dc.jpeg" alt="e8f8ac47-d8af-4285-9576-5fbbdb5060dc.jpeg"></p><h3 id="2-2-透视的类型">2.2 透视的类型</h3><ol><li><p>平行透视：平行透视也叫一点透视，即物体向视平线上某一点消失</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/dd5fd534-28b4-41b0-a2cd-187ba5d94d92.jpeg" alt=""></p></li><li><p>成角透视：成角透视也叫二点透视，即物体向视平线上某二点消失</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/6bda7f5c-f4cc-49d6-a2af-9d2b140a2c0e.jpeg" alt=""></p></li><li><p>三点透视：有三个消失点，高度线不完全垂直于画面</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2f146a1b-7310-4f86-bfe1-54854b8261c0.jpeg" alt=""></p></li><li><p>散点透视：散点透视也叫多点透视，即不同物体有不同的消失点，这种透视法在中国画中比较常见</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/97748680-e624-4610-b641-c7f5179d122c.jpeg" alt=""></p></li><li><p>鱼眼透视</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/c0300fda-f946-4a2c-8685-6ac966f3cbb4.jpeg" alt=""></p></li><li><p>空气透视：aerial perspective，是由于大气及空气介质（雨、雪、烟、雾、尘土、水气等）使人们看到近处的景物比远处的景物浓重、色彩饱满、清晰度高等的视觉现象。又称“色调透视”、“影调透视”、“阶调透视”。如近处色彩对比强烈，远处对比减弱，近处色彩偏暖，远处色彩偏冷等，故空气透视现象又被称为色彩透视</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/cbb3d9ff-f627-44e8-b9e9-74099a1ef8e0.jpeg" style="zoom:50%;" /></li></ol><h3 id="2-3-达芬奇的透视观点">2.3 达芬奇的透视观点</h3><p>根据达·芬奇对于透视研究的结论，透视分为一下几种：</p><ol><li>色彩透视: 研究这些物体的颜色的淡退</li><li>消逝透视: 研究物体在不同距离处清晰度的减低</li><li>线透视: 研究物体在不同距离处的大小</li></ol><h3 id="2-4-游戏中的透视">2.4 游戏中的透视</h3><p>游戏中为了营造空间感，会使用雾效，这就是空气透视</p><p>![右侧开启了雾效，表现要好很多](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 2.png)</p><p>罪恶装备中给模型加入了一定程度的透视扭曲，更好地表现空间关系</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 3.png)</p><h2 id="3-色彩">3 色彩</h2><blockquote><p>色彩是眼、脑和我们的生活经验对光的颜色类别描述的视觉感知特征。</p></blockquote><h3 id="3-1-色彩三要素">3.1 色彩三要素</h3><p>色彩三要素（Elements of color）色彩可用的色调（色相）、饱和度（纯度）和明度来描述。人眼看到的任一彩色光都是这三个特性的综合效果，这三个特性即是色彩的三要素，其中色调与光波的频率有直接关系，亮度和饱和度与光波的幅度有关</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/62626773-7677-43ad-9c3a-d8694f52b6ee.jpeg" alt=""></p><h3 id="3-2-色相">3.2 色相</h3><p>是指色彩的相貌，是色彩最显著的特征，是不同波长的色彩被感觉的结果。光谱上的红、橙、黄、绿、青、蓝、紫就是七种不同的基本色相</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 4.png)</p><h3 id="3-3-饱和度（纯度）">3.3 饱和度（纯度）</h3><p>色彩纯度，是指原色在色彩中所占据的百分比。纯度用来表现色彩的浓淡和深浅。纯度是深色、浅色等色彩鲜艳度的判断标准。</p><p>彩色系中，常用彩度或者饱和度表示，而黑白的纯度，则可以称之为灰度。</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 5.png)</p><h3 id="3-4-明度">3.4 明度</h3><p>是指色彩的明暗、深浅程度的差别，它取决于反射光的强弱。它包括两个含义：一是指一种颜色本身的明与暗，二是指不同色相之间存在着明与暗的差别</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 6.png)</p><h3 id="3-5-三原色">3.5 三原色</h3><p>三原色指色彩中不能再分解的三种基本颜色，我们通常说的三原色，是颜料三原色以及光学三原色。</p><ul><li>光学三原色（RGB）：红、绿、蓝(靛蓝)。光学三原色混合后，组成显示屏显示颜色，三原色<strong>同时相加为白色</strong>，白色属于无色系（黑白灰）中的一种。(下图左)</li><li>颜料三原色（CMY）：绘画色彩中最基本的颜色为三种，即红(品红Magenta)、黄（柠檬黄Yellow）、蓝（青Cyan），称之为原色。(下图右)</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/5aaa9868-e176-4eaf-aa73-0d82bf5cf40e.png" alt=""></p><h3 id="3-6-间色">3.6 间色</h3><p>三原色中任何的两种原色作等量混合调出来的颜色叫做间色，亦称作第二次色</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e9d13421-6887-4e1b-90bf-b5f7e69231dd.png" style="zoom: 33%;" /><h3 id="3-7-复色">3.7 复色</h3><p>任何两种间色（或一个原色与一个间色）混合调出的颜色则称复色，亦称再间色或第三次色。（黑色的深灰黑色，所以任何一种颜色与黑色混合得到都是复色。即凡是复色都有红、黄、蓝三原色的成分）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/17c62f0c-79cd-4169-aacf-9ff49b464251.png" style="zoom:50%;" /><h3 id="3-8-同类色">3.8 同类色</h3><p>同一色相中不同倾向的系列颜色被称为同类色。如黄色中可分为柠檬黄、中黄、橘黄、土黄等，都称之为同类色</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 7.png)</p><h3 id="3-9-互补色">3.9 互补色</h3><p>色相环中相隔180度的颜色,被称为互补色。如：红与绿，蓝与橙，黄与紫互为补色。<strong>补色相减</strong> ( 如颜料配色时，将两种补色颜料涂在白纸的同一点上 ) 时，就成为黑色；<strong>补色并列时，会引起强烈对比的色觉</strong>，会感到红的更红、绿的更绿，如将补色的饱和度</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 8.png)</p><h3 id="3-10-对比色">3.10 对比色</h3><p>对比色是人的视觉感官所产生的一种生理现象，是视网膜对色彩的平衡作用。指在24色相环上相距120度到180 度之间的两种颜色，称为对比色</p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 9.png)</p><h3 id="3-11-冷暖色">3.11 冷暖色</h3><p>冷暖色(Cool/Cold &amp; Warm colour) 指色彩<strong>心理上的冷热感觉</strong>。红、橙、黄、棕等色往往给人热烈、兴奋、热情、温和的感觉，所以将其称为暖色。绿、蓝、紫等色往往给人镇静、凉爽、开阔，通透的感觉，所以将其称为冷色。</p><p>色彩的冷暖感觉又被称为冷暖性。色彩的<strong>冷暖感觉是相对的</strong>，除橙色与蓝色是色彩冷暖的两个极端外，其他许多色彩的冷暖感觉都是相对存在的。比如说紫色和黄色，紫色中的红紫色较暖，而蓝紫色则较冷。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/455f284c-32f6-4fb9-8f2a-6d6f8de9cbd4.png" alt="" style="zoom:50%;" /><h3 id="3-12-色彩的视觉心理学">3.12 色彩的视觉心理学</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/6dcaaaa3-e498-4387-826f-94253ca06ef0.png" alt=""></p><h3 id="3-13-游戏中的色彩">3.13 游戏中的色彩</h3><p>色彩在游戏中是非常重要的，可以唤起情感的强大方式，塑造品牌和潮流，增加视觉层次，体现时间的发展等</p><p><strong>资料：游戏设计里的色彩学剖析</strong> <a href="https://www.sohu.com/a/27523401_168553">https://www.sohu.com/a/27523401_168553</a></p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/b46c3584-b383-4c3d-83cb-a945defc2fb0.jpeg" alt=""></p><h2 id="4-构图">4 构图</h2><blockquote><p>是一个造型艺术术语，即创作时根据题材和主题思想的要求，把要表现的形象适当地组织起来，构成一个协调的完整的画面。</p></blockquote><h3 id="4-1-构图的来历和目的">4.1 构图的来历和目的</h3><p>构图的名称，来源于西方的美术，其中有一门课程在西方绘画中，叫做构图学。<br>构图这个名称在我国国画画论中，不叫构图，而叫<strong>布局</strong>，或叫经营位置。也就是说，摄影构图是从美术的构图转化而来，我们也可以简单的称它为取景。</p><p><strong>研究在一个平面上处理好三维空间——高、宽、深之间的关系，以突出主题，增强艺术的感染力。构图处理是否得当，是否新颖，是否简洁，对于艺术作品的成败关系很大。</strong></p><h3 id="4-2-构图的形式">4.2 构图的形式</h3><ol><li><p>水平式（安定有力感）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/08844a62-4b53-4455-a481-62358a9701f7.jpeg" style="zoom:50%;" /></li><li><p>垂直式（严肃端庄）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/d1d79f50-ab15-45fd-a274-445d24f2bec2.jpeg" style="zoom:50%;" /></li><li><p>S形（优雅有变化）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/a766c771-0a98-44b3-a47f-8e44a965548a.jpeg" style="zoom:50%;" /></li><li><p>三角形（正三角较空，锐角刺激）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2e282b5c-6e5d-4e1a-838f-180b1a74f121.jpeg" style="zoom:50%;" /></li><li><p>长方形（人工化有较强和谐感）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/9c6e87dc-1a07-4015-9431-9bcb72adeb1e.jpeg" style="zoom:50%;" /></li><li><p>圆形（饱和有张力）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/60f9ad0d-ddc7-49a6-b4d7-42fedf038695.jpeg" style="zoom:50%;" /></li><li><p>辐射（有纵深感）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e800377a-afec-4bdf-ac95-7366be339e75.jpeg" style="zoom:50%;" /></li><li><p>中心式（主体明确，效果强烈）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/d6a9f1be-a356-4877-a7c0-2fc135643c5d.jpeg" style="zoom:50%;" /></li><li><p>渐次式（有韵律感）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/0b10c9fa-86ab-46ef-a4c1-6438be29b3ed.jpeg" style="zoom:50%;" /></li><li><p>散点式（自由可向外发展）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/323ff1c9-c270-48df-aa71-8bfc5493af96.jpeg" style="zoom:50%;" /></li></ol><h3 id="4-3-游戏中的构图">4.3 游戏中的构图</h3><p>旷野之息中使用的三角设计原则：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/286658c8-3f6e-4587-9a9f-6dd0e7f35632.jpeg" style="zoom:50%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/0d0af094-bf57-4e9a-9f51-df4305c3b80a.jpeg" style="zoom:50%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/b3a15a78-d8ab-495d-8bc4-55ac2e4cde33.jpeg" style="zoom:50%;" /><p>设计师把原本的比较有规律的地图加入了大量三角形设计的景物，玩家在体验游戏的过程中，视线会被遮挡，进而影响游戏体验——给玩家一种“柳暗花明又一村”的感觉</p><p>其中的三角形设计的原则，其实就和构图中的前后中景遮挡关系是一致的</p><h2 id="5-镜头语言">5 镜头语言</h2><h3 id="5-1-什么是镜头语言">5.1 什么是镜头语言</h3><p>镜头语言就是用镜头像语言一样去表达我们的意思，我们通常可经由摄影机所拍摄出来的画面看出拍摄者的意图，因为可从它拍摄的主题及画面的变化，去<strong>感受拍摄者透过镜头所要表达的内容</strong>。</p><p>而<strong>蒙太奇</strong>（Montage）在法语是“<strong>剪接</strong>”的意思，但到了俄国它被发展成一种电影中镜头组合的理论，在涂料、涂装行业蒙太奇也是独树一帜的艺术手法和自由式涂装的含义。</p><h3 id="5-2-镜头的一些概念">5.2 镜头的一些概念</h3><ul><li>广角镜头：镜头视角大，视野宽阔。从某一视点观察到的景物范围要比人眼在同一视点所看到的大得多；景深长，可以表现出相当大的清晰范围；能强调画面的透视效果，善于夸张前景和表现景物的远近感，这有利于增强画面的感染力</li><li>长焦距镜头：是指比标准镜头的焦距长的摄影镜头。视角小,景深短,透视效果差（焦距小）</li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/011b56b3-1e21-47d0-901c-e24b39ac8447.png" style="zoom:80%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/341e7f0e-7194-4d24-a479-e9515378f852.png" style="zoom:80%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/1a10d56b-28c3-44c1-8154-e49ea6bf5aed.png" alt="1a10d56b-28c3-44c1-8154-e49ea6bf5aed.png" style="zoom:80%;" /><h3 id="5-3-镜头语言的常用手法">5.3 镜头语言的常用手法</h3><ol><li><p>拉</p><p>拉摄是摄像机<strong>逐渐远离</strong>被摄主体，或变动镜头焦距使画面框架由近至远与主体拉开距离的拍摄方法。用这种方法拍摄的画面叫拉镜头。</p></li><li><p>移</p><p>移摄是将摄像机<strong>架在活动物体上随之运动</strong>而进行的拍摄。用移动摄像的方法拍摄的电视画面称为移动镜头，简称移镜头。</p></li><li><p>跟拍</p><p>跟摄是<strong>摄像机始终跟随运动的被摄主体一起运动</strong>而进行的拍摄。用这种方式拍摄的画面称跟镜头。</p></li><li><p>摇</p><p>摇摄是指当摄像机机位不动，借助于三角架上的活动底盘或拍摄者自身的人体，变动摄像机光学镜头轴线的拍摄方法。用摇摄的方式拍摄的画面叫摇镜头。（<strong>旋转摄像机的角度，不做平移</strong>）</p></li><li><p>升降镜头</p><p>摄像机借助升降装置等一边升降一边拍摄的方式叫升降拍摄。用这种方法拍摄到的画面叫升降镜头（<strong>y轴上平移</strong>）</p></li><li><p>推</p><p>推镜头是摄像机向被摄主体方向推进，或者变动镜头焦距使画面框架由远而近向被摄主体不断接近的拍摄方法。用这种方式拍摄的运动画面，称为推镜头。</p></li></ol><h3 id="5-4-游戏中的镜头语言">5.4 游戏中的镜头语言</h3><p>《战神4》中为了能够<strong>拉近玩家和游戏角色的距离</strong>，使得游戏感觉<strong>更加紧张</strong>采用的<strong>过肩视角</strong></p><p>![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 10.png)</p><p>塞尔达旷野之息的开场在一组跟拍后拉起镜头，直接为玩家展示了海拉鲁大陆，并且原处的城堡直接点明了游戏的目的  ![](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 11.png)</p><h2 id="6-游戏美术概念设计">6 游戏美术概念设计</h2><h3 id="6-1-什么是游戏美术概念设计">6.1 什么是游戏美术概念设计</h3><p>概念设计是由<strong>分析用户、策划、制作人需求到生成概念产品</strong>的一系列有序的、可组织的、有目标的设计活动，它表现为一个由粗到精、由模糊到清晰、由抽象到具体的<strong>不断进化</strong>的过程。</p><p>风格是由<strong>艺术品的独特内容与形式相统一</strong>，作为创作主体的艺术家的<strong>个性特征</strong>与由作品的题材、体裁以及社会、时代<strong>等历史条件决定的客观特征相统一而形成的</strong>。</p><p>那么美术风格概念设计就是通过题材，体裁以及社会、时代等历史条件的有序的、可组织的、有目标的设计活动。</p><h3 id="6-2-如何确定游戏的美术风格">6.2 如何确定游戏的美术风格</h3><p>一：<strong>看清自己的用户群</strong><br>每种风格都有它的特定喜爱群体，不同的用户群体自然就有不同的审美需求。</p><p>二：<strong>题材和风格都是为了游戏本身的理念而服务的</strong><br>以荒野大镖客为例：为了追求极致的沉浸式体验，比如在大镖客里猎杀小动物和猎杀某一大型动物所要用的武器是有不同要求的，还有对射击动物的部位，它形成的伤口大小都会对皮毛的品质造成影响，那美术风格肯定要有代入感，也就是要极度真实。</p><p>三：<strong>平台的性能技术有时也会限制住一些理念的表达</strong><br>例如勇者斗恶龙11在PS4和3DS上的风格表现则是完全不同</p><h3 id="6-3-常见的游戏美术风格">6.3 常见的游戏美术风格</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/52c66a8a-9339-4d5b-bc40-c22bd7ce414c.jpeg" alt=""></p><h2 id="7-参考资料">7 参考资料</h2><p>《绘画论》-莱奥纳多·达·芬奇</p><p>《Framed ink》-Marcos Mateu-Mestre （漫画分镜）</p><p>《色彩与光线》</p><p>《绘画构图学》</p><p>以及一些博客：</p><p><a href="https://zhuanlan.zhihu.com/p/74528925">https://zhuanlan.zhihu.com/p/74528925</a></p><p><a href="https://zhidao.baidu.com/">https://zhidao.baidu.com/</a></p><p><a href="http://www.360doc.com/userhome/64191223">http://www.360doc.com/userhome/64191223</a></p><p><a href="https://www.blenderguru.com/tutorials/understanding-colors">https://www.blenderguru.com/tutorials/understanding-colors</a></p><p><a href="https://www.sohu.com/a/230495235_100102240">https://www.sohu.com/a/230495235_100102240</a></p><p><a href="https://wenku.baidu.com/view/97134e0d844769eae009edc7.html">https://wenku.baidu.com/view/97134e0d844769eae009edc7.html</a></p><p><a href="https://www.sohu.com/a/27523401_168553">https://www.sohu.com/a/27523401_168553</a></p><p><a href="https://www.zhihu.com/question/22530411">https://www.zhihu.com/question/22530411</a></p><h2 id="8-常用美术术语">8 常用美术术语</h2><ul><li>脏：画面不通透，颜色关系上的脏指颜色偏暗纯度偏低、素描关系上的脏指体现在调子上的脏</li><li>乱：线条关系不明确，乱麻麻的感觉</li><li>散：独立分布的内容过多</li><li>光影：物体在不同受光面的明暗变化</li><li>黑白灰：指暗面、亮面、灰面</li><li>明暗五调子：高光、明暗交界线、亮面、灰面、暗面</li><li>飘了：光影有问题（阴影或AO）、不通透不立体</li><li>透视：指在平面上表现立体感、空间感的方法</li><li>色调/色相：平常人们理解的颜色，是色彩最显著的特种，为不同波长的色彩被感知的结果</li><li>饱和度/纯度：色彩的纯度，指原色在色彩中所占的百分比</li><li>明暗：色彩的明暗、深浅程度的差别，取决于反射光的强弱</li><li>三原色：色彩中不能再分解的三种基本颜色，光学三原色—红绿蓝，颜料三原色—红黄蓝</li><li>间色：三原色中的任何两种原色作等量混合调出的颜色</li><li>复色：任何两种间色（或者一种间色与一种原色）混合调出的颜色称为复色（也称再间色、第三次色）</li><li>同类色：同一色相中不同倾向的系列颜色被称为同类色</li><li>互补色：色环中相隔180°的颜色</li><li>对比色：24色色环上相距120°~180°的两种颜色</li><li>构图：在平面的物质空间上，根据构思中预想的形象和审美效果，安置和处理审美客体的位置与关系，将个别或局部的形象组成整体的艺术手法</li><li>轮廓：指绘画中界定描绘对象形状、大小、粗细、高低等基本范围的边缘线</li><li>体积感：体积感是指画中所描绘的物体给人的一种占有立体空间的感觉</li><li>空间感：空间感是在绘画中，依照透视法所营造出来的物体之间的稠密、远近、高下等空间关系，是画面中所体现出的立体感和纵深度如何的一个层面，也是绘画中构图、布局成败的一个重要标准</li><li>塑造能力：形和体和结构的准确能力既是塑造能力，形就是物体的剪影，体则是形的体积，结构即是连续相组合的体积</li><li>质感：质感是指绘画等造型艺术中，通过色彩的光亮、冷暖以及线条的粗细等不同的表现手法，在作品中所表现的各种物体所具有的内在特性和秉性</li><li>量感：量感，绘画术语。指画面上借助线条、色彩、明暗等造型因素，所表现出的描绘对象厚重、轻薄、稠密、大小等各种感觉</li><li>调子：光线强度的物理特征，是形体中的面所反映光的数量，也就是面的深浅度。他是表现形体、立体、空间、质量等的要素，是塑造的重要手段</li><li>笔触：绘画中的笔法。又称肌理，常指油画和水粉画中运笔的痕迹不同的笔触感觉有不同的特征，表现为画家的艺术风格和个性</li></ul>]]></content>
    
    
    <summary type="html">光影、透视、色彩、构图、镜头语言、概念设计的相关基础，以及一些常用的美术术语</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="美术理论" scheme="https://himoqiuhan.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"/>
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形3.1 深度测试和模板测试）</title>
    <link href="https://himoqiuhan.github.io/2023/06/20/Notes-TA100T-8/"/>
    <id>https://himoqiuhan.github.io/2023/06/20/Notes-TA100T-8/</id>
    <published>2023-06-20T04:01:11.000Z</published>
    <updated>2023-07-01T07:48:16.736Z</updated>
    
    <content type="html"><![CDATA[<h1>笔记链接：<a href="https://emerald-sunscreen-d5d.notion.site/3-1-00295801c7794f6992f409d6e1184b6a?pvs=4">3.1 深度测试和模板测试</a></h1>]]></content>
    
    
    <summary type="html">深度测试与模板测试的基础知识以及一些案例，其中还有关于Early-Z技术的概述</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形2.9 GPU硬件架构及运行机制）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-7/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-7/</id>
    <published>2023-06-14T04:01:11.000Z</published>
    <updated>2023-07-01T01:59:01.028Z</updated>
    
    <content type="html"><![CDATA[<h1>2.9 深入GPU硬件架构及运行机制</h1><h1>前言问题及快速索引：</h1><p>先是我课前的回答，然后再等上课时或者上课后修正</p><ol><li><p>GPU是如何与CPU协调工作的？</p><p><a href="#CPU-GPU%E7%9A%84%E5%BC%82%E6%9E%84%E7%B3%BB%E7%BB%9F">CPU与GPU的异构系统</a></p></li><li><p>GPU也有缓存机制吗？有几层？他们的速度差异多少？</p><p>[GPU内存架构](##7.1 GPU内存架构)</p></li><li><p>GPU的渲染流程有哪些阶段？他们的功能分别是什么？</p><p>[GPU渲染流程](##2.2 完整渲染流程)</p></li><li><p>Early-Z技术是什么？发生在哪个阶段？这个阶段还会发生什么？</p><p>[Early-Z](#3 Early-Z)</p></li><li><p>SIMD和SIMT是什么？他们的好处是什么？co-issue呢？</p><p><a href="##SIMD">SIMD</a>、<a href="##SIMT">SIMT</a>、<a href="##co-issue">co-issue</a></p></li><li><p>GPU是并行处理的吗？若是，硬件层是如何设计和实现的？</p><p><a href="#CPU%E4%B8%8EGPU%E7%9A%84%E5%AF%B9%E6%AF%94">CPU与GPU的对比</a>、<a href="##GPU%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B1%E6%80%A7">GPU架构的共性</a></p></li><li><p>GPC、TPC、SM是什么？Warp又是什么？它们和Core、Thread之间的关系如何？</p><p><a href="##GPU%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B1%E6%80%A7">GPU架构的共性</a></p></li><li><p>顶点着色器（VS）和像素着色器（PS）可以是同一处理单元吗？为什么？</p><p>可以，用的都是Core</p></li><li><p>像素着色器（PS）的最小处理单元是1像素吗？为什么？会带来什么影响？</p><p>[渲染流程14](##2.2 完整渲染流程)</p></li><li><p>Shader中if、for等语句会降低渲染效率吗？为什么？</p><p>[渲染流程14](##2.2 完整渲染流程)</p></li><li><p>如下图，渲染相同面积的图形，三角数量少（左）的还是数量多的（右）的效率更快？为什么？</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="Untitled"></p><ul><li>答案是：同一个像素块如果分属不同的三角形，就会分配到不同的SM进行处理。由此推断，相同面积的区域，如果所属的三角形越多，就会导致分配给SM的次数越多，消耗的渲染性能也越多。</li></ul></li><li><p>GPU Context是什么？有什么作用？</p><p>[GPU Context](#9 GPU Context和延迟)</p></li><li><p>造成渲染瓶颈的问题很可能有哪些？该如何避免或优化他们？</p><p>[总结及渲染优化建议](10 总结及渲染优化建议)</p><ol><li>数据传输的带宽问题：优化模型、压缩贴图</li><li>CPU切换渲染状态过于频繁：合并使用同一材质的模型，减少场景中的材质总数</li><li>GPU性能限制：降低画质</li></ol></li></ol><h1>1 GPU硬件架构</h1><h2 id="1-1-GPU是什么">1.1 GPU是什么</h2><p>GPU全称Graphics Processing Unit，图形处理单元。</p><p>是专门用于绘制图像和处理图元数据的特定芯片</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/471fb59b-e239-45a7-a861-61cffb1d35cb.jpeg" alt="2.9-1 NVIDIA GPU芯片实物图"></p><p>NVIDIA GPU芯片实物图</p><h2 id="1-2-GPU物理架构">1.2 GPU物理架构</h2><ul><li><p>由于纳米工艺的引入，GPU可以将数以亿计的晶体管和电子器件集成在一个小小的芯片内。从宏观物理结构上看，现代大多数桌面级GPU的大小跟数枚硬币等同大小，部分甚至比一枚硬币还小。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/3705924a-5482-4a7e-8011-1f2eaa9e38df.png" alt="2.9-2"></p></li><li><p>当GPU结合散热风扇、PCI插槽、HDMI接口等部件之后，就组成了显卡</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/21140ab7-1507-48de-9284-b1c19032c9ea.png" alt="2.9-3"></p></li><li><p>显卡不能独立工作，需要装载在主板上，结合CPU、内存、显存等硬件设备组成完整的PC机</p></li></ul><h2 id="1-3-GPU硬件架构">1.3 GPU硬件架构</h2><h3 id="NVIDIA-GPU架构发展关键点">NVIDIA GPU架构发展关键点</h3><ul><li>2008 - Tesla<ul><li>Tesla最初是给计算处理单元使用的，应用于早期的CUDA系列显卡芯片中，并不是真正意义上的普通图形处理芯片。</li></ul></li><li>2010 - Fermi<ul><li>Fermi是第一个完整的GPU计算架构。首款可支持与共享存储结合纯cache层次的GPU架构，支持ECC的GPU架构。</li></ul></li><li>2014 - Maxwell<ul><li>其全新的立体像素全局光照 (VXGI) 技术首次让游戏 GPU 能够提供实时的动态全局光照效果。基于 Maxwell 架构的 GTX 980 和 970 GPU 采用了包括多帧采样抗锯齿 (MFAA)、动态超级分辨率 (DSR)、VR Direct 以及超节能设计在内的一系列新技术。</li></ul></li><li>2018 - Tering<ul><li>Turing 架构配备了名为 RT Core 的专用光线追踪处理器，能够以高达每秒 10 Giga Rays 的速度对光线和声音在 3D 环境中的传播进行加速计算。Turing 架构将实时光线追踪运算加速至上一代 NVIDIA Pascal™ 架构的 25 倍，并能以高出 CPU 30 多倍的速度进行电影效果的最终帧渲染。2060系列、2080系列显卡也是跳过了Volta<strong>直接选择了Turing架构。</strong></li></ul></li></ul><h3 id="NVIDIA-Tesla架构">NVIDIA Tesla架构</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/cd66d1dc-5f85-4259-80de-6d1cd1c8f14b.png" alt="2.9-4"></p><ul><li>拥有7组TPC (Texture Process Cluster, 纹理处理簇)</li><li>每个TPC有两组SM (Stream Multiprocessor — 流多处理器)</li><li>每个SM包含：<ul><li>8个SP (Streaming Processor — 流处理器)</li><li>2个SFU (Special Function Unit — 特殊函数单元)</li><li>L1缓存、MT Issue（多线程指令获取）、C-Cache（常量缓存）、共享内存</li></ul></li><li>除了TPC核心单元，还有与显存、CPU、系统内存交互的各种部件</li></ul><h3 id="NVIDIA-Fermi架构">NVIDIA Fermi架构</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/b9966bc7-2ca2-4fa7-bb96-279eb2f9e35f.png" alt="2.9-5"></p><ul><li>拥有16个SM<ul><li>2个Wrap Schedual（线程束）</li><li>两组共32个Core</li><li>16组加载存储单元（LD/ST）</li><li>4个特殊函数单元（SFU）</li><li>分发函数（Dispatch Unit）</li></ul></li><li>每个Core：<ul><li>1个FPU（浮点数单元）</li><li>1个ALU（逻辑运算单元）</li></ul></li></ul><h3 id="NVIDIA-Maxwell架构">NVIDIA Maxwell架构</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/ce61c7b2-8a10-4509-81b0-7372b4d8b991.png" alt="2.9-6" style="zoom:80%;" /><ul><li>采用Maxwell的GM204拥有4个GPC（Graphics Process Cluster — 图形处理簇）</li><li>每个GPC有4个SM，对比Tesla架构来说，在处理单元上有了很大的提升</li></ul><h3 id="NVIDIA-Turning架构">NVIDIA Turning架构</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/11c0c83b-1c03-459d-b753-1ad1d843fe28.png" alt="2.9-7" style="zoom: 25%;" /><ul><li>6个GPC（图形处理簇）</li><li>36个TPC（纹理处理簇）</li><li>72个SM（流多处理器）</li><li>每个GPC有6个TPC，每个TPC有2个SM</li><li>4608个CUDA核</li><li>72个 RT核</li><li>288个纹理单元</li><li>12x32位GDDR6内存控制器（共384）</li></ul><p>其中每个SM的结构如下：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/024272b6-85bb-4f1b-a3ab-6a03f52bf28e.png" alt="2.9-8" style="zoom: 50%;" /><ul><li>64个CUDA核<ul><li>CUDA是NVIDIA推出的统一计算架构</li></ul></li><li>8个Tensor核<ul><li>Tensor Core是专门为执行张量或矩阵运算而设计的专用执行单元</li></ul></li><li>256KB寄存器文件</li><li>RT Core</li></ul><h3 id="GPU架构的共性">GPU架构的共性</h3><ul><li>GPC：图形处理蹙</li><li>TPC：纹理处理簇</li><li>Thread：线程</li><li>SM、SMX、SMM（Stream Multiprocessor，流多处理器）</li><li>Warp线程束、Warp Scheduler（Wrap编排器）</li><li>SP（Streaming Processor，流处理器）</li><li>Core（执行数学运算的核心）</li><li>ALU（逻辑运算单元）</li><li>FPU（浮点数单元）</li><li>ROP（Render Output Unit，渲染输出单元）</li><li>Load/Store Unit（加载存储单元）</li><li>L1 Cache（L1缓存）</li><li>L2 Cache（L2缓存）</li><li>Shared Memory（共享内存）</li><li>Register File（寄存器）</li></ul><p>GPU为什么会有那么多层级且有那么多雷同的部件？因为GPU的任务是天然并行的，现代GPU的架构皆是以<strong>高度并行能力</strong>而设计的</p><p>核心组件结构：</p><ul><li>包含关系：GPC→TPC→SM→CORE</li><li>SM中包含Poly Morph Engine（多边形引擎）、L1 Cache（L1缓存）、Shared Memory（共享内存）、Core（执行数学运算的核心等）</li><li>CORE中包含ALU、FPU、Execution Context（执行上下文）、Detch、Decode（解码）</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/7dcde62d-8d2c-49d3-8c48-56ffb9219178.png" alt="2.9-9"></p><h1>2 GPU的运行机制</h1><h2 id="2-1-GPU渲染总览">2.1 GPU渲染总览</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/678d15f1-0a7c-4e5f-86b8-dd155f234197.png" alt="2.9-10 Fermi架构运行机制总览" style="zoom: 50%;" /><p>Fermi架构运行机制总览</p><p>从Fermi开始NVIDIA使用类似的原理架构，使用一个Giga Thread Engine来管理所有正在进行的工作，GPU被划分成多个GPCs（Graphics Processing Cluster），每个GPC拥有多个SM（SMX、SMM）和一个光栅化引擎（Raster Engine）。他们其中有很多的连接，最显著的是Crossbar，它可以连接GPCs和其他功能性模块（例如ROP或其他子系统）</p><p>程序员编写的shader是在SM上完成的，每个SM包含许多为线程执行数学运算的Core（核心）。例如，一个线程可以是顶点或像素着色器驱动，Warp Schedule管理一组32个线程作为Warp（线程束），并将要执行的指令移交给Dispatch Units</p><p>GPU中实际有多少这些单元（有多少个GPC，每个GPC有多少个SM……）取决于芯片配置本身</p><h2 id="2-2-完整渲染流程">2.2 完整渲染流程</h2><ol><li>首先，场景中的模型包含了mesh数据，位置信息等，经过camera的粗粒度裁剪获得真正需要显示在屏幕中的模型。程序通过图形API（DX、GL、WEBGL）发出drawcall指令，指令会被推送到程序驱动，驱动会检查指令的合法性，然后会把指令放到GPU可以读取的Pushbuffer中</li><li>经过一段时间或者显式调用flush指令后，驱动程序把Pushbuffer的内容发送给GPU，GPU通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令</li><li>在图元分配器（Primitive Distributor）中开始工作分配，处理indexBbuffer中的顶点产生三角形分成批次（batches），然后发送给多个GPCs。这一步的理解就是提交上来n个三角形，分配给这几个GPC同时处理。</li></ol><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2be8e11c-e5ab-4cc7-af39-81180307b26a.png" alt="2.9-11"></p><p>这一阶段的理解就是场景中的数据包括vbo，cbuffer等已经提交到GPU，GPU通过指针绑定到对应的数据层面上通过GPC开始同时处理。</p><ol start="4"><li><p>在GPC中，每个SM中的Poly Morph Engine负责通过三角形索引（Triangle Indices）取出三角形的数据（Vertex Data），即下图中的Vertex Fetch模块</p></li><li><p>在获取数据之后，SM会以32个线程（Thread）为一组，组成一个线程束（Wrap），开始处理顶点的数据</p><ul><li><p>Wrap是典型的<strong>单指令，多线程（Single instruction, multiple thread - SIMT）</strong>，32个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个Wrap只需要一套逻辑，对指令进行解码、执行即可，芯片可以做得更小更快，因为GPU处理的任务是天然并行的</p></li><li><p>SIMT与SIMD(单指令多数据)的差别：简而言之就是输入一个vec4进行计算时，SIMT会把vec4拆分为四个float进行计算，执行4次cycle，而SIMD则是进行一次计算，执行1次cycle。在负责计算的情况下，SIMT相比于SIMD，对开发者和编译器的要求更低，更好优化<br>资料：<a href="https://zhuanlan.zhihu.com/p/113360369">https://zhuanlan.zhihu.com/p/113360369</a></p><ol><li><p>2、从一个线程角度看。从我的研究看，SIMD一般是这样实现的，一个线程处理一条指令，这条指令是向量化处理的。例如一个32bit位宽的4维向量vec4，一条指令最快就在一个cycle执行完。那SIMT，最快要用4个cycles来完成。在SIMT的架构上，会把vec4分解开，然后一个cycle处理完一个数据。所以最快需要4个cycle。好了这里我们讲的是一个线程的情况看，但从这个角度，大家可能都觉得SIMD效率更高。</p></li><li><p>2、单个线程的SIMD核SIMT逻辑单元对比。从上述中看，基本可以认为单个线程看，SIMD相对SIMT需要4倍的逻辑单元。这里的逻辑单元可以认为是最基本的逻辑计算单元。当然也可以理解为单个线程的面积SIMD基本接近SIMT的4倍面积。</p></li><li><p>4、单核同时多线程SIMD和SIMT同等算力对比。很显然SIMD的线程个数是SIMT线程的n分之一就可能实现同等算力。为了达到这种情况，算法的实现必须严格的按照n维的整数倍来实现。</p></li><li><p>5、SIMD在线程越来越多的时候不在有优势。很显然，随着线程越来越多，SIMD如果单纯把向量维度增加的话，会出现vec16。对于这么长维度的话，浪费可能越来越多。因此有些架构可能会对16个线程分成4组的SIMD。然后线程打包成4组一个包。</p></li><li><p>6、SIMT在多线程的不足。因为SIMT始终是同一条指令的，从寄存器角度看就是PC指针始终是一样的。如果线程太多的时候，有些线程需要分支跳转（if-else），那么效率就会降低，所以很多GPU对分支计算一般耗时是多个分支的总和。</p></li></ol></li></ul></li></ol><p>![2.9-12](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 1.png)</p><ol start="6"><li><p>SM的warp调度器会按照顺序分发指令给整个warp，单个warp中的线程会锁步（lock-step）执行各自的指令（同一时间执行相同的指令） ，如果线程碰到不被执行的情况也会被遮掩（be masked out）</p><ul><li><p>被遮掩的原因有很多，比如当前的指令是if-true的分支，但是当前线程的数据条件是false；或者循环的次数不一样，比如说for的循环次数N不是一个常量，他是一个动态被计算出来的量，或是被break提前终止但是别的线程还在走。因此，shader中分支会显著增加时间消耗，在一个warp，32个线程中，除非都走到true或false力，否则相当于所有的分支都走一遍。线程不能独立执行指令，而是以一个warp中32个线程为单位，只有每个warp间才是独立的。</p></li><li><p>可以这样理解：在shader执行过程中，如果这一片32个线程，同时存在true或是false的情况，由于这32个线程是锁步的，那么true和false这两个指令他都会依次执行，只不过它的计算结果会被他的条件所遮蔽。更进一步，此为动态分支；那么静态分支呢？就是同一个warp中32个线程所有都走到同一个分支，即如果我们确保这32个分支里面所有都是true或是所有都是false的情况的话，那么他只会走单个分支。在这个分支执行完毕后，继续执行下一个指令。</p></li><li><p>变体的执行状况其实和if的判断情况比较相似，比如说我们要执行变体一中的方法，相当于就是一个if true，这时候我们其实可以把它改造成使用if shader中的一个属性或者公共变量来做判断，这样可以减少变体的数量。比如说shader的属性中设置一个变量它的范围是0~1，对应我们的一个变体， 然后我么写一个判断：if (x &lt; 1)，当我们把他设置成0的时候，我们就可以保证所有执行这个shader的线程中都是true，那么我们能够使得线程全部只执行true中的指令，从而获得使用变体相同的效果，这样就可以减少变体数量。</p></li></ul></li><li><p>而现在使用的URP管线中，他能否使用SRP Batch，关键就是相同的shader中它使用的变体是否一致</p></li></ol><p>![2.9-13](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 2.png)</p><ol start="8"><li><p>warp中的指令可以被一次完成，也可能经过多次调度。</p></li><li><p>由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp调度器可能会简单地切换到另一个没有内存等待的warp，这是GPU如何克服内存读取延迟的一个关键——只是简单地切换活动线程组</p><ul><li><p>为了加快这种切换，调度器管理的所有warp在寄存器文件中都有自己的寄存器。此处就会产生一个矛盾：如果说当我们的shader中寄存器需要的越多，就会给warp留越少的空间，导致产生越少的warp，这个时候碰到内存延迟，就只能等待，而没有可以运行的warp去切换</p></li><li><p>猜测这有些游戏GPU没吃多少但帧率就是低是因为shader里寄存器用太多了？</p></li></ul></li></ol><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/88904ac5-40a1-4534-bdb5-0bf8bdd55e8a.png" alt="2.9-14" style="zoom:80%;" /><ol start="10"><li>一旦warp完成了vertex-shader的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁减然后准备栅格化，GPU会使用L1和L2缓存来进行vertex-shader和pixel-shader的数据通信<ul><li>Viewport Transform模块的处理就是将数据从NDC变换到屏幕空间，并在此过程中进行裁剪</li></ul></li></ol><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/a6f08863-e0a6-45fc-93c1-defd1859cae0.png" alt="2.9-15" style="zoom:80%;" /><ol start="11"><li>接下来这些三角形会被分割，再分配给多个GPC，三角形的范围决定它将被分配到那个光栅引擎（Raster Engines），每个Raster Engines覆盖了多个屏幕上的tile，这等于把三角形的渲染分配到了多个tile上面。也就是像素阶段就把三角形进行了按显示的像素的划分，即把显示的数据由按三角形划分变为按显示的像素划分</li></ol><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/3270af08-6537-4145-9ab4-2c06bda94b8d.png" alt="2.9-16" style="zoom:80%;" /><ol start="12"><li><p>SM上的Attribute Setup保证了从vertex shader来的数据经过插值后是pixel shader可读的</p></li><li><p>GPC上的光栅引擎（Raster Engines）在他接收到的三角形上来工作，来负责这些三角形的像素信息生成（同时会处理背面剔除和Early-Z剔除）</p></li><li><p>32个像素线程被分成一组<strong>8个2x2的像素块</strong>（这是像素着色器上的最小工作单元，即4个像素），在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM中的warp调度器会管理像素着色器的任务。</p><ul><li><p><strong>像素着色器最小工作单元是</strong>4个像素的原因是，2x2的像素块我们可以轻易地获取2个像素之间的ddx和ddy，用于计算读取哪个层级的mipmap，从而减少我们从贴图中读取贴图数据的大小，进而降低带宽</p></li><li><p>说起mipmap，开启之后不只是增加内存，让远处部分不会有像素闪烁，因为每个层级的mipmap都是上一层及经过双线性插值或者三线性插值后的结果，其表现是连续的 。但其实他更重要的作用是减少带宽的消耗，因为在读取贴图的时候，在正常UV0-1的连续读取中，GPU会尽量将这个shader中读取这张贴图的指令拼接在一起，GPU会将贴图中第一个读取指令的uv值位置周围一片像素读进L2、L1缓存中，这就是贴图读取的预测策略。这样做的好处是由于uv的连续，会有高命中率直接获取所需uv值的颜色值；而不连续的uv值将需要获取图片中2个距离很大的区域，比如如果当前像素线程中uv值是(0,0)，那么读取贴图的时候，GPU会将索引为(0,0)周围区域的像素一并读取进L2、L1缓存中；但如果我们右边第二个像素值却是(0.5,0.5)（这在距离摄像机远的物件中，是非常常见的顶点UV插值后的结果），这样的话，我们在读取贴图的时候当前内存中不存在这个贴图的uv位置的数据，那么我们只能清空当前已经进入缓存的数据，再重新读取贴图对应uv(0.5,0.5)周围一片的像素的值，再次放入L2、L1缓存中，这就是我们经常说的缓存命中率低造成的带宽上升的问题。<br>我的理解：开启mipmap后，显卡会先计算当前像素的mipmap level，根据mipmap level去读取对应等级的贴图，让两个相邻像素的所读取的贴图位置相邻，提高Cache Hit</p></li></ul></li></ol><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled 3.png" alt="2.9-17" style="zoom: 80%;" /><ol start="15"><li><p>而接下来的操作就和vertex shader中的逻辑步骤完全一样了，但是变成了在像素着色器线程中执行。由于不耗费任何性能就可以获取一个像素内的值，导致锁步执行非常便利，所有的线程内可以保证其指令在同一点</p></li><li><p>最后一步，现在的像素着色器已经完成了颜色的计算和深度值的计算，在这个点上，我们必须考虑三角形的原始API顺序，然后才将数据移交给ROP（Render Output Unit，渲染输出单元），一个ROP内部有很多ROP单元，在ROP单元中处理深度测试和frambuffer的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误</p></li></ol><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/cd7ce2fb-d2a6-4682-9904-ecf4d818a49c.png" alt="2.9-18"></p><h1>3 Early-Z</h1><p>早期的GPU的渲染管线测深度测试是在像素着色器之后才执行的，这样会造成很多根本不可见的像素执行了耗性能的像素着色器计算。后来，为了减少像素着色器的额外消耗，将深度测试提前制像素着色器之前（如下图所示），这就是Early-Z技术的由来。Early-Z技术可以将很多无效的像素提前剔除，避免他们进入耗时严重的像素着色器。Early-Z剔除的最小单位不是1像素，而是像素块（2*2）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/c6f913dd-8850-430e-ac9d-65e1f7722680.png" alt="2.9-19" style="zoom: 67%;" /><p>但是，以下情况会导致Early-Z失效：</p><ol><li>开启Alpha Test：由于Alpha Test需要在像素着色器后的Alpha Test阶段比较（DX的discard，OpenGL的Clip），所以无法在像素着色器之前就决定该像素是否被剔除</li><li>开启Alpha Blend：启用了Alpha混合的像素很多需要与frame buffer做混合，无法执行深度测试，也就无法利用Early-Z技术。</li><li>关闭深度测试：Early-Z是建立在深度测试开启的条件下，如果关闭了深度测试，也就无法启用Early-Z技术</li><li>开启Muti-Sampling：多采样会影响周边像素，而Early-Z阶段无法得知周边像素是否被裁剪，故无法提前剔除</li><li>以及其他任何导致需要混合后面颜色的操作</li></ol><h1>4 SIMD与SIMT</h1><h2 id="SIMD">SIMD</h2><p>SIMD，Simgle Instruction Mutiple Data，是单指令多数据，在GPU的ALU单元内，一条指令可以处理多维向量（一般是4D）的数据。比如，有以下shder指令：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 c = a + b; <span class="comment">//a, b都是float4类型的数据</span></span><br></pre></td></tr></table></figure><p>对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD c.x, a.x, b.x</span><br><span class="line">ADD c.y, a.y, b.y</span><br><span class="line">ADD c.z, a.z, b.z</span><br><span class="line">ADD c.w, a.w, b.w</span><br></pre></td></tr></table></figure><p>但有了SIMD技术后，只需要一条指令就可以完成，汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIMD_ADD c,a,b</span><br><span class="line">//这就相当于for(i=0;i&lt;n;++i) a[i]=b[i]+c[i];</span><br></pre></td></tr></table></figure><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/df086102-efb2-4621-aeb2-32ea37d65ca9.png" alt="2.9-20" style="zoom:80%;" /><h2 id="SIMT">SIMT</h2><p>SIMT，Single Instruction Multiple Thread，是单指令多线程，是SIMD的升级版，可对GPU中单个SM中的多个Cire同时处理同一指令，并且每个Core存取的数据可以是不同的。</p><p>其汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIMT_ADD c,a,b</span><br></pre></td></tr></table></figure><p>上述指令会被同时送入在单个SM中被编组的所有Core中，同时执行运算，但a、b、c的值都可以不一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__void add(float *a, float *b, float *c)&#123;</span><br><span class="line">int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">a[i] = b[i] + c[i]; //no loop!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/5cfc2c48-c718-4b3e-ab63-53a60068f59f.png" alt="2.9-21" style="zoom:80%;" /><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/9aed3ff5-db7b-42e8-b4a3-59bd9609a13d.png" alt="9aed3ff5-db7b-42e8-b4a3-59bd9609a13d.png"></p><h2 id="co-issue">co-issue</h2><p>co-issue是为了解决SIMD运算单元无法充分利用的问题。例如下图，由于float数量的不同，ALU利用率从100%依次下降为75%、50%、25%</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/b6e2d7ce-fc20-4eb6-8b83-0c83f64a9c4b.png" alt="2.9-22" style="zoom: 67%;" /><p>为了解决着色器在低维向量的利用率低的问题，可以通过合并1D与3D，或合并2D与2D的指令。例如下图，DP3指令用了3D数据，ADD指令只有1D数据，co-issue会自动将他们合并，在同一个ALU中只需要一个指令周期即可执行完</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/d2ca8f1f-b223-42b4-9cec-f206f184b126.png" alt="2.9-23" style="zoom: 80%;" /><p>但是对于向量运算单元（Vetor ALU），如果其中一个变量既是操作数又是存储数的情况，无法启用co-issue技术</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/619a2a5c-4707-4fbd-bd09-bb54953a3a07.png" alt="2.9-24" style="zoom:80%;" /><h1>5 CPU与GPU的对比</h1><p>CPU是一个具有多种功能的优秀领导者，他的优点在于调度、管理、协调能力强，但计算能力一般</p><p>GPU相当于一个接受CPU调度的”拥有大量计算能力“的员工</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4302207a-2747-48d0-b58c-93b0703bcfc9.png" alt="4302207a-2747-48d0-b58c-93b0703bcfc9.png"></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/94f04abd-2836-431a-be10-921920d9ad5a.png" alt="2.9-25" style="zoom:80%;" /><h1>6 CPU-GPU的异构系统</h1><p>根据CPU和GPU是否共享内存，可分为两种类型得CPU-GPU架构：Discrete分离式架构，和Coupled耦合式架构</p><ul><li><p>分离式架构中，CPU和GPU各自有独立的缓存和内存，他们通过PCI-e等总线通讯。这种结构的缺点在于PCI-e相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC等</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/0006348d-8fd8-48fd-a5b9-2b6174882a0c.png" alt="2.9-26"></p></li><li><p>耦合式架构中，CPU和GPU共享内存和缓存。AMD的APU采用的就是这种结构，目前主要用在游戏主机中，如PS4，智能手机</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/190f0a37-8c4d-4328-b466-41da202c6fa9.png" alt="2.9-27"></p></li></ul><p>在内存管理方面，分离式结构中CPU和GPU各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU没有独立的内存，与CPU共享内存，由MMU(Memory Management unit)进行存储管理</p><h1>7 GPU资源机制</h1><h2 id="7-1-GPU内存架构">7.1 GPU内存架构</h2><p>GPU与CPU类似，也有多级缓存结构：寄存器、L1缓存、L2缓存、GPU显存、系统内存</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/237a8163-2067-4f70-bfbc-67c3acda6135.png" alt="2.9-28" style="zoom:80%;" /><p>他们的存取速度从寄存器到系统内存依次变慢。由下图可见，GPU读取寄存器时，消耗一个访问周期，而共享内存L1缓存是1~32个，L2缓存是32~64个，而纹理、常量缓存和全局内存达到了惊人的400~600</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4683eb74-02b1-40f7-b9b8-eb14eb72eb5e.png" alt="4683eb74-02b1-40f7-b9b8-eb14eb72eb5e.png"></p><p>由此可见，shader直接访问寄存器、L1、L2缓存还是比较快的，但是访问纹理、常量缓存和全局内存会非常慢，会造成很高的延迟。这也是为什么我们要增加纹理的缓存命中率，尽量避免cache-missing</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4aec7a55-008f-4586-b327-dffb24fff640.png" alt="2.9-29" style="zoom: 33%;" /><h2 id="7-2-GPU中的各个内存">7.2 GPU中的各个内存</h2><p>GPU内存分布在RAM存储芯片或者GPU芯片上，他们物理上所在的位置决定了他们的速度、大小以及访问规则</p><ul><li>全局内存（Global Memory）：位于片外存储体中，容量大，但访问延迟高、传输速度较慢，使用L2 Cache做缓存</li><li>本地内存（Local Memory）：一般位于片内存存储体中，变量、数组、结构体等都存放在此处，但是有大数组、大结构体以至于寄存器区放不下他们，编译器在编译阶段就会将他们放到片外的DDR芯片中（最好的情况也会被扔到L2 Cache中），且将他们标记为”Local“型</li><li>共享内存（Shared Memory）：位于每个流处理器组（SM）中，其访问速度仅次于寄存器</li><li>寄存器内存（Register Memory）：位于每个流处理器组（SM）中，访问速度最快的存储体，用于存储线程执行时所需的变量</li><li>常量内存（Constant Memory）：位于每个流处理器组（SM）中和片外的RAM存储器中</li><li>纹理内存（Texture Memory）：位于每个流处理器组（SM）中和片外的RAM存储器中</li></ul><h2 id="7-3-GPU资源管理模型（分离式架构）">7.3 GPU资源管理模型（分离式架构）</h2><p>首先从图右下角可知，CPU与GPU之间的交流通过MMIO进行，我们的驱动程序通过MMIO获取寄存器的状态，也通过MMIO进行数据的传输。</p><p>图中间的GPU Context，他位于驱动程序所管理的虚拟内存当中，GPU可以并存多个活跃状态下的context，也就是多个GPU上下文。</p><p>所有的contex通过page table隔离，提交命令到硬件单元，也就是GPU Channel，每个GPU Channel会关联一个context，而一个GPU Context可以提交给多个GPU Channel。</p><p>我们的指令通过channel发送到core中的执行上下文模块存储，等待调度执行。在执行完毕后，将计算结果写回虚拟内存中，然后虚拟内存通过DMA（Direct Memory Access，一种高速的数据传输操作）传输回我们的主存。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/fce9fcca-b3d3-4e99-92fc-e85578ef761d.png" alt="2.9-30" style="zoom:80%;" /><p>简单来说，CPU到GPU的数据流如下所示</p><ol><li>将主存的数据复制到显存中</li><li>CPU通过指令驱动GPU</li><li>GPU中的每个运算单元并行处理（此步会在显存上存取数据）</li><li>GPU将现存结果传回主存</li></ol><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/71b7b653-1778-488f-ad66-61a4baf9aece.png" alt="2.9-31" style="zoom:67%;" /><h1>8 硬件层面下Shader的运行机制</h1><p>执行阶段，CPU端会将已经在离线阶段编译好的shader汇编代码经由PCI-e推送到GPU端，GPU在执行代码时，会用Context将指令分成若干Channel推送到各个Core的存储空间中</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/004112f1-93e2-4c86-b2d4-0df5d799d374.png" alt="2.9-32" style="zoom: 80%;" /><p>下面就是一个假象的Core的示意图，一个GPU Core包含8个ALU，4组执行环境（Execution Context），每组执行环境有8个GPU Context。这样，一个Core可以并发(Concurrent but interleaved)执行4条指令流(Instruction Streams)，32个并发程序片元（Fragment）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4519013b-2907-42a8-b4cc-65b33e27c2ce.png" alt="2.9-33" style="zoom:80%;" /><p>以如下漫反射为例：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">sampler mySamp;</span><br><span class="line">Texture2D&lt;float3&gt; myTex;</span><br><span class="line">float3 lightDir;</span><br><span class="line"></span><br><span class="line">float4 diffuseShader(float3 norm, float2 uv)</span><br><span class="line">&#123;</span><br><span class="line">float3 kd;</span><br><span class="line">kd = myTex.Sample(mySamp, uv);</span><br><span class="line">kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> float4*kd, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行阶段，汇编代码会被GPU推送到执行上下文（Execution Context），然后ALU会逐条获取）Detch）、解码（Decode）汇编指令为二进制指令，并执行他们。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4ffd9380-f5e7-40ca-bdf4-0d8622e48ef8.png" alt="2.9-34" style="zoom: 67%;" /><p>对于SIMT架构的GPU，汇编指令有所不同，变成了SIMT特定指令代码</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/0551789e-85e9-4c68-a8b6-685eef70c801.png" alt="2.9-35" style="zoom:67%;" /><p>并且Context以Core为单位组成共享的结构，同一个Core的多个ALU共享一组Context；如果有多个Core，就会有更多的ALU同时参与shader计算，每个Core执行的数据是不一样的，可能是顶点、图元、像素等任何数据。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/296dbb35-9069-43cb-80c8-9031da0f7d8e.png" alt="2.9-36" style="zoom: 50%;" /><h1>9 GPU Context和延迟</h1><p>由于SIMT技术的引入，导致很多同一个SM内的很多Core并不是独立的，当它们当中有部分Core需要访问到纹理、常量缓存和全局内存时，就会导致非常大的卡顿（Stall）</p><p>例如下图中，有4组上下文（Context），它们共用同一组运算单元ALU。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/9b7c05c2-3a92-4352-b20d-9b523a131e14.png" alt="2.9-37" style="zoom: 50%;" /><p>假设第一组Context需要访问缓存或内存，会导致2~3个周期的延迟，此时调度器会激活第二组Context以利用ALU。当第二组Context访问缓存或内存又卡住，会依次激活第三、第四组Context，直到第一组Context恢复运行或所有都被激活</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4aa3972f-2f7c-41ee-9eba-00f6d6b6fa98.png" alt="2.9-38" style="zoom:50%;" /><p>延迟的后果是每组Context的总体执行时间被拉长了</p><p>越多Context可用就越可以提升运算单元的吞吐量，比如下图的18组Context的架构可以最大化地提升吞吐量：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/2e086ab5-1e2a-4bc3-918c-6b4b59256720.png" alt="2.9-39" style="zoom: 50%;" /><p>我们可以理解为，我们需要在shader中读取两张贴图，并且进行大量的计算。此时上下文会进行切割，尽量将不相关的计算分为不同的上下文，以便于分开执行。我们在第一组warp的32个线程指令走到读取第一个图后，它会将指针指向读取贴图的结果，然后开始切换到第二组warp中32个线程执行其余上下文。直到第二组warp又开始读取图片，这样又会激活第三组、第四组等。这样可以充分的利用我们读取图片内存卡住的一个时间</p><h1>10 总结及渲染优化建议</h1><ul><li>顶点着色器和像素着色器都是在同一个单元中执行的（在原本的架构中中vs和ps的确实分开的，后来NVIDIA把这个统一了），vs是按照三角形来并行处理的，ps是按照像素来并行处理的</li><li>vs和ps中的数据是通过L1和L2缓存传递的</li><li>warp和thread都是逻辑上的概念，sm和sp都是物理上的概念。线程束≠流处理器数</li></ul><p>优化建议：</p><ol><li>尽量使用自己扩展的几何实例化替代unity提供的静态合批、动态合批，静态合批将合并mesh增加vbo内存占用，动态合批则会增加CPU端的耗时开销</li><li>尽量减少顶点数与三角形面数，前者减少顶点着色器的运算和显存中frameData的内存存储，后者减少片元着色器的消耗</li><li>避免每帧提交buffer的数据，比如unityCPU版本的粒子系统，可使用GPU版本的粒子系统替代，将修改数据移动到GPU端；另外特别提醒的就是避免大片的透明粒子特效，这将造成严重的overdraw</li><li>减少渲染状的设置和获取，例如在Updare中获取设置shader的属性或者公共变量，因为前面提到CPU是通过MMIO获取寄存器数据，这将浪费更多的时间周期</li><li>3D物件硬使用LOD减少处理的顶点与面数的消耗，开启mipmap减少贴图缓存命中的丢失</li><li>避免AlphaTest的使用，这会导致Early-Z的失效</li><li>避免三角面过小，这会加剧overdraw的情况，也就是前面提到的一个三角形只占据3个像素点，却使用了12个线程去计算像素值，然后遮蔽其余9个的计算结果</li><li>在寄存器数量与变体数量中寻找平衡，使用if变量达成静态分支，取代变体，一方面可以减少变体数量，另一方面也可以使得URP中的SRP Batch更高效地合批</li><li>尽量避免判读分支，也就是shader中if true和false都会走的情况</li><li>减少复杂函数的调用，因为从硬件架构上可以看出特殊函数处理单元是远远少于正常计算单元的</li></ol>]]></content>
    
    
    <summary type="html">深入GPU硬件架构及运行机制</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形2.8 Flow Map流动效果实现）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-6/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-6/</id>
    <published>2023-06-14T03:52:27.000Z</published>
    <updated>2023-07-01T01:58:46.672Z</updated>
    
    <content type="html"><![CDATA[<h1>作业</h1><p>根据今天的内容，实现流动效果（与Demo不同，达到更好看的效果）</p><p>Flow Map贴图直接手绘，课程中的借助软件如Houdini的做法，更适用于开放世界那样的大场景，作业做Demo可以简单处理</p><h1>1 Flow Map是什么</h1><h2 id="1-1-基本概念">1.1 基本概念</h2><p>Flowmap实际上是一张记录了2D向量信息的纹理，flow map上的颜色（通常为RG通道）记录该处向量场的方向，让模型上某一点表现定量的特征。</p><p>通过在shader中偏移uv再对纹理进行采样，来模拟流动效果</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="2.8-1" style="zoom:45%;" /><p>![2.8-2](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 1.png)</p><p>使用flow map干扰uv坐标</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled 2.png" alt="2.8-3" style="zoom: 45%;" /><h2 id="1-2-为什么要使用flowmap">1.2 为什么要使用flowmap</h2><p>flowmap类似于UV动画，而非顶点动画。换而言之，无需对模型进行操作，易实现，运算开销小</p><p>不仅仅是水面，任何和流动相关的效果都可以采用flowmap</p><p>![2.8-4](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 3.png)</p><p>所以flowmap是一种简单高效的用于实现流动效果的方法</p><p>flowmap还可以被用于天空球上</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled 4.png" alt="2.8-5" style="zoom: 45%;" /><h1>2 flowmap shader</h1><ul><li><p>采样Flow map获得向量场信息</p><ul><li>得到的是将来用于乘time的方向信息</li><li>flowmap不能直接使用，要将色值从[0,1]的范围映射到方向向量的范围[-1,1]</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从flowmap中获取流向</span></span><br><span class="line">float3 flowDir = tex2D(_FlowMap, i.uv) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></li><li><p>用向量场信息，使采样贴图的UV随时间变化</p><ul><li>UV - time</li><li>为什么是用减法（加上一个为负数的时间）：用减法从视觉上来看，采样得到的图象是在向右移动，与直观的运算法则相同</li></ul></li><li><p>对同一张贴图以半个周期的相位差采集两次，并线性插值，使贴图流动连续</p><ul><li><p>随着时间的进行，变形越来越夸张，为了将偏移控制在一定范围内，使用frac函数进行牵制</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> phase = frac(_Time);</span><br></pre></td></tr></table></figure><p>![2.8-6](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 5.png)</p></li><li><p>这样得到的效果会“跳变”，所以就构造周期相同，相位相差半个周期的波形函数</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> phase0 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed);</span><br><span class="line"><span class="type">float</span> phase1 = frac(_Time * <span class="number">0.1</span> * _TimeSpeed + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>![2.8-7](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 6.png)</p></li><li><p>用相位差半个周期的两层采样进行加权混合，使纹一个周期重新开始时的不自然情况被另一层采样重新覆盖</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平铺贴图用的uv</span></span><br><span class="line">float2 tiling_uv = i.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用波形函数周期化向量场方向，用偏移后的uv对材质进行偏移采样</span></span><br><span class="line">half3 tex0 = tex2D(_MainTex, tiling_uv - flowDir.xy * phase0);</span><br><span class="line">half3 tex1 = tex2D(_MainTex, tiling_uv - flowDir.xy * phase1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数计算波形函数变化的权值，使得MainTex采样在接近最大偏移时有权值为0，并因此消隐，构造较平滑的循环</span></span><br><span class="line">ffloat flowLerp = <span class="built_in">abs</span>((<span class="number">0.5</span> - phase0) / <span class="number">0.5</span>);</span><br><span class="line">ffloat3 finalColor = lerp(tex0, tex1, flowLerp); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![2.8-8 其实只用看红线就行，蓝线表示tex1的权重值，红线则是1-蓝线](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 7.png)</p><p>![2.8-9](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 8.png)</p><p>有效缓解突变</p><p>我的理解：因为tex1比tex0慢半个周期，所以当tex0的偏移采样接近1时，为了降低由0→1的突变，在[0.5,1]的区间上，逐渐降低tex0的权重；与此同时，tex1不会在1时发生突变，tex1的权重则在慢慢增加。这样就很好地规避了偏移达到最大的时候跳变的问题。</p><p>同理，flowmap可以用于调整法线贴图的采样</p></li></ul></li></ul><h1>3 flowmap的制作</h1><h2 id="3-1-flowmap的烘培和相关设置">3.1 flowmap的烘培和相关设置</h2><ul><li>注意gamma矫正选项、UV匹配</li><li>flowmap贴图设置：<ul><li>无压缩或高质量</li><li>确认色彩空间</li></ul></li></ul><h2 id="3-2-Flowmap-Painter">3.2 Flowmap Painter</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled 9.png" alt="2.8-10" style="zoom: 50%;" /><ul><li>使用Flowmap Painter绘制得到的Flowmap为线性空间下的颜色（gamma1.0），不需要gamma矫正，取消勾选sRGB</li><li>否则会出现“没画的地方在流动”，“画的地方流动方向错误”等问题</li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled 10.png" alt="2.8-11" style="zoom: 80%;" /><h2 id="3-3-Houdini-Labs">3.3 Houdini Labs</h2><p>Houdini Labs是内置在Houdini中的一组游戏开发相关的节点</p><p>//等到之后要用在项目里的时候再来学吧，不然现在直接学很快也就忘了</p><p>提前记录几个关键节点：</p><ul><li>flowmap：生成一张flowmap</li><li>修改flowmap的向量场：<ul><li>flowmap_brush：手动绘制flowmap</li><li>flowmap_guide：使用绘制的曲线来控制flowmap（需要输入一条曲线）</li><li>flowmap_obstacle：让流向与物体进行碰撞检测（需要输入一个网格）</li></ul></li><li>flowmap_to_color：将flowmap向量场信息转化为颜色信息</li><li>flowmap_visual：可视化flowmap</li><li>maps_baker：烘焙（一个用于高模烘低模的节点）</li></ul>]]></content>
    
    
    <summary type="html">Flow Map流动效果实现</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形2.7 Bump图）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-5/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-5/</id>
    <published>2023-06-14T03:42:29.000Z</published>
    <updated>2023-07-01T01:58:31.019Z</updated>
    
    <content type="html"><![CDATA[<h1>作业</h1><p>结合先行版基础渲染光照介绍(一)将本次课程中所讲的案例结合进先前的光照效果中（如何将视差后的结果与IBL进行结合，尤其是暗部的表现）</p><p>还有瞳孔的实现也用到了视差映射（见下节课的OP）</p><h1>1 Bump Mapping 凹凸映射</h1><h2 id="1-1-表达物体细节的三个尺度">1.1 表达物体细节的三个尺度</h2><ul><li>宏观尺度<ul><li>覆盖很多个像素</li><li>由顶点或三角形或其他的图元来表示的，建模通常就是在宏观尺度上进行处理</li></ul></li><li>中观尺度<ul><li>覆盖几个像素</li><li>描述了宏观尺度和微观尺度之间的特征，细节比较复杂，没有办法使用单个三角形来进行渲染，但这些细节又足够大，能够让观察者看出其中的细节，比如：皮肤的褶皱，肌肉组织的细节，砖块之间的缝隙等等。</li></ul></li><li>微观尺度<ul><li>小于一个像素</li><li>表现在着色模型中，而着色模型通常在像素着色器中实现。使用纹理贴图作为参数，模拟物体表面围观几何形状的相互作用，比如高光部分在微观尺度下是光滑的，漫反射部分在微观尺度下是粗糙的</li></ul></li></ul><h2 id="1-2-凹凸映射">1.2 凹凸映射</h2><ul><li>凹凸映射就是模拟中观尺度的常用方法之一，它能让观察者感知到比几何模型的尺度更小的细节。</li><li>基本思想是将尺度细节相关的信息编码进纹理中，在着色过程中，我们用稍微受到干扰的表面去模拟真实的表面，从而模拟出表面的小尺度的细节。</li><li>从原理上讲，凹凸贴图映射技术是对物体表面贴图进行变化，然后再进行光照计算的一种技术。例如给法线分量增加噪音，或者在一个保持扰动值的纹理图中进行查找（视差映射贴图，或者浮雕贴图）</li><li>这是一种提升物体真实感的有效方法，但却不需要额外的提升物体的几何复杂度（不需要添加额外的顶点）。这种方式在提升物体的表面细节或者表面的不规则性方面有显著效果。</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="2.7-1 左侧没有使用法线贴图，右侧使用法线贴图"></p><h2 id="1-3-凹凸映射的分类">1.3 凹凸映射的分类</h2><ul><li>Bump Mapping的种类主要有：法线映射、视差映射、浮雕映射</li><li>用处广泛，可以用来增加模型细节效果，或者做一些特殊的画面表现效果</li><li>最常用的是法线映射，一般的增加法线贴图后，会对局部的物体表面进行法线扰动，进而改变明暗关系，从而达到增加表面细节的效果。</li><li>上述的三种映射都会用到法线贴图</li></ul><p>![2.7-2](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 1.png)</p><h1>2 Normal Mapping 法线映射</h1><h2 id="2-1-法线贴图">2.1 法线贴图</h2><ul><li>Normal Map 是一张存有物体局部表面法线信息的一张贴图。在计算光照的时候，程序会去读取法线图，并获取到当前像素点的法线信息，结合光线信息进行光照计算。</li><li>使用法线贴图计算光照，可以让物体表现出更加丰富的细节（小范围的明暗变化），并随着光照方向的变换实时变化。</li><li>法线贴图一般由高模映射到对应的底模上来生成。但像金属，木头等这些细节丰富的物体，可借助程序化的软件如：Photo Shop，Substance Designer等生成</li></ul><p>![2.7-3](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 2.png)</p><h2 id="2-2-切线空间">2.2 切线空间</h2><ul><li><p>法线的存储，一般会放到模型的切线空间中。</p></li><li><p>切线空间是以物体表面的<strong>切线，副切线</strong>和<strong>法线</strong>组成的几何空间</p><ul><li><p>切线空间中，坐标原点为顶点位置，顶点法线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>n</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">n</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>作为z轴，切线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>t</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8981em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8981em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">t</span></span><span style="top:-3.1841em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1522em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>和纹理坐标系一致，副切线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>b</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>则由顶点法线和切线叉乘得到</p><p>![2.7-4](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 3.png)</p></li></ul></li><li><p>计算光照时，需要把光照运算的向量放到统一坐标系下。读取切线空间法线，需要<strong>世界坐标转切线空间</strong>的转换矩阵 或 <strong>切线空间转世界空间</strong>的转换矩阵，将向量统一到同一坐标系后再进行光照操作。</p></li></ul><h2 id="2-3-世界空间和切线空间的转换-——-TBN矩阵">2.3 世界空间和切线空间的转换 —— TBN矩阵</h2><p>将<strong>世界坐标系</strong>下的顶点法线（Normal）和切线（Tangent）以及副切线（Bitangent）作为切线空间坐标系的正交基。并用这三个向量的标准正交基来构建转换矩阵。对应关系为法线作为Z轴，切线作为X轴，副切线作为Y轴。</p><p>构建一个3*3的矩阵来做空间向量的坐标系转换。一般的叫该矩阵为TBN矩阵。</p><h3 id="切线空间→法线空间">切线空间→法线空间</h3><p>在Unity中，将读取到的切线空间的法线信息右乘TBN矩阵，即可将法线从切线空间转换到世界空间</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3x3 TBN = float3x3(i.tangentDir, i.biTangentDir, i.normalDir)</span><br><span class="line">float3 worldNormal = <span class="built_in">normalize</span>(mul(localNormal, TBN));</span><br></pre></td></tr></table></figure><h3 id="世界空间→切线空间">世界空间→切线空间</h3><p>因为TBN矩阵实际上是一个旋转矩阵，而旋转矩阵是一个正交矩阵，所以TBN矩阵的逆矩阵就是TBN的转置矩阵</p><p>从世界空间转换到法线空间进行相关处理，只需要顶点右乘TBN矩阵的转置矩阵即可</p><p>![2.7-5](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 4.png)</p><p>转换完成后，就可以在相应空间中进行相关着色模型的计算处理</p><h2 id="2-4-引入切线空间的好处">2.4 引入切线空间的好处</h2><p>实际上法线存在哪个空间下都是可以的，但是实际上我们不仅仅要存储法线信息，更重要的是后续的光照计算。选择哪个坐标系意味着我们需要把光照计算用到的不同信息全部转换到对应的坐标系中。但是，使用切线空间存储法线带来的收益高过空间转换的成本。</p><p>优势：</p><ul><li><p>自由度高</p><ul><li><p>同一张法线可以作用于不同的模型</p></li><li><p>如果把法线信息存在模型空间下，得到的则是一个绝对的法线信息，这个法线信息就只是属于一个模型的法线，比如说存到下面球的模型空间下，法线就无法用于右侧的圆环中</p><p>![2.7-6](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 5.png)</p></li></ul></li><li><p>很方便实现UV动画</p><ul><li>法线在切线空间中，只是对现有现有法线的扰动。对贴图采样进行偏移时，就可以改动顶点UV实现不同的凹凸效果，进而实现uv动画。（试想一下，如果是在模型空间下，</li></ul></li><li><p>基于同样的原理，可以重用法线贴图</p><ul><li>一个立方体一面的法线贴图可以同时用在其他五个面上</li></ul></li><li><p>便于压缩</p><ul><li>在切线空间中，法线始终是垂直于表面向外。在归一化的法线向量中，他的值始终是处于0-1之间的，这样的话我们就只用存储副切线和切线，再用sqrt算出法线即可</li><li>而在模型空间中，法线可以为负，在-1到1之间，这样就不能通过只存储两个值来推导出法线的值，必须要储存三个值（否则无法指明法线的方向，因为作为贴图的颜色通道，只能存0-1的值），这样就无法压缩了。</li></ul></li></ul><h2 id="2-5-Unity中的法线贴图的压缩格式">2.5 Unity中的法线贴图的压缩格式</h2><ul><li>在unity中，非移动平台上，Unity会把法线贴图转换成DXRT5nm格式。这种格式只有两个有效通道GA通道，这样可以节省空间<ul><li>GA存储对应法线的y、x分量，z分量需要通过一个简单的运算求得。</li></ul></li><li>而移动平台Unity使用传统的RGB通道</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/c6595f3d-9e9e-4934-98b7-218523669d0f.png" alt="2.7-7 DXR5nm格式"></p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/4c6ff8af-96b4-4a4a-bc41-45df04cb94eb.png" alt="2.7-8 普通存储到RGB通道中"></p><h1>3 Parallax Mapping 视差映射</h1><h2 id="3-1-视差映射的概述">3.1 视差映射的概述</h2><ul><li>视差贴图主要用于赋予物体表面细节遮挡关系，和法线一起使用，能让效果更加逼真</li><li>视差贴图引入一张新的贴图：高度图<ul><li>高度图一般是作为顶点位移时使用的，但是模型需要包含大量的三角形才能获得比较不错的效果，否则看起来会成块状。所以如何在有限的三角面上表示令人信服的效果？这就时视差映射技术</li><li>视差映射技术核心是改变纹理坐标，但如何改变？怎么改变？这时需要一张存储模型信息的高度图，利用模型表面高度信息来对纹理进行偏移</li></ul></li><li>视角越斜，效果越明显</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e0862766-782c-48e4-9830-409d495fb6af.png" alt="2.7-9 对比右侧三张贴图可以明显看出，右边使用了视差贴图的砖墙看上去比左边单纯使用法线贴图的砖墙看上去多了遮挡的感觉，且视差贴图作用强度越高，遮挡效果越明显"></p><h2 id="3-2-视差映射的原理">3.2 视差映射的原理</h2><ul><li>视差映射主要是要让平面看起来更立体，和法线贴图一样，是欺骗眼睛的做法</li></ul><p>![2.7-10](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 6.png)</p><p>图中蓝色的线0.0为模型表面，正常情况下，我们看到的点A对应的点是黄色的线Ha对应下去的点，当但是如果我们要实现图中灰色部分那样的效果的话，我们实际看到的是B点（红色的线Hb）对应下去的点。</p><p>现在的问题是，已知A点的UV，要怎样让他（近似）采样到B点（获得B点或近似B点的UV值）？</p><ul><li><p>首先明确一点，是在改一个顶点的UV坐标值，所以说是可以知道视角和模型表面（和法线）之间的夹角的。明白这一点之后就方便理解了。</p></li><li><p>我们可以通过模型表面法线和视线方向的夹角的sin乘上这个点的高度值，这样就能获得uv坐标偏移的算术平方和，进而获得uv偏移值。</p><p>![2.7-11](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 7.png)</p></li><li><p>然后用新的uv值去采样A点即可</p></li></ul><p>视差贴图只是一种近似的模拟方法</p><ul><li>由上图可以看出，实际A偏移后获得的uv坐标与B点还是有比较大的差距的</li><li>视差贴图的思想理念在于：深度高的地方更容易被遮挡，偏移的值更大；而对于深度小的点来说，更不容易被遮住，所以偏移的值更小；没有深度的点则不做偏移。</li><li>ps：深度图越浅的地方值越小（看上去越黑），越深的地方值越大（看上去越白）</li></ul><h2 id="3-3-Steep-Parallax-Mapping-陡峭视差映射">3.3 Steep Parallax Mapping 陡峭视差映射</h2><p>陡峭视差映射也是一个近似的解，但相比于普通的视差映射要精确很多，效果上也更好，并且会对uv坐标进行合理性检查。</p><p>陡峭视差映射的基本思想是将深度分为等距的若干层，然后从最顶层进行采样，并且每次沿着视角方向偏移一定值，若当前层的深度大于采样出的深度，则停止检查并返回最后的结果。</p><p>![2.7-12](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 8.png)</p><p>陡峭视差映射解释：</p><p>如上图所示，获得A点视线和法线的夹角，用于计算步进长度。一开始时，采样深度是0.25，视线深度是0.0，则向前步进；直到0.5-0.75区间时，发现当前视线深度对应的点D的采样深度为0.5，是第一个采样深度&lt;视线深度的点，那么就认为当前采样的点就是偏移后的点</p><p>陡峭视差映射缺点：</p><p>问题在于他的分层机制，如果分的层数过多，步进次数会变多，那么性能开销就会比较大；如果分的层数太少，那么就会有明显的锯齿</p><p>优化：可以根据视线v和法线n的角度来做对采样层数的最大值和最小值的阈值的限定</p><h1>4 Relief Mapping 浮雕映射</h1><h2 id="4-1-浮雕映射的概述">4.1 浮雕映射的概述</h2><p>浮雕映射是陡峭视差映射的一个改良版本</p><p>浮雕映射相比于视差映射，能够更精确地计算uv偏移量，更容易提供更多的深度，还可以做自阴影以及闭塞效果</p><p>![2.7-13 下面两张图使用了浮雕映射](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 9.png)</p><h2 id="4-2-浮雕映射的原理">4.2 浮雕映射的原理</h2><p>浮雕映射一般先使用射线步进，再使用二分查找的方法来决定UV偏移量</p><p>为什么不直接使用二分查找呢：</p><p>![2.7-14 虽然步进的步长太长也会带来同样的问题，但相较于直接使用二分查找，能一定程度上减少误差](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 10.png)</p><h2 id="4-3-陡峭视差映射另外的改良版本-——-视差闭塞贴图POM">4.3 陡峭视差映射另外的改良版本 —— 视差闭塞贴图POM</h2><p>——主要为了解决浮雕贴图映射最后二分查找的性能问题（可能需要迭代多次）</p><p>POM相对于浮雕映射贴图，他将二分查找替换成了插值计算，在得到目标区间后，他会对目标区间的两个端点进行采样，通过得到的两个高度值去算数alpha，最终插值得到uv偏移值</p><p>（因为用了插值，所以要求凹凸部分要相对平滑）</p><img src="C:\Users\Qui Han\AppData\Roaming\Typora\typora-user-images\image-20230614114858045.png" alt="2.7-15" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">Bump图改进</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（先行版-基础渲染光照介绍）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-4/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-4/</id>
    <published>2023-06-14T03:18:25.000Z</published>
    <updated>2023-07-01T01:58:15.982Z</updated>
    
    <content type="html"><![CDATA[<h1>[先行版]基础渲染光照介绍</h1><h1>Lambert</h1><p>漫反射：lambert数值为法线和光照的点乘</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz)</span><br><span class="line">float3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">dot</span>(finiNormal, worldLight))</span><br></pre></td></tr></table></figure><h1>Phong</h1><p>环境光+漫反射+高光</p><p>高光：光照颜色<em>高光反射颜色</em>视线方向与反射方向的点乘的gloss次幂</p><p>Gloss用于控制高光反射范围</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLight, finiNormal));<span class="comment">//计算反射方向</span></span><br><span class="line">float3 viewDir = normalzie(_WorldSpaceCameraPos.xyz - i.worldPOs.xyz);<span class="comment">//计算视角方向（该像素的位置）</span></span><br><span class="line"><span class="type">float</span> VdotR = <span class="built_in">max</span>(<span class="number">0.0</span>, dor(reflectDir, viewDir);</span><br><span class="line">float3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(VdotR, _Gloss);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">float3 color = diffuse + ambient + specular;</span><br></pre></td></tr></table></figure><h1>Blinn-Phong</h1><p>与Phong模型的区别在于计算specular时，使用的是半角向量而非反射向量</p><p>比起Phong模型，计算效率提升至少三分之一以上</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 halfDir = <span class="built_in">normalize</span>(worldLight + viewDir);</span><br><span class="line">float3 NdotH = saturate(<span class="built_in">dot</span>(halfDir, viewDir);</span><br><span class="line"><span class="type">float</span> specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(NdotH, _Gloss);</span><br></pre></td></tr></table></figure><h1>法线贴图</h1><p>UnpackNormal：空间转换（【0-1】空间→【-1-1】空间）</p><p>Unity内置的法线转换：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline fixed3 UnpackNormalDXT5nm(fixed4 packednormal)</span><br><span class="line">&#123;</span><br><span class="line">fixed3 normal;</span><br><span class="line">normal.xy = packednormal.xy * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">normal.z = <span class="built_in">sqrt</span>(<span class="number">1</span> - saturate(<span class="built_in">dot</span>(normal.xy, normal.xy)));</span><br><span class="line"><span class="keyword">return</span> normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fixd3 UnpackNormal(fixed4 packednormal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#ifdef UNITY_NO_DXT5nm</span></span><br><span class="line"><span class="keyword">return</span> packednormal.xyz * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#els</span></span><br><span class="line"><span class="keyword">return</span> UnpackNormalDXT5nm(packednormal);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在世界空间计算光照：计算切线空间→世界空间的变换矩阵，在frag中读取法线贴图然后将切线空间的法线信息转换到世界空间</p><p>法线的空间变换（法线空间→世界空间）：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">float3 worldNormalDir : TEXCOORD1;</span><br><span class="line">float4 worldTangentDir : TEXCOORD2;</span><br><span class="line">float3 worldbiTangentDir : TEXCOORD3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v2f vert(a2v v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//得出世界空间下的法线、切线，并计算出副切线</span></span><br><span class="line">o.worldNormalDir = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">o.worldTangentDir = <span class="built_in">normalize</span>(mul(unity_ObjectToWorld, float4( v.tangent.xyz, <span class="number">0.0</span>)).xyz);</span><br><span class="line">o.worldbiTangentDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(o.worldNormalDir, o.worldTangentDir) * v.tangent.w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//得到变换矩阵（世界空间下的切线、副切线、法线）</span></span><br><span class="line">float3x3 tangentTransform = float3x3(i.worldTangentDir, i.worldbiTangentDir, i.worldNormalDir);</span><br><span class="line"><span class="comment">//读取法线贴图并将其转换到世界空间下</span></span><br><span class="line">float3 normalLocal = UnpackNormal(tex2D(_NormalMap, TRANSFORM_TEX(i.uv0, _NormalMap)));</span><br><span class="line">float3 normalWorld = <span class="built_in">normalize</span>(mul(normalLocal.rgb, tangentTransform));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>CUBE Map</h1><p>做反射效果、环境光效果时会用到CUBE Map</p><p>用反射向量来读取CUBE Map</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取反射向量</span></span><br><span class="line">float3 worldRefl = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-viewDir, finiNormal));</span><br><span class="line"><span class="comment">//基于反射向量去读取反射效果的CUBE Map</span></span><br><span class="line">float4 refCol = texCUBElod(_Cubemap, float4(worldRefl.rgb, (<span class="number">255</span>-_Gloss)*<span class="number">8</span>/(<span class="number">255</span>)))*_EnvScale;</span><br><span class="line"><span class="comment">//参数解释：</span></span><br><span class="line"><span class="comment">//_Cubemap:存储反射信息的CubeMap</span></span><br><span class="line"><span class="comment">//_Gloss:光泽度</span></span><br><span class="line"><span class="comment">//_EnvScale:环境影响程度，即反射程度</span></span><br><span class="line"><span class="comment">//函数解释：</span></span><br><span class="line"><span class="comment">//texCUBElod如果传入float4，则最后一位是用来表示lod等级的（mipmap level）</span></span><br><span class="line"><span class="comment">//此处mipmap level是通过_Gloss光泽度来计算的，在Unity中如果勾选了贴图的generate1 mipmap，Unity会自动为这张帖图生成8个等级的mipmap</span></span><br><span class="line"><span class="comment">//用_Gloss计算mipmap level：如果一个物体_Gloss越高，说明物体表面越光滑，越能反射环境，mipmap level等级越低</span></span><br></pre></td></tr></table></figure><h1>IBL</h1><p>IBL：image based lighting，基于图像的光照，把一张图当成光源来加入物体的光照计算中</p><p>通常会用到texCUBElod来模拟PBR中粗糙度的表现（同上方CUBE Map中对_Gloss的解释，只不过换成了对光的反射率/显示出的亮度）</p><h1>处理漫反射暗面死黑的trick</h1><p>通过插值计算漫反射（暗部以环境光作为光源，亮部以真是光源作为光源）</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 diffuse = lerp(ambient.rgb*_Diffuse.rgb*MainTex.rgb, _LightColor.rgb*_Diffuse.rgb*MainTex.rgb, NdotL);</span><br></pre></td></tr></table></figure><h1>有金属质感，同时兼具非金属质感的trick</h1><h2 id="高光计算的trick">高光计算的trick</h2><p>模拟PBR效果：通过gloss的值对specular和diffuse进行插值，当Gloss很高（金属质感）时高光颜色与漫反射无关，当Gloss很低时（非金属质感）高光颜色会被漫反射影响</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 specular = _LightColor0.rgb * _SpecularColor.rgb * <span class="built_in">pow</span>(NdotH, _Gloss);</span><br><span class="line">specular = lerp(diffuse * specular, specular, _Gloss/<span class="number">255</span>);</span><br></pre></td></tr></table></figure><h2 id="环境映射的trick">环境映射的trick</h2><p>和高光计算同理</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">reflColor = lerp(diffuse * reflColor, reflColor, _Gloss/<span class="number">255</span>);</span><br></pre></td></tr></table></figure><h3 id="很不标准，不建议用，只是一种强行对PBR的仿制">很不标准，不建议用，只是一种强行对PBR的仿制</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[先行版]基础渲染光照介绍&lt;/h1&gt;
&lt;h1&gt;Lambert&lt;/h1&gt;
&lt;p&gt;漫反射：lambert数值为法线和光照的点乘&lt;/p&gt;
&lt;figure class=&quot;highlight glsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形2.6-2.7）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-3/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-3/</id>
    <published>2023-06-14T00:48:57.000Z</published>
    <updated>2023-07-01T01:58:03.405Z</updated>
    
    <content type="html"><![CDATA[<h1>Gamma矫正</h1><h2 id="颜色空间">颜色空间</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-78.png" alt="TA100-78" style="zoom:80%;" /><p>sRGB和Rec-709能表达的颜色空间范围是差不多的，他的三原色位置是差不多的。它们之间的区别就在于传递函数不同</p><h2 id="传递函数">传递函数</h2><p>把颜色显示到一个电子设备上时，需要把颜色转换成一个视频信号，这时候就需要一个传递函数</p><p>一个传递函数分为两部分：</p><ul><li>OETF：光转电传递函数，负责把场景线性光转到非线性视频信号值</li><li>EOTF：电转光传递函数，负责把非线性视频信号值转换成显示光亮度</li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-79.png" alt="TA100-79" style="zoom:80%;" /><h2 id="Gamma矫正">Gamma矫正</h2><p>Gamma矫正简单来说就是指<strong>对线性三色值和非线性视频信号之间进行编码和解码的过程</strong>，就比如说当相机拍摄到自然中的线性的光信号，传递到电脑中进行存储时，就需要进行一个Gamma的编码操作，获得非线性的视频信号；最后通过显示器显示时，又需要将非线性的视频信号还原回一个线性的光信号，这时就需要进行一个Gamma的解码操作，最后得到我们所见到的样子（线性的光信号）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-80.png" alt="TA100-80"></p><p>Gamma矫正的实例：简单理解为就是<strong>线性显示、非线性存储</strong>。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-82.png" alt="TA100-82" style="zoom:80%;" /><h2 id="进行Gamma矫正的原因">进行Gamma矫正的原因</h2><p>这其实和人眼的特性有关，<strong>人眼对暗部的变化要更加敏感一点</strong>。如果要存储更多的有效信息，就需要更多的位置去存储暗部值，即在存储暗部时用更高精度的值去存储，而对于亮部则可以用相对精度较低的值去存储。</p><p>所以，非线性转换的目的主要是为了<strong>优化存储空间和带宽</strong>，传递函数能够更好地帮我们利用编码空间。</p><h2 id="韦伯定律">韦伯定律</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-83.png" alt="TA100-83" style="zoom: 67%;" /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-84.png" alt="TA100-84" style="zoom: 80%;" /><p>韦伯定律:即感觉的差别闽限随原来刺激量的变化而变化，而且表现为一定的规律性，用公式来表示，就是ΔΦ/Φ=c，其中Φ为原刺激量，ΔΦ为此时的差别闽限，c为常数，又称为韦柏率。</p><p>简单来说就是，当这次通过一定的刺激爽到了，下次要获得同样的爽度就需要更多的刺激。</p><h2 id="什么是中灰值？（环境对亮度的影响）">什么是中灰值？（环境对亮度的影响）</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-85.png" alt="TA100-85 纯灰色的条看上去左右部分明暗不同"></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-86.png" alt="TA100-86" style="zoom:67%;" /><p>所以说<strong>中灰值并非一个明确的值，而是取决于实际的视觉感受</strong></p><h2 id="小结">小结</h2><ol><li>人眼对暗部变化比亮部更加敏感</li><li>我们目前所使用的真彩格式RGBA32，每个颜色通道只有8位用于记录信息，为了合理使用带宽和存储空间，需要进行非线性转换</li><li>目前我们所普遍使用的sRGB颜色空间标准，他的传递函数gamma值为2.2</li></ol><h1>线性工作流</h1><ul><li>线性工作流就是在生产的各个环节中，正确使用gamma编码和gamma解码，使得最终得到的颜色数据与最初输入的物理数据保持一致</li><li>如果使用Gamma空间的贴图，在传给着色器前需要从Gamma空间转到线性空间，以确保获得正确的计算结果</li></ul><p>如果不在线性空间下进行渲染工作：</p><p>Gamma空间中进行亮度计算时，会容易过曝：因为光线信息在经过Gamma编码后，他的值比实际上的要大</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-87.png" alt="TA100-87 Gamma空间中进行亮度计算容易过曝"></p><p>进行颜色混合时，也会让亮度过高，出现”黑边“</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-88.png" alt="TA100-88 颜色重叠区域出现“黑边”"></p><p>进行光照渲染时，如果把中灰色以0.5作为实际的物理光强进行计算的话，就会出现如下左图的情况；但是实际上中灰色的物理光强度应该是0.18</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-89.png" alt="TA100-89" style="zoom:80%;" /><h1>Unity中的颜色空间</h1><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-90.png" alt="TA100-90" style="zoom:80%;" /><ul><li>当选择Gamma Space时，Unity不会做任何处理</li><li>当选择Linear Space时，引擎的渲染流程在线性空间中计算。理想情况下项目使用线性空间的贴图颜色，不需要勾选sRGB选项；如果勾选了sRGB选项，unity则会通过硬件特性采样时进行线性转换。</li></ul><h2 id="硬件支持">硬件支持</h2><p>线性空间需要图形API的硬件支持，目前支持的平台有：</p><ol><li>Windows，Mac OS x和Linux</li><li>Xbox One</li><li>PS4（新的PS5肯定支持）</li><li>Android</li><li>IOS</li><li>WebGL（新的WebGPU肯定支持）</li></ol><h2 id="硬件特性支持">硬件特性支持</h2><p>主要由两个硬件特性来支持：</p><ul><li>sRGB Frame Buffer<ul><li>将shader的计算结果输出到显示器前进行Gamma矫正</li><li>作为纹理被读取时自动会把存储的颜色从sRGB空间转换到线性空间</li><li>调用ReadPixels()、ReadBackImage()时，会直接返回sRGB空间下的颜色</li><li>sRGB Frame Buffer只支持每通道为8bit的格式，不支持浮点格式</li><li>HDR开启后会先把渲染结果绘制到浮点格式的Frame Buffer中，最后绘制到sRGB Frame Buffer上输出</li></ul></li><li>sRGB Sampler<ul><li>将sRGB的贴图进行线性采样的转换</li></ul></li></ul><p>使用硬件特性完成sRGB贴图的线性采样和shader计算结果的gamma矫正，比起在shader里对贴图采样和计算结果的矫正要快</p><h1>资源导出问题</h1><h2 id="SP贴图导出">SP贴图导出</h2><p>SP贴图导出时，线性的颜色值经过了gamma变换，颜色被提亮了，所以在unity中需要勾选sRGB选项，让他在采样时能还原回线性值</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-91.png" alt="TA100-91"></p><h2 id="PS中相关设置">PS中相关设置</h2><p>如果使用线性空间，一般来说PS可以什么都不改，导出的贴图只要勾上sRGB即可</p><p>如果调整PS的gamma值为1，导出的贴图在unity中也不需要勾选sRGB了</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-92.png" alt="TA100-92"></p><ul><li>PS对颜色管理特别精准，Unity中看到的颜色要经过显示器的gamma变换，而PS不会，PS会读取显示器的Color Profile，反向补偿回去。所以PS里使用的是一个真实的颜色值</li><li>PS有第二个Color Profile（Document Color Profile）。通常它的默认值就是sRGB Color Profile，和显示器的Color Profile一致，颜色是被这个Color Profile压暗了，所以PS中看到的结果才和Unity的一样（通过一个灰度值来控制颜色的显示，并且这个灰度值和显示器的gamma值一致，让我们看着和unity一样）</li></ul><p>Unity在进行半透明混合时，会先将它们转换到一个线性空间下，然后再进行混合。但是PS中，图层和图层之间做混合的时候，每个上层的图层都会读取他们的Color Profile，经过一个Gamma变换，再做混合，得到的结果就会偏暗一些。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-93.png" alt="TA100-93" style="zoom:80%;" /><h1>Unity中的颜色空间转换函数</h1><p>Unity CG.cginc文件中封装的函数</p><p>其中，带有Exact后缀的的函数计算精确，但消耗高；不带有Exact后缀的函数是一种近似解法</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">float</span> GammaToLinearSpaceExact (<span class="type">float</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0.04045</span>F)</span><br><span class="line">        <span class="keyword">return</span> value / <span class="number">12.92</span>F;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">1.0</span>F)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>((value + <span class="number">0.055</span>F)/<span class="number">1.055</span>F, <span class="number">2.4</span>F);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(value, <span class="number">2.2</span>F);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline half3 GammaToLinearSpace (half3 sRGB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Approximate version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1</span></span><br><span class="line">    <span class="keyword">return</span> sRGB * (sRGB * (sRGB * <span class="number">0.305306011</span>h + <span class="number">0.682171111</span>h) + <span class="number">0.012522878</span>h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Precise version, useful for debugging.</span></span><br><span class="line">    <span class="comment">//return half3(GammaToLinearSpaceExact(sRGB.r), GammaToLinearSpaceExact(sRGB.g), GammaToLinearSpaceExact(sRGB.b));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="type">float</span> LinearToGammaSpaceExact (<span class="type">float</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0.0</span>F)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>F;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= <span class="number">0.0031308</span>F)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12.92</span>F * value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">1.0</span>F)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.055</span>F * <span class="built_in">pow</span>(value, <span class="number">0.4166667</span>F) - <span class="number">0.055</span>F;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(value, <span class="number">0.45454545</span>F);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline half3 LinearToGammaSpace (half3 linRGB)</span><br><span class="line">&#123;</span><br><span class="line">    linRGB = <span class="built_in">max</span>(linRGB, half3(<span class="number">0.</span>h, <span class="number">0.</span>h, <span class="number">0.</span>h));</span><br><span class="line">    <span class="comment">// An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">1.055</span>h * <span class="built_in">pow</span>(linRGB, <span class="number">0.416666667</span>h) - <span class="number">0.055</span>h, <span class="number">0.</span>h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exact version, useful for debugging.</span></span><br><span class="line">    <span class="comment">//return half3(LinearToGammaSpaceExact(linRGB.r), LinearToGammaSpaceExact(linRGB.g), LinearToGammaSpaceExact(linRGB.b));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>1 基本概念</h1><ul><li>HDR：High Dynamic Range</li><li>LDR：Low Dynamic Range</li><li>动态范围 = 最高亮度 / 最低亮度</li></ul><p>将场景中高动态范围的光线信息，转换到显示设备上可显示出来的低动态范围的视频信息，这一过程被称为Tone Mapping</p><p>Tips：电脑显示器的最高亮度是由之前经验积累下来的一个，让人眼舒适的，相对统一的亮度。</p><h2 id="1-1-LDR">1.1 LDR</h2><ul><li><p>通常LDR的精度范围是8位（2的8次方）</p></li><li><p>0-1的单通道</p></li><li><p>常用的存储格式为jpg、png、tga</p></li><li><p>拾色器、一般的图片，电脑屏幕都是LDR</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled.png" alt="TA100-94"></p></li></ul><h2 id="1-2-HDR">1.2 HDR</h2><ul><li>远高于8位的精度</li><li>单通道的最大值可超过1</li><li>常用HDR图片存储格式有hdr、tif、exr、raw</li><li>HDRI、真实世界的光都是HRD</li></ul><h2 id="1-3-相机记录信息的过程">1.3 相机记录信息的过程</h2><ul><li>首先，将曝光值进行计算，将曝光值重新映射回相机能够感应的范围内（受到光圈、快门时间，以及传感器灵敏度等的影响）</li><li>再把值进行输出（线性），存储进数码相机的格式内</li><li>之后会经过一个线性变换（白平衡、色彩矫正、色调验色以及伽马矫正等这一系列过程），最终会得到一张LUT图</li><li>不同相机厂商LUT图的格式是不同的</li></ul><h1>2 为什么需要HDR</h1><p>LDR是对现实颜色进行压缩并且呈现出来，具有一定局限性，在进行后期效果调整和后续加工会因为颜色精度不够而难以进行</p><p>HDR有着更好的色彩，更高的动态范围和更丰富的细节，并且能够有效地防止画面过曝，亮度值超过1的颜色也能很好的表现出来。使得像素光亮度变得正常，视觉传达更加真实。</p><p>![TA100-95](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 1.png)</p><p>只有HDR才有超过1的数值，才会有Bloom的效果——高质量的Bloom才能更好体现画面的渲染品质</p><p>![TA100-96](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 2.png)</p><h1>3 在Unity中设置HDR</h1><h2 id="3-1-Camera的HDR">3.1 Camera的HDR</h2><p>![TA100-97](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 3.png)</p><p>Unity Camera基本参数中有HDR，如果开启的话，Unity会将场景渲染到HDR图像缓冲区，下一步进行后处理，在Tone mapping过程中会把HDR转换成LDR，再将LDR图像（R8G8B8）发送给显示器</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled.jpeg" alt="TA100-98"></p><h2 id="3-2-Lightmap的HDR">3.2 Lightmap的HDR</h2><p>![TA100-99](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 4.png)</p><p>将Lightmap编码质量设置为High Quality，将会为Lightmap开启HDR光照贴图的支持</p><h2 id="3-3-拾色器的HDR">3.3 拾色器的HDR</h2><ul><li>使用Intensity滑动条可以调整颜色的强度</li><li>滑动条每增加1，提供的光亮增加一倍</li></ul><p>![TA100-100](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 5.png)</p><h2 id="3-4-优缺点">3.4 优缺点</h2><p>优点：</p><ul><li>画面中亮度超过1的部分不会被截为1，增加亮部的细节并减少曝光</li><li>减少画面较暗部分的色阶感（用更大的精度去存储暗部）</li><li>更好的支持Bloom效果</li></ul><p>缺点：</p><ul><li>渲染流程中多了Tone mapping这一步，渲染速度慢</li><li>占据更多显存</li><li>不支持硬件抗锯齿</li><li>低端手机不支持HDR</li></ul><h1>4 Bloom</h1><p>渲染出原图后，提取原图中较亮的部分，对提取出来的图片进行高斯模糊，然后再叠加到原图上</p><p>![TA100-101](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 6.png)</p><p>Unity中的Bloom流程：</p><p>![TA100-102](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 7.png)</p><h1>5 HDR与Tone Mapping</h1><h2 id="5-1-ToneMapping的概念">5.1 ToneMapping的概念</h2><ul><li><p>色调映射</p></li><li><p>将HDR转化为LDR</p></li><li><p>如果是线性映射的话效果极差</p><p>![TA100-103](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 8.png)</p></li><li><p>所以一般使用曲线，把亮度区域和阴影区域向中等亮度方向压缩→S曲线</p></li></ul><h2 id="5-2-ToneMapping映射曲线">5.2 ToneMapping映射曲线</h2><p>![TA100-104 左图HDR，右图LDR（有点过曝的感觉）](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 9.png)</p><p>HDR的Tone Mapping映射曲线会<strong>把暗部压得更低一些，亮部也往回缩一点，让整体效果看起来更加真实</strong></p><h3 id="ACES映射曲线">ACES映射曲线</h3><ul><li>Academy Color Encoding System学院颜色编码系统</li><li>最流行、最被广泛使用的Tonemapping映射曲线</li><li>效果：对比度提高，很好地保留暗处和亮处的细节</li></ul><p>![TA100-105](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 10.png)</p><h3 id="其他类型的映射曲线">其他类型的映射曲线</h3><p>![TA100-106](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 11.png)</p><h1>6 LUT</h1><p>Look-Up Table，简单来说就是滤镜</p><p>与Tonemapping不同的是，LUT是对LDR图进行处理，而Tonemapping则是处理HDR图</p><p>可以调整RGB三个通达的LUT被称为3D LUT，格式有下图所示的那几种</p><p>![TA100-107](<a href="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled">http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Untitled</a> 12.png)</p><p>Tips：可以在PS中调整LUT，导出的LUT作为滤镜去调整画面（相当于整个画面的滤镜）</p><p>LUT的效果比较：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-108.png" alt="TA100-108 出处： UE4 画质增强Lut使用方法_ue4 lut_Deveuper的博客-CSDN博客"></p>]]></content>
    
    
    <summary type="html">gamma矫正、LDR与HDR</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形2.1-2.4）</title>
    <link href="https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-2/"/>
    <id>https://himoqiuhan.github.io/2023/06/14/Notes-TA100T-2/</id>
    <published>2023-06-14T00:48:56.000Z</published>
    <updated>2023-07-01T06:58:54.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为前两章基础概念较多，所以放在一起整理了</p></blockquote><h1>颜色空间</h1><h2 id="色彩发送器">色彩发送器</h2><p>色彩认知：光源是出生点，光源发射出光线，光线通过直射反射折射等路径最终进入人眼。但人眼接收到光线后，人眼的细胞产生了一系列化学反应。由此把产生的信号传入大脑，最终大脑对颜色产生了认知感知。</p><h3 id="光的要素">光的要素</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-28.png" alt="TA100-28" style="zoom: 80%;" /><h3 id="光源">光源</h3><p>光源就是产生的物体</p><h3 id="波长">波长</h3><p>光理论上讲是无限大的，只是我们人眼可见光是有局限的。</p><p>如果没有光，我们就无法在黑暗中看到色彩，光的本质就是一种<strong>物理现象</strong>，光在没有进入我们的眼睛前，我们对它的认知是一种<strong>波长与能量分布</strong>。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-29.png" alt="TA100-29"  /><h3 id="能量分布">能量分布</h3><p>我们讲光线是一种波，那么既然是真实存在的就会有能量，能量单位就是功率，我们认知的光就会有不同的功率。比如一个光是由多个波长组合起来的波形</p><p>那么也就是说我们阐述色彩就用这个波长就可以了，但是这么做实在是太反人类了，我们无法保证能简单描述色彩。于是人们发明了一个叫做<strong>分光光度计</strong>的东西。</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-30.png" alt="TA100-30"></p><h3 id="分光光度计">分光光度计</h3><p>分光光度计就是用于描述光线的具体能量强度，记得小时候用棱镜分光吗。我们通过分光之后对区间波长进行了感应与测量，最后得知了光谱的分布最终得知光线额能量集中在了550nm附近（图中绿色地方）</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-31.png" alt="TA100-31"></p><h3 id="光的传播">光的传播</h3><ul><li><p>直射光：光源直射眼睛</p></li><li><p>折射光： 光源穿过物体进入眼睛</p></li><li><p>反射光：光源经过物体表面反射进入眼睛</p></li><li><p>光线追踪：光线弹来弹去，然后我们根据权重确定光线最后进入眼睛中的颜色</p></li></ul><p>下图就是光通过反射之后，在能量上发生的变化，可以明显看到，少了一部分的能量，这是因为一部分的能量被物体吸收了，也就是说每次光经过反射或投射都会或多或少对光的能量分布产生一些影响</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-32.png" alt="TA100-32"></p><h2 id="光源的接收者">光源的接收者</h2><h3 id="相对亮度感知">相对亮度感知</h3><p>在某些阴暗的环境下，点亮一盏灯，这时人眼就会觉得非常亮。如果同时点亮1000盏灯，反而觉得只是10倍的亮度，对亮度的认知相当于从0~1再从1~10.</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-33.png" alt="TA100-33"></p><h3 id="人眼HDR">人眼HDR</h3><p>人眼既可以分辨出高亮度的云彩的不同层次区别，还可以分辨出阴影中物不同物体的异同。</p><p>但是人眼的能力并<strong>不能保证这两个功能同时生效</strong>。</p><p>这样一说，反而就能发现人眼真是个变化莫测的存在，它可能会随着不同的环境，感知到不同的色彩，体验到不同的明暗效果，甚至可能会随着盯着某一个点时间流逝而变化颜色。</p><h3 id="人眼感光细胞分布">人眼感光细胞分布</h3><ul><li>杆状细胞：感知亮度</li><li>锥状细胞：感知色彩</li></ul><p>感光细胞（杆状细胞）对亮度特别的敏感，只要有5~14个光子打到杆状细胞就会产生神经信号，这也可以解释为什么闪光弹能让人致盲，一部分原因就是因为光实在太亮，直接干涉了人眼最敏感的感光细胞</p><h3 id="锥状细胞">锥状细胞</h3><p>这种细胞专门用于感知颜色，但是他们还被区分为了L细胞，M细胞，S细胞。</p><p>这三种细胞负责感知的波长不一，如下图所示，L感知红色区间，M感知绿色区间，S感知蓝色区间</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-34.png" alt="TA100-34" style="zoom:80%;" /><h3 id="人眼的本质">人眼的本质</h3><p>人眼的本质是光源的接收者。他的作用就是接收外部光线输入，输出神经电信号进入大脑。</p><h3 id="完整积分公式">完整积分公式</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-35.png" alt="TA100-35"></p><h2 id="色彩空间历史">色彩空间历史</h2><h3 id="19世纪的猜想">19世纪的猜想</h3><ol><li>人们有100多种感受颜色的细胞</li><li>人们有三种，分别是RGB三种感色细胞</li><li>人们有三种，分别是黑白，红绿，黄蓝感色细胞（是不是很眼熟）</li></ol><p>现在这么多年过去了，其中的2和3这两种猜想都成为了我们当下的色彩视觉模型，也称之色彩模型</p><h3 id="1905Munsell色彩系统">1905Munsell色彩系统</h3><p>美国艺术家 Albert Henry Munsell利用自己的艺术特长，最早提出了一个色彩系统，后来在1930年被优化改良。</p><p>Munsell通过很多色卡来描述色彩，下面旋转角度的是色相，Munsell垂直的是亮度，从圆心到外部是Munsell饱和度。 人们凭借自我主观意识认知与区分色彩就是HSL(色相、饱和亮度)，这套系统没有过多的物理科学在其中，更多的是一种艺术家的理解与归纳总结规范…</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-36.png" alt="TA100-36" style="zoom:80%;" /><h3 id="1931-CIE-1931-RGB-Color-Specification-System">1931 CIE 1931 RGB Color Specification System</h3><p>科学家们觉得上述的色彩系统还可以，但是不够科学，于是为了以一种科学的方式阐述色彩，于是一个叫CIE的机构在1931年建立了一套色彩系统， 希望完全客观完全物理的量化色彩。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-37.png" alt="TA100-37" style="zoom:80%;" /><p>CIE把所有可视波长的光线作为测试光挨个测试了一个遍，最终的到了三条曲线我们发现435.8~546.1 nm这段波长中的红色基色强度是负数。这虽然物理正确，但是一点也没有科学的美感，于是我们进行了归一化，保证色彩在-1~1之间。最终通过计算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>g</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">rgb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">b</span></span></span></span>的基色的强度在当前混色强度的所占比例这样计算后，$ r’g’b’$都是在-1~1之间</p><p>那么如果我们发现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r&#x27;+g&#x27;+b&#x27;=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8352em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，就可以通过其中两个已知数计算出另一个的强度</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-38.png" alt="TA100-38" style="zoom:80%;" /><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-39.png" alt="TA100-39"></p><h3 id="XYZ-Color-Specification-System">XYZ Color Specification System</h3><p>上文的CIE1931RGB色彩系统已经不错了，但是存在负数，这在计算上非常的麻烦，比如写个乘法，得先计算是正数还是负数。</p><p>于是人们就用数学的方式做了一个新的色彩空间。所以XYZ色彩空间就是一个<strong>中转站</strong>，主要目的就是<strong>简化计算</strong>。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-40.png" alt="TA100-40"  /><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-41.png" alt="TA100-41" style="zoom:80%;" /><ul><li>如何转换：</li></ul><p>因为是空间转换所以我们用**矩阵(进行空间变换)**的方式进行</p><p>注：这里的RGB是CIE 1931RGB 不是sRGB中的RGB数值。</p><p>这个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>矩阵也不太美，于是人们为了计算方便有把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">xyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>矩阵进行了<strong>归一化</strong></p><ul><li>最终效果：色域马蹄图</li></ul><p>也就是人眼可见范围表示， 但是我们发现图像上面好像没有亮度于是我们就在归一化的基础上，把XYZ中的Y单独拿出来与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>一起组成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>色彩空间 其中的Y表示亮度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>表示色度。</p><p>注：这里提一下 这里是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>色彩空间 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XYZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>色彩空间衍生出来的</strong></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-42.png" alt="TA100-42" style="zoom:80%;" /><ul><li><p>不足与补充</p><p>上述的XYZ色彩空间也不错，但是也有问题，就是<strong>色彩的分布不均匀</strong>，他们的分布色彩一些地方紧一些地方又很松，举个例子这个图的偏向绿色部分就非常平滑，然后左下角部分坐标变化小，但是色彩变化就很快。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-44.png" alt="TA100-44" style="zoom:80%;" /></li></ul><h2 id="色彩空间的定义">色彩空间的定义</h2><p>至少需要满足三项重要指标：</p><ol><li>色域（三个基色的坐标，由此形成三角形）</li><li>Gamma（如何对三角形内进行切分）</li><li>白点（色域三角形中心）</li></ol><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614092133606.png" alt="TA100-45"></p><h3 id="Gamma">Gamma</h3><p>Gamma并不是色彩空间，它只是如何对色彩进行<strong>采样的一种方式</strong></p><p>每次对比顶点切割，就会发现切割的方式不同会导致每次对应的色彩不一样，大家通常理解的gamma=1的情况就是指代<strong>均匀的切分</strong>（下左图），这样的好处就是方便计算。而非均匀切割的方式就是gamma≠1</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614092220077.png" alt="TA100-46"  /><p>比如我们有个常用的空间 sRGB，那么<strong>sRGB的构成</strong>：</p><p>1.色域： sRGB首先设定了RGB三个基色的坐标</p><p>2.白点： sRGB也规定了<strong>白点位置</strong></p><p>3.gamma： sRGB的gamma设定为≈2.2（上右图）也就是说从外而向内切，<strong>先切的很细，然后逐渐变粗</strong></p><p>大家知道线性的好处(也就是gamma=1的时候)，方便计算，计算机效率高，方便理解，但是计算机储存（不需要花费很多空间去存储亮的区域）与显示器硬件因为早期的性能问题，采用的基本大部分都是gamma≈2.2的情况，但是我们目前大部分的机器都已经不是远古版本了，所以PC上的大部分游戏都会推荐使用<strong>线性空间</strong></p><p>我们可以自定义色彩空间，换一个色域，换一个白点位置，换一个gamma值其实就是一个新的色彩空间了，所以也可以存在sRGB D65 linear这类空间，所以任何色彩空间都可以是linear线性的（改gamma值就可以去确定），但linear本身并不是一个色彩空间，它只是一个gamma值</p><h2 id="常用色彩模型与色彩空间">常用色彩模型与色彩空间</h2><p>色彩模型：使用一定规则描述（排列）颜色的方法</p><p>色彩空间：需要至少满足三个指标：色域、白点、gamma</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-47.png" alt="TA100-47"></p><h2 id="补充">补充</h2><h3 id="色彩空间下的各种色域">色彩空间下的各种色域</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-48.png" alt="TA100-48" style="zoom:80%;" /><h3 id="P3色域相较于sRGB的提升">P3色域相较于sRGB的提升</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-49.png" alt="sRGB视频的色彩被映射到了更低的部分，而P3完整显示了色彩" style="zoom:80%;" /><p>系统能正确映射sRGB色彩的原因在于系统有正确的色彩配置文件，选用不同的色彩配置文件会造成显示的色彩差异<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>美术师需要用校色仪来获取正确的色彩配置文件</p><h3 id="为什么需要Gamma矫正">为什么需要Gamma矫正</h3><p>常见Gamma值为2.2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span>测试得到的<strong>符合大部分人的灰阶感知的Gamma值</strong></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614092920518.png" alt="TA100-50" style="zoom:80%;" /><h3 id="HDR">HDR</h3><p>高动态范围</p><p>HDR显示器的峰值亮度通常在1000nit以上，同时保持非常高的对比度，远高于SDR显示器的亮度和对比度</p><p>HDR内容：观看HDR视频内容需要HDR显示器</p><h3 id="色彩空间转换">色彩空间转换</h3><p>一个广色域HDR的视频（Display P3）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614093015670.png" alt="TA100-51"  /><h3 id="作业">作业</h3><ol><li><p>色彩空间的定义：</p><p>满足色域、白点、Gamma三个指标的对色彩的组织方式</p></li><li><p>人眼可见光范围是什么：</p><p>波长在400纳米~700纳米之间的电磁波</p></li></ol><h1>模型与材质</h1><h2 id="渲染管线与模型基础">渲染管线与模型基础</h2><h3 id="图形渲染管线">图形渲染管线</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-52.png" alt="TA100-52"></p><h3 id="模型的实现原理">模型的实现原理</h3><p>点连成线→线围成面→组成多边形→一个模型空间下的模型形成</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614093439928.png" alt="TA100-53" style="zoom:80%;" /><h3 id="UV">UV</h3><p>UV平铺在一个二维坐标系中，模型的每个顶点在三维空间和二维空间中都能一一对应，在二维坐标系中的顶点对应的位置就是顶点的纹理坐标，因此每个顶点都能利用纹理坐标获取到贴图所存储的信息</p><p>在建模软件中进行UV展开，UV会放在一个横轴为U，纵轴为V，范围为（0~1）的二维坐标系中</p><h3 id="一个模型包含的信息（以obj文件为例）">一个模型包含的信息（以obj文件为例）</h3><ul><li>V：顶点坐标数据（模型空间中单个顶点的XYZ坐标）</li><li>VT：贴图坐标（水平方向是U，垂直方向是V，范围在0~1之间）</li><li>VN：顶点法线→会决定面的朝向</li><li>顶点色：单个顶点的RGBA通道颜色信息</li></ul><p><strong>obj格式与fbx格式的区别</strong></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-53.png" alt="TA100-53" style="zoom: 80%;" /><h3 id="材质">材质</h3><p>在现实世界里，每个物体会对光产生不同的反应：有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点而有些物体则会散射很多，产生一个有着更大半径的高光点</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-54.png" alt="TA100-54" style="zoom: 50%;" /><h3 id="漫反射">漫反射</h3><p>漫反射是最容易模拟的模型。</p><p>最简单的<strong>Lambertian</strong>很简单粗暴的认为光线<strong>均匀地反射出去</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi><mo>=</mo><mi>B</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>∗</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>∗</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo separator="true">,</mo><mi>N</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Diffuse = BaseColor * LightColor * dot(LightDir, NormalDir)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">u</span><span class="mord mathnormal">se</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ma</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-55.png" alt="TA100-55" style="zoom: 50%;" /><h3 id="镜面反射">镜面反射</h3><p>镜面反射就是将入射光线根据表面法线进行反射，并且<strong>只有在反射方向有能量，其他方向能量均为0</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi><mo>=</mo><mi>L</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>∗</mo><mi>p</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>f</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo separator="true">,</mo><mi>V</mi><mi>i</mi><mi>e</mi><mi>w</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Specular = LightColor * pow(dot(ReflectDir, ViewDir), x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Sp</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-56.png" alt="TA100-56" style="zoom:50%;" /><h3 id="折射">折射</h3><p>对于玻璃这种电介质，除了反射之外还有根据物体的折射率折射一部分光线进入物体之中反射和折射能量的多少是根据菲尼尔定律决定</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>e</mi><mi>f</mi><mi>l</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mo stretchy="false">(</mo><mi>V</mi><mi>i</mi><mi>e</mi><mi>w</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo separator="true">,</mo><mi>N</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo separator="true">,</mo><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReflDir = refract(ViewDir, NormalDir, ration)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">Vi</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ma</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>e</mi><mi>f</mi><mi>l</mi><mi>C</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>C</mi><mi>U</mi><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>s</mi><mi>k</mi><mi>y</mi><mi>b</mi><mi>o</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>e</mi><mi>f</mi><mi>l</mi><mi>D</mi><mi>i</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReflColor =  texCUBE(skybox, ReflDir)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.07153em;">lC</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05764em;">BE</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-57.png" alt="TA100-57" style="zoom:50%;" /><h3 id="粗糙镜面反射">粗糙镜面反射</h3><p>法线偏移较小。反射依然集中在一个区域。形成有磨砂质感的金属表面。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-58.png" alt="TA100-58" style="zoom:50%;" /><h3 id="粗糙镜面折射">粗糙镜面折射</h3><p>毛玻璃效果</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-59.png" alt="TA100-59" style="zoom:50%;" /><h3 id="多层材质">多层材质</h3><p>涂了油漆的地板</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-60.png" alt="TA100-60" style="zoom: 45%;" /><h3 id="SSS次表面散射">SSS次表面散射</h3><p>多发生在半透明的物体上，如玉石、牛奶、皮肤、蜡烛</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-61.png" alt="TA100-61 光进入皮肤后照亮了毛细血管，因此在明暗交界处更容易看到反射出的红光" style="zoom:45%;" /><h3 id="多层皮肤模型">多层皮肤模型</h3><p>我们把皮肤看成三层：油脂层（微量、很薄），表皮层，真皮层</p><ul><li>正是因为有油脂层，油脂层直接把光反射出去，所以皮肤上才会有高光产生</li><li>没有被反射的光通过折射进入子表面层，光进入这些层之后被部分吸收（获得颜色）和散射</li><li>再从皮肤中入射点附近的出射点射出</li><li>这个过程就产生了次表面散射的效果</li></ul><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-62.png" alt="TA100-62"></p><h3 id="改变材质表面">改变材质表面</h3><p>现实世界中不存在完美平滑的表面，因此需要对模型表面的法线进行扰动。</p><p>其中一个方法是使用法线贴图。</p><p>漫反射，高光，折射，都与法线有关，因此改变法线，就能改变其光照计算结果</p><h2 id="模型数据解析">模型数据解析</h2><h3 id="模型数据在渲染中的作用">模型数据在渲染中的作用</h3><ol><li><p>顶点动画：在顶点着色器中，修改模型的顶点位置，进而达到模型运动的效果</p><ul><li><p>顶点动画就是在顶点着色器中对纹理的顶点进行进行操作进而产生动画效果</p></li><li><p>顶点动画改变的是一个顶点的位置，需要一定数量的顶点才能得到比较好的效果</p></li><li><p>一个顶点传入一个顶点着色器，顶点着色器控制顶点时，每个顶点都会执行同样的算法</p></li></ul></li><li><p>纹理动画：在片段着色器中，修改模型的UV信息，使得采样贴图时，发生位移而产生运动效果</p></li><li><p>顶点色</p><ul><li>通过重心坐标插值计算三角形内部的颜色</li></ul></li></ol><h3 id="顶点法线与面法线">顶点法线与面法线</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230614095731628.png" alt="TA100-63" style="zoom: 80%;" /><p>差异的原理：</p><ul><li><p>（面法线）未使用平滑时，三角形三个顶点<strong>共用</strong>一个法线。 那么插值时，因为三个顶点的法线相同，所以插值的结果<strong>相同</strong>。</p></li><li><p>（顶点法线）使用平滑后，<strong>一个顶点一个法线</strong>。三角形三个顶点的法线也就<strong>不相同</strong>。插值结果，也就会不同。</p></li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-64.png" alt="TA100-64" style="zoom: 67%;" /><p>在NPR渲染中。通常在顶点着色器中，将顶点往法线方向偏移。然后再片段着色器中直接输出一个颜色，达到描边的效果。<strong>BackFacing描边</strong>时，线条之间断开就是因为没有使用顶点法线（没有进行平滑着色）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-65.png" alt="TA100-65" style="zoom:50%;" /><h1>HLSL常用函数</h1><p>官方文档：</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions</a></p><p>一个实用的函数可视化网站：</p><p><a href="https://graphtoy.com/">https://graphtoy.com/</a></p><h2 id="基本数学运算">基本数学运算</h2><ul><li><p>max(x,y)</p><ul><li>返回x和y两者中较大的那个数</li></ul></li><li><p>min(x,y)</p><ul><li>返回x和y两者中较小的那个数</li></ul></li><li><p>mul(x,y)</p><ul><li>两变量相乘，常用于矩阵运算<ul><li>如果x是向量，则被视为行向量；如果y是向量，则被视为列向量</li></ul></li></ul></li><li><p>abs(x)</p><ul><li>取绝对值</li></ul></li><li><p>round(x)</p><ul><li><p>返回与x最近的整数</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-66.png" alt="TA100-66"></p></li></ul></li><li><p>sqrt(x)</p><ul><li>返回x的平方根</li></ul></li><li><p>rsqrt(x)</p><ul><li>返回x的平方根的倒数</li></ul></li><li><p>degrees(x)</p><ul><li>将弧度转换成角度</li></ul></li><li><p>radians(x)</p><ul><li>将角度转换成弧度</li></ul></li><li><p>noise(x)</p><ul><li>根据传入的浮点型向量，返回基于一个Perlin-noise算法的范围在-1~1之间的噪波值</li></ul></li></ul><h2 id="幂指对函数">幂指对函数</h2><ul><li>pow(x,y)<ul><li>返回x的y次幂（x和y均可为常量或变量）</li></ul></li><li>exp(x)<ul><li>返回以e为底，x为指数的幂，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>exp2(value x)<ul><li>返回以2为底，x为指数的幂，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>ldexp(x,exp)<ul><li>返回x与2的exp次方的乘积，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>e</mi><mi>x</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x*2^{exp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li>log(x)<ul><li>返回指定值的以e为底的对数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>n</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">lnx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span></span></span></span>lo</li></ul></li><li>log10(x)<ul><li>求以10为底的对数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">log_{10}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span></li></ul></li><li>log2(x)<ul><li>求以2为底的对数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">log_{2}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span></li></ul></li><li>frexp(x,out exp)<ul><li>把浮点数x分解成尾数和指数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>t</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>e</mi><mi>x</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x=ret*2^{exp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span></li><li>函数返回值为尾数，exp为指数（原始浮点数的二进制指数）</li><li>如果x参数为0，则此函数的尾数和指数均返回0</li></ul></li></ul><h2 id="三角函数与双曲函数">三角函数与双曲函数</h2><ul><li>asin(x)<ul><li>返回输入值的反正弦值</li></ul></li><li>acos(x)<ul><li>返回输入值的反余弦值</li></ul></li><li>atan(x)<ul><li>返回输入值的反正切值</li></ul></li><li><strong><em>*</em>*******atan2(y,x)*********</strong>*<ul><li>返回y/x的反正切值</li></ul></li><li><strong>sin(x)、cos(x)、tan(x)、tan(y/x)</strong></li><li>sincos(x,out s,out c)<ul><li>返回x的正弦值和余弦值</li></ul></li><li>sinh(x)<ul><li>返回x的双曲正弦值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(e^x-e^{-x})/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></li></ul></li><li>cosh(x)<ul><li>返回x的双曲余弦值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(e^x+e^{-x})/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></li></ul></li><li>tanh(x)<ul><li>返回x的双曲正切值，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mi mathvariant="normal">/</mi><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e^x-e^{-x}/e^x+e^{-x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h2 id="数据范围类">数据范围类</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-67.png" alt="TA100-67" style="zoom: 80%;" /><h2 id="类型判断类">类型判断类</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-68.png" alt="TA100-68"  /><h2 id="向量与矩阵类">向量与矩阵类</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-69.png" alt="TA100-69"></p><h2 id="光线运算类">光线运算类</h2><ul><li>reflect(i ,n)<ul><li>以i为入射向量，n为法线方向的反射光</li></ul></li><li>refract(i, n, ri)<ul><li>以i为入射向量，n为法线方向，ri为折射率的折射光</li></ul></li><li>lit(<em>n_dot_l</em>, <em>n_dot_h</em>, <em>m</em>)<ul><li>返回光照系数向量**(ambient, diffuse, specular, 1)，其中：**<ul><li>ambient = 1</li><li>diffuse = n · l &lt; 0 ? 0 : n · l</li><li>specular = n · h &lt; 0 ? 0 : pow( n · l, m)</li></ul></li></ul></li><li>faceforward(<em>n</em>, <em>i</em>, <em>ng</em>)<ul><li>在特定条件下翻转表面法线，表面面向i所指方向，返回面向i所指方向的面的法线方向（得到面向视图的曲面法向量）</li><li>return -n*sign(dot(i, ng))</li></ul></li></ul><h2 id="纹理查找">纹理查找</h2><h3 id="1D纹理查找（几乎不用）">1D纹理查找（几乎不用）</h3><ul><li>GPU在PS阶段是在屏幕空间XY坐标系中对每一个像素去对应的纹理中查找对应的纹素来确定像素的颜色</li><li>tex1D(s, t) 普通一维纹理查找 返回纹理采样器s在标量t位置的color4</li><li>tex1D(s,t,ddx,ddy) 使用微分查询一维纹理 t和ddxy均为vectortex1Dlod(s, t) 使用LOD查找纹理s在t.w位置的color4</li><li>tex1Dbias(s, t) 将t.w决定的某个MIP层偏置后的一维纹理查找</li><li>tex1Dgrad(s,t,ddx,ddy) 使用微分并指定MIP层的一维纹理查找</li><li>tex1Dproj(s, t) 把纹理当做一张幻灯片投影到场景中，先使用投影纹理技术需要计算出投影纹理坐标t(坐标t.w除以透视值)，然后使用投影纹理坐标进行查询</li></ul><h3 id="2D纹理查找">2D纹理查找</h3><ul><li>tex2D(s, t) 普通二维纹理查找 返回纹理采样器s在vector t位置的颜色</li><li>tex2D(s,t,ddx,ddy) 使用微分查询二维纹理 t和ddxy均为vector（只有小于ddxy的值才会采样）</li><li>tex2Dlod(s, t) 使用LOD查找纹理s在t.w位置的color4tex2Dbias(s, t) 将t.w决定的某个MIP层偏置后的二维纹理查找</li><li>tex2Dgrad(s,t,ddx,ddy) 使用微分并指定MIP层的二维纹理查找</li><li>tex2Dproj(s, t) 把纹理当做一张幻灯片投影到场景中，先使用投影纹理技术需要计算出投影纹理坐标t(坐标t.w除以透视值)，然后使用投影纹理坐标进行查询</li></ul><h3 id="3D纹理查找">3D纹理查找</h3><ul><li>tex3D(s, t) 普通三维纹理查找 返回纹理采样器s在vector t位置的颜色</li><li>tex3D(s,t,ddx,ddy) 使用微分查询三维纹理 t和ddxy均为vector</li><li>tex3Dlod(s, t) 使用LOD查找纹理s在t.w位置的color4</li><li>tex3Dbias(s, t) 将t.w决定的某个MIP层偏置后的三维纹理查找tex3Dgrad(s,t,ddx,ddy) 使用微分并指定MIP层的三维纹理查找</li><li>tex3Dproj(s, t) 把纹理当做一张幻灯片投影到场景中，先使用投影纹理技术需要计算出投影纹理坐标t(坐标t.w除以透视值)，然后使用投影纹理坐标进行查询</li></ul><h3 id="立体纹理查找">立体纹理查找</h3><ul><li>texCUBE(s,t) 返回纹理采样器s在vector t位置的颜色</li><li>texCUBE(s,t,ddx,ddy)使用微分查询立方体维纹理 t和ddxy均为vector</li><li>texCUBEDload(s,t) 使用LOD查找纹理s在t.w位置的color4</li><li>texCUBEbias(s,t) 将t.w决定的某个MIP层偏置后的立方体纹理查找</li><li>texCUBEgrad(s,t,ddx,ddy) 使用微分并指定MIP层的立方体纹理查找</li><li>texCUBEproj(s,t) 使用投影方式的立方体纹理查找</li></ul><h1>传统经验光照模型</h1><h2 id="光照模型">光照模型</h2><h3 id="是什么">是什么</h3><p>illumination model，是一种模拟自然界光照的物理过程的一种计算机模型，即光线与空间中物体表面的交互模型，大致分为两类：</p><ol><li>基于物理的模型</li><li>经验模型</li></ol><h3 id="为什么">为什么</h3><p>现实世界光照复杂，使用简化的光照模型对现实世界的光照情况进行模拟</p><h3 id="光照模型发展历程">光照模型发展历程</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-70.png" alt="TA100-70" style="zoom:80%;" /><h2 id="局部光照模型">局部光照模型</h2><h3 id="定义">定义</h3><p>只考虑直接光照，不考虑物体间反射的间接光</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-71.png" alt="TA100-71" style="zoom:80%;" /><h3 id="漫反射-2">漫反射</h3><p>光线均匀被反射到各个方向</p><p>漫反射过程中，光线发生了吸收和散射，因此改变颜色和方向</p><p>使用Lambert余弦定理计算：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-72.png" alt="TA100-72" style="zoom: 67%;" /><ul><li><strong>漫反射只与光源和表面法线有关</strong></li></ul><h3 id="高光反射">高光反射</h3><p>描述了光线与物体表面发生的反射（光强不变，方向改变）</p><p>反射率根据菲涅尔效应决定</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-73.png" alt="TA100-73" style="zoom: 67%;" /><ul><li><p><strong>Gloss影响了高光反射的范围，但高光的亮度是不变的</strong></p></li><li><p><strong>高光反射与观察方向有关</strong></p></li></ul><h3 id="环境光">环境光</h3><p>引入环境光弥补间接光照</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-74.png" alt="TA100-74" style="zoom:67%;" /><h3 id="自发光">自发光</h3><p>物体自身发出的光</p><h2 id="经典光照模型">经典光照模型</h2><h3 id="Lambert光照模型">Lambert光照模型</h3><p>只计算漫反射，没有高光效果</p><h3 id="Phong模型">Phong模型</h3><p>Phong = Ambient + Diffuse + Specular</p><p>使用环境光来模拟间接光照</p><p>加上了高光反射（使用反射光线方向和视线方向进行计算）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-75.png" alt="TA100-75" style="zoom: 50%;" /><h3 id="Blinn-Phong模型">Blinn-Phong模型</h3><p>在计算高光反射时，用的是半角向量和法线向量</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-76.png" alt="TA100-76" style="zoom: 80%;" /><h3 id="Phong和Blinn-Phone模型的区别">Phong和Blinn-Phone模型的区别</h3><p>Blinn-Phong模型使用半角向量：</p><ol><li><p>计算更简洁（计算半角向量比计算反射向量更简洁）</p></li><li><p>半角向量与法线的角度永远不会大于90度（但是反射光线与视线方向的角度会大于90度，导致点乘计算的值钳制在0，出现明显的边缘效果）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-77.png" alt="TA100-77" style="zoom:80%;" /></li></ol><h3 id="Flat模型">Flat模型</h3><p>使用面法线，每个面都是同一个颜色</p>]]></content>
    
    
    <summary type="html">颜色空间、模型与材质、HLSL常用函数、传统经验光照模型</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>技术美术百人计划学习笔记（图形1.1-1.4）</title>
    <link href="https://himoqiuhan.github.io/2023/06/13/Notes-TA100T-1/"/>
    <id>https://himoqiuhan.github.io/2023/06/13/Notes-TA100T-1/</id>
    <published>2023-06-12T16:00:00.000Z</published>
    <updated>2023-07-01T07:22:54.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为前两章基础概念较多，所以放在一起整理了</p></blockquote><h1>渲染流水线</h1><p>如图：</p><p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/Render%20pipeline.png" alt="Render pipeline"></p><h1>数学基础</h1><h2 id="向量运算">向量运算</h2><h3 id="认识向量">认识向量</h3><h4 id="向量的定义">向量的定义</h4><ul><li>向量是有大小和方向的有向线段，没有位置只有大小和方向</li><li>向量的箭头是向量的结束，尾是向量的开始</li><li>向量描述的位移能够被认为是与轴平行的位移序列</li></ul><h4 id="向量与标量">向量与标量</h4><ul><li>向量：有大小、有方向</li><li>标量：有大小，没方向</li></ul><h4 id="向量与点">向量与点</h4><ul><li>向量与点数学形式上相同，但几何意义完全不同</li><li>点：有位置，没有实际的大小和方向</li><li>向量：无位置，有实际的大小和方向</li><li>联系：任何一个点可以看作是从原点出发的向量</li></ul><h4 id="零向量">零向量</h4><ul><li>零向量是唯一大小为零的向量</li><li>零向量是唯一一个没有方向的向量</li><li>零向量不是一个点</li><li>零向量表示的是没有位移，如同零标量表示没有数量一样</li></ul><h3 id="向量的计算">向量的计算</h3><h4 id="向量与标量-2">向量与标量</h4><ul><li>没有加法与减法</li><li>乘法：将每个分量都与标量相乘</li><li>除法：等同于乘以标量的倒数</li><li>乘除的几何意义：以标量的大小缩放向量的长度，负值则方向相反（将向量缩放至k个标量单位）</li></ul><h4 id="向量的模长">向量的模长</h4><p>表示向量的长度，为向量x和y的算术平方根</p><h4 id="标准化向量">标准化向量</h4><p>用于只需要知道方向，不关心大小的向量。例如：法线</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub><mo>=</mo><mfrac><mi>V</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">V_{norm} = \frac{V}{||V||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">or</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2963em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="向量与向量的加减法">向量与向量的加减法</h4><p>三角形法则、四边形法则</p><h4 id="计算两点间距离">计算两点间距离</h4><p>向量相减计算得到位移向量，位移向量的模长即为两点之间的距离</p><h4 id="向量的点积运算">向量的点积运算</h4><ul><li>向量点乘就是分量乘积的和，结果是一个标量并满足交换律</li></ul><h5 id="点积的几何意义">点积的几何意义</h5><p>点乘的结果描述了两个向量的相似程度，点乘值越大，夹角角度越小，两个向量越接近</p><h5 id="向量投影">向量投影</h5><p>向量a在向量b上的投影为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">a * sin{\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></p><h5 id="点积的应用：Lambert光照模型">点积的应用：Lambert光照模型</h5><p>最简单通用的模拟漫反射的光照模型</p><h4 id="向量的叉积">向量的叉积</h4><p>几何意义：判断一个点是否在三角形内</p><h3 id="作业">作业</h3><p>向量各方面的几何意义：</p><ol><li>向量(a,b)：表示从坐标系原点指向点(a,b)的向量</li><li>向量(a,b)乘标量：表示向量的放大缩小，标量为负则向量方向取反</li><li>向量点乘：①用于计算投影；②单位向量点乘用于表示两条向量之间夹角的大小；③向量点乘自己后取平方根获得向量模长</li><li>向量叉乘：①用于判断点是否在三角形内部；②根据两条不平行的向量，叉乘计算出与两条向量共同所在平面垂直的向量，例如Billboarding效果</li></ol><h2 id="矩阵运算">矩阵运算</h2><h3 id="矩阵变换的几何意义：得到点在新的坐标系下的位置">矩阵变换的几何意义：得到点在新的坐标系下的位置</h3><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-1.png" alt=""></p><h3 id="特殊的矩阵">特殊的矩阵</h3><ul><li>方阵</li><li>单位矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></li><li>零矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span></li></ul><h3 id="矩阵的计算">矩阵的计算</h3><h4 id="矩阵的加减法">矩阵的加减法</h4><p><strong>几何意义</strong>：对单位向量的变换，新得到的单位向量就是将两个矩阵相加分别得到的列向量</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-2.png" alt="TA100-2"></p><h4 id="矩阵的数乘">矩阵的数乘</h4><p><strong>几何意义</strong>：对空间的缩放</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-3.png" alt="TA100-3"></p><h4 id="矩阵相乘">矩阵相乘</h4><p><strong>几何意义</strong>：可以用点积来方便记忆</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-4.png" alt="TA100-4"></p><p><strong>几何意义</strong>：</p><ol><li><p>矩阵乘矩阵，计算得到矩阵</p><p>进行矩阵变换，更改单位向量（转换到新的坐标系）</p></li><li><p>矩阵乘列向量，计算得到向量或坐标</p></li></ol><p><strong>注意</strong>：矩阵相乘不满足交换律，按照变换顺序，矩阵<strong>从右往左</strong>进行计算。但是满足结合律，进行复合变换可以先将所有矩阵相乘，再去乘向量</p><h3 id="矩阵的仿射变换">矩阵的仿射变换</h3><p>在Unity、Houdini的矩阵存储不同于图形学案例，他们采用的是列优先存储，所以矩阵的平移变换可能在最后一行，而非最后一列，（需要转置）</p><p>详细的各个放射变化见Games101的笔记</p><h2 id="MVP矩阵">MVP矩阵</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-5.png" alt="TA100-5"></p><h3 id="Model矩阵">Model矩阵</h3><p><strong>模型空间→世界空间</strong></p><ul><li>模型空间：以自身为中心的空间坐标系</li><li>世界空间：以世界为中心的空间坐标系</li></ul><p>缩放→旋转→平移依次进行矩阵变换</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-6.png" alt="TA100-6"></p><h3 id="View矩阵">View矩阵</h3><p><strong>世界空间→视觉空间</strong></p><ul><li>视觉空间：以摄像机为原点的空间坐标系</li></ul><p>先求V矩阵的逆矩阵（视觉空间→世界空间），再对他进行逆变换得到V矩阵</p><h3 id="Perspective矩阵">Perspective矩阵</h3><ol><li>不是真正的投影，只是为投影做准备</li><li>目的：判断顶点是否在可见范围内</li><li>P矩阵：对x,y,z分量进行缩放，用w分量做范围值。如果x,y,z都在w范围内，那该点在裁剪空间内。</li></ol><h3 id="作业-2">作业</h3><p>模型空间世界空间视野空间的区别在于空间坐标系的原点不同，模型空间的空间坐标系原点是物体在创建时所确定的中心，世界空间的空间坐标系原点是世界中心，视野空间的空间坐标系原点是摄像机。</p><p>P矩阵推导见Games101笔记</p><h1>纹理基础</h1><h2 id="纹理是什么">纹理是什么</h2><p>一张图片 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span> 一种可供着色器读写的结构化存储形式</p><p>一张<strong>纹理对象</strong>除了保存一些<strong>图片信息</strong>外，还会储存一些<strong>纹理采样的设置</strong></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-7.png" alt="TA100-7" style="zoom: 50%;" /><h2 id="纹理管线">纹理管线</h2><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-8.png" alt="TA100-8" style="zoom:50%;" /><ul><li>投影函数：获取我们要渲染的位置，将它从模型空间投影到纹理空间中，转化为UV坐标（投影指的是纹理投影，不同于摄像机投影，常规情况下投影函数通常会在“展UV”的阶段中使用，将投影的结果存储在顶点数据中。所以通常我们是直接使用存储在模型顶点数据中的投影的结果）</li><li>通讯函数：将UV坐标进行一个灵活的扩展，实现平移缩放旋转或者是控制图像的应用方式等等，得到一个新的纹理坐标，用这个纹理坐标就可以去获取纹理的值了（纹理采样）</li><li>着色器中的纹理通常会以Sampler Variable（采样器变量）的形式存在，即我们经常看见的sampler，这是一种Uniform类型的变量，在处理不同片元时这个变量是不变的。</li><li>依赖纹理读取：当我们使用tex2D或类似方式去访问纹理时，只要fragment shader不是直接用vertex shader传过来的数据，而是需要计算的数据，那么他就会产生一个叫做依赖纹理读取的东西，哪怕这个处理只是简单的交换UV的两个坐标。<strong>只要不是顶点着色器传过来的纹理采样数据，在片元着色器需要计算纹理偏移，哪怕是只进行了一些计算，也会影响性能的表现。</strong></li></ul><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-9.png" alt="TA100-9" style="zoom: 60%;" /><ul><li><p>后续获取一个具体纹素的颜色值就要看<strong>纹理采样的设置</strong>来决定了（采样设置包含在一个纹理对象中）</p><ul><li><p>纹理采样设置之Wrap Mode</p><p>决定UV值在[0,1]之外的表现</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-10.png" alt="TA100-10" style="zoom: 50%;" /></li><li><p>纹理采样设置之Filter Mode</p><ul><li>纹理放大：</li></ul><p>描述不同形状大小角度缩放比的情况下我们应该如何应用纹理让他的采样更加合理（纹理过滤可在硬件中完成，也可在软件中完成，也可在软件和硬件中共同完成）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-11.png" alt="TA100-11" style="zoom: 50%;" /><p><strong>Nearest Neighbor</strong>：获取最邻近点（采样一次），获得像素化的表现，消耗很省</p><p><strong>Bilinear Interpolation</strong>：双线性插值（采样四次）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-13.png" alt="TA100-13" style="zoom:45%;" /><p><strong>Cubic Convolution</strong>：立方卷积插值（采样16次）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-14.png" alt="TA100-14" style="zoom:45%;" /><p><strong>光滑曲线插值</strong>：在2x2纹理组之间进行插值（采样四次）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-15.png" alt="TA100-15" style="zoom:45%;" /><p>与双线性插值很相似，区别在于在将UV坐标带入读取纹理前多加了一步对UV坐标的处理</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-16.png" style="zoom: 50%;" /><p><strong>效果对比</strong>：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-17.png" alt="TA100-17" style="zoom:45%;" /><ul><li>纹理缩小</li></ul><p>常见方法是最邻近与双线性插值：</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-18.png" alt="TA100-18" style="zoom:50%;" /><p><strong>Mipmap</strong>：预处理纹理并创建数据结构，有助于实时工作时快速计算一组纹素对一个像素的近似值，且内存比原本多了1/3</p><p>如何正确<strong>选择Mipmap level</strong>：使用四个像素单元格所形成的一个四边形的最长边来近似这个像素覆盖的范围（显卡执行pixel是将其都分成2x2的一组，然后分块并行执行的→用于计算ddx和ddy，四个一组的pixel块是共享偏导值的）</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-19.png" style="zoom: 45%;" /><p><strong>Bilinear Interpolation</strong>：三线性插值，在两个Mipmap之间再进行一次插值</p><p>但是Mipmap催在overblur的问题，只能用于各向同性贴图</p><p><strong>Ripmap</strong>：各向异性过滤Anisotropic Filtering的一种方法，但是还是存在overblur；还有<strong>EWA过滤</strong>，用椭圆的方式存储纹素，效果好但是开销大</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-20.png" style="zoom:45%;" /></li></ul></li></ul><h2 id="纹理优化">纹理优化</h2><h3 id="CPU渲染优化常见方式——纹理图集-数组">CPU渲染优化常见方式——纹理图集/数组</h3><p>减少Draw Call，避免渲染时频繁改变纹理带来的消耗</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-21.png" style="zoom:50%;" /><h3 id="GPU渲染常见方式——纹理压缩">GPU渲染常见方式——纹理压缩</h3><p>从<strong>带宽</strong>入手，显存带宽指GPU独显的专用内存的速度，如果游戏速度受限于显存带宽的话，往往是我们所使用的纹理实在太大，GPU它没有办法快速处理</p><ul><li><p>减少了资源在CPU中进行解压缩的过程</p></li><li><p>减小了包体大小，减少了数据量级，减轻了带宽计算的压力</p></li><li><p>内存的使用效率更高</p></li></ul><h3 id=""></h3><h2 id="纹理应用">纹理应用</h2><h3 id="立方体贴图CubeMap">立方体贴图CubeMap</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-22.png" style="zoom:50%;" /><h3 id="凹凸贴图Bump-Mapping">凹凸贴图Bump Mapping</h3><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-23.png" alt="TA100-23" style="zoom:50%;" /><h3 id="位移贴图Displacement-Mapping">位移贴图Displacement Mapping</h3><p>凹凸贴图是模拟，而位移贴图是真的把<strong>顶点做了位置的移动</strong></p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-24.png" alt="TA100-24" style="zoom: 80%;" /><h2 id="作业-3">作业</h2><p>Filter Mode有几种？</p><ol><li>Nearest Neighbor最邻近（采样一次）</li><li>Bilinea Interpola双线性插值（采样4次）</li><li>Cubic Convolution立方卷积插值（采样16次）</li><li>Lanczos Interpolation兰索斯插值（采样64次）</li><li>Qu´ılez光滑曲线插值（采样4次）</li></ol><p>纹理贴图的优化方式及原理？</p><ol><li>使用Texture atlas纹理图集或纹理数组，减少Draw Call次数，减少切换渲染状态的次数来进行CPU方向的优化</li><li>对纹理进行压缩，减轻显存带宽计算的压力</li></ol><h1>主流平台API介绍</h1><h2 id="API的定义">API的定义</h2><p>是一个图形库，用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API），针对GPU</p><h2 id="基础概念">基础概念</h2><p>应用端：我们自己的程序端，相对于OpenGL ES，我们属于应用端</p><p>图元：要渲染的几何物体，或者形状</p><p>纹理：通俗点可以理解为一张图片</p><p>纹素：纹理的基础单元，不同于像素（不是一个维度的东西）</p><p>顶点数组：顶点指的是组成图元的各个顶点的属性，这些属性可以一起存到一个内存数组中</p><p>顶点缓冲区：在显存中专门分配一块显存来存储这个顶点数组，这个显存就被称为顶点缓冲区</p><p>顶点着色器、片元着色器：跑在GPU上的程序片段</p><h2 id="主流图形API">主流图形API</h2><p>手机：ios和Android都支持OpenGL ES</p><p>电脑：Windows支持DX和OpenGL，Linux/Mac(Unix)支持OpenGL</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-25.png" alt=""></p><h2 id="OpenGL-ES">OpenGL ES</h2><p><strong>相同点：</strong></p><p>相比于 OpenGL ES 1.x 系列的固定功能管线，OpenGL ES 2.0 和 OpenGL ES 3.0 都是可编程图形管线。开发者可以自己编写图形管线中的 顶点着色器 和 片段着色器 两个阶段的代码。</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-26.png" style="zoom: 45%;" /><p><strong>不同点：</strong></p><ol><li><p>兼容性：向后兼容</p></li><li><p>新特性：3.0引入采用阴影贴图、体渲染、基于GPU的粒子动画、几何形状实例化、纹理压缩和伽马矫正等新技术</p></li><li><p>渲染管线：3.0移除了Alpha Test和逻辑操作LogicOp两部分</p></li><li><p>着色器脚本编写</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/TA100-27.png" style="zoom: 45%;" /></li></ol><h2 id="5-OpenGL-ES3-0新功能">5 OpenGL ES3.0新功能</h2><p>详细见<a href="https://docs.qq.com/slide/DUHl3U2pOZ3lKTmNK?u=a2c3b90d79354f16b6413e563a612ffc">百人计划1400图形api</a></p>]]></content>
    
    
    <summary type="html">渲染流水线、数学基础、纹理基础、主流平台API介绍</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="百人计划" scheme="https://himoqiuhan.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://himoqiuhan.github.io/2023/05/30/hello-world/"/>
    <id>https://himoqiuhan.github.io/2023/05/30/hello-world/</id>
    <published>2023-05-29T16:00:00.000Z</published>
    <updated>2023-06-09T07:50:50.952Z</updated>
    
    <content type="html"><![CDATA[<h1>Hello Butterfly</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment">#创建日期</span></span><br><span class="line"><span class="attr">tags:</span> <span class="comment">#标签</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">tag2</span></span><br><span class="line"><span class="attr">categories:</span> <span class="comment">#种类</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&#x27;#关键词&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#封面处的描述</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="comment">#文章顶部图片</span></span><br><span class="line"><span class="attr">cover:</span> <span class="comment">#封面图片</span></span><br><span class="line"><span class="attr">swiper_index:</span> <span class="number">1</span> <span class="comment">#置顶轮播图顺序，非负整数，数字越大越靠前 （目前暂时还没有开）</span></span><br><span class="line"><span class="attr">katex:</span> <span class="literal">true</span> <span class="comment">#此页是否使用katex渲染数学公式</span></span><br></pre></td></tr></table></figure><h1>主页双行显示</h1><p>博客的config文件（不是主题的）中的buterfly_article_double_row</p><h1>代码自动换行</h1><p>主题配置文件中的code_word_wrap</p><h1>副标题打字效果</h1><p>主题配置文件中的subtitle</p><h1>折叠框使用</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab active"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">Front Matter范式及一些备注</summary>
    
    
    
    
    <category term="Butterfly" scheme="https://himoqiuhan.github.io/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>【C++】软光栅渲染器</title>
    <link href="https://himoqiuhan.github.io/2023/04/29/Projects-CPPSoftRasterizerRenderer/"/>
    <id>https://himoqiuhan.github.io/2023/04/29/Projects-CPPSoftRasterizerRenderer/</id>
    <published>2023-04-29T00:54:04.000Z</published>
    <updated>2023-09-02T10:46:58.713Z</updated>
    
    <content type="html"><![CDATA[<h1>介绍</h1><p>学习完<a href="https://games-cn.org/intro-graphics/">Games101</a>一段时间后，发现自己对一些基础知识掌握得不够牢固，就从零手搓了一个软光栅渲染器。</p><p>目标是过一遍光栅化渲染管线，所以不考虑算法优化，以及例如图片解码读取这些细分内容。</p><p>用glfw实现窗口创建和像素点绘制，基础的数学库和TGA图片读取类改写自<a href="https://github.com/ssloy/tinyrenderer">TinyRenderer</a>教程提供的数学库，其余实现流程全是自己手搓的。</p><blockquote><p>项目地址：<a href="https://github.com/himoqiuhan/QiuHRenderer">https://github.com/himoqiuhan/QiuHRenderer</a></p></blockquote><p>部分效果图：</p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_TextureMapping.png" style="zoom:33%;" /><figcaption>贴图读取与映射</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_bat.png" style="zoom:50%;" /><figcaption>“伪后处理”描边效果</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_Normal.png" style="zoom: 33%;" /><figcaption>平滑法线</figcaption><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/SoftRenderer_Depth.png" style="zoom: 50%;" /><figcaption>深度图渲染</figcaption><h1>渲染器整体架构</h1><ul><li>传入模型、读取光照信息</li><li>-–for(每个面)<ul><li>定义v2f结构体数组vertexout[3]</li><li>–for(3个顶点)<ul><li>GetVertexData获取当前顶点appdate_base顶点信息(顶点位置、顶点UV、顶点法线)</li><li>VertexShader给v2f赋值(裁剪空间坐标、世界空间坐标、世界空间法线、顶点UV)</li></ul></li><li>透视除法-&gt;齐次裁剪空间：简单粗暴的放弃这个面片 continue!(因为写渲染器的目标在于捋清楚渲染流水线，所以不做深挖)</li><li>屏幕映射-&gt;屏幕空间：三角形设置(基于三角形GetAABB获取BoudingBox)</li><li>–for(BoundingBox)三角形遍历<ul><li>IsInTriangle叉乘判断片元是否在三角形内</li><li>-if(在三角形内部)<ul><li>GetBarycentric获取屏幕上的重心坐标</li><li>插值计算出该片元在candidate cube 中的z值-&gt;获取candidate cube 中的坐标</li><li>齐次裁剪空间的坐标转换到相机空间中</li><li>利用透视除法系数，反推出裁剪空间中的深度值fragDepth</li><li>判断fragDepth与zbuffer内的深度值<ul><li>if(fragDepth.abs &lt; zbuffer[])<ul><li>写入当前深度值</li><li>FragmentShader输出片元颜色color4</li><li>DrawPixel</li></ul></li><li>else<ul><li>不进行任何处理</li></ul></li></ul></li></ul></li><li>-else<ul><li>continue</li></ul></li></ul></li></ul></li></ul><h1>细节分析</h1><h2 id="类、结构体的设计">类、结构体的设计</h2><h3 id="Rasterizer类">Rasterizer类</h3><p>实际的每一帧的渲染是在Rasterizer类中实现的，其中包含渲染前对模型变换、摄像机的设置，以及对渲染流程的执行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rasterizer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Transform transform;</span><br><span class="line">Camera camera;</span><br><span class="line">Screen screen;</span><br><span class="line"></span><br><span class="line">Matrix Matrix_M;</span><br><span class="line">Matrix Matrix_V;</span><br><span class="line">Matrix Matrix_P;</span><br><span class="line">Matrix Matrix_MVP;</span><br><span class="line"></span><br><span class="line">Vec3f worldLightDir;</span><br><span class="line"></span><br><span class="line">TGAImage* diffuseTex;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; ZBuffer;</span><br><span class="line">std::vector&lt;color4&gt; FrameBuffer;</span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; LuminanceBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DEBUG</span></span><br><span class="line"><span class="type">int</span> fragCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rasterizer</span>(<span class="type">const</span> Screen&amp; screen);<span class="comment">//构造对象，指定摄像机</span></span><br><span class="line">~<span class="built_in">Rasterizer</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTransform</span><span class="params">(Vec3f transition, Vec3f rotation, Vec3f scale)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPerspective</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetOrthogonal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position, Vec3f _lookAt, Vec3f _lookUp, <span class="type">float</span> _FOV, <span class="type">float</span> _aspect, <span class="type">float</span> _near, <span class="type">float</span> _far)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position, Vec3f _lookAt, Vec3f _lookUp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCamera</span><span class="params">(Vec3f _position)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExeRenderPipeline</span><span class="params">(Model* model, TGAImage* diffuse, Vec3f light_dir)</span></span>;<span class="comment">//执行渲染管线，其中包含模型的读取、顶点着色器、图片的读取和片元着色器，并且最终渲染到RenderTarget上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Used In RenderPipeline</span></span><br><span class="line"><span class="function">appdata_base <span class="title">GetVertexData</span><span class="params">(Model* model, Vec3i faceIndex)</span></span>;</span><br><span class="line"><span class="function">v2f <span class="title">VertexShader</span><span class="params">(appdata_base v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canClip</span><span class="params">(Vec3f* homogeneousPos)</span></span>;</span><br><span class="line"><span class="function">Vec3f <span class="title">ScreenMapping</span><span class="params">(Vec3f screen_coord)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInTriangle</span><span class="params">(Vec2i frag, Vec3f* triangleVertex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetFragHomogeneousDepth</span><span class="params">(<span class="type">float</span>* triangleVertexDepths, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetFragW</span><span class="params">(<span class="type">float</span>* triangleVertexW, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="function">color4 <span class="title">FragmentShader</span><span class="params">(v2f* i, <span class="type">float</span> fragW, Vec3f barycoord)</span></span>;</span><br><span class="line"><span class="comment">//Used In Vertex Shader</span></span><br><span class="line"><span class="function">Vec3f <span class="title">ObjectToWorldNormal</span><span class="params">(Vec3f normal)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Vec3f <span class="title">GetFragNormalByVertNormal</span><span class="params">(Vec3f* triangleVertexNormals, Vec3f barycoord)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawFrag</span><span class="params">(Vec2f pos, color4 color)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基础信息结构体">基础信息结构体</h3><h4 id="屏幕-窗口信息">屏幕/窗口信息</h4><p>用于存储所创建窗口的长、宽信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> width = <span class="number">640</span>;</span><br><span class="line"><span class="type">int</span> height = <span class="number">480</span>;</span><br><span class="line"><span class="built_in">Screen</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Screen</span>(<span class="type">int</span> w, <span class="type">int</span> h) :<span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="变换信息">变换信息</h4><p>用于存放物体在世界空间下的变换（平移、旋转和缩放），其中由于后续在矩阵设置过程中进行了角度值到弧度值的转换，所以这里的旋转所用的是角度值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Transform</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f transition = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vec3f rotate = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vec3f scale = <span class="built_in">Vec3f</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTransform</span><span class="params">(Vec3f _transition, Vec3f _rotation, Vec3f _scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">transition = _transition;</span><br><span class="line">rotate = _rotation;</span><br><span class="line">scale = _scale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="相机信息">相机信息</h4><p>有关信息见如下注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f position = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//世界空间位置</span></span><br><span class="line">Vec3f g = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>); <span class="comment">//摄像机看向方向</span></span><br><span class="line">Vec3f t = <span class="built_in">Vec3f</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//摄像机向上方向</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> FOV = <span class="number">60</span>; <span class="comment">//Field of view</span></span><br><span class="line"><span class="type">float</span> aspect = <span class="number">16</span> / (<span class="type">float</span>)<span class="number">9</span>; <span class="comment">//宽高比</span></span><br><span class="line"><span class="type">float</span> near = <span class="number">0.1f</span>; <span class="comment">//近裁剪面距离</span></span><br><span class="line"><span class="type">float</span> far = <span class="number">100.f</span>;<span class="comment">//远裁剪面距离</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="颜色信息">颜色信息</h4><p>用于对颜色的RGBA值进行存储，加入一些简单的相加、相乘和增加对比度的功能</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">color4</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> g;</span><br><span class="line"><span class="type">float</span> b;</span><br><span class="line"><span class="type">float</span> a;</span><br><span class="line"><span class="built_in">color4</span>() : <span class="built_in">r</span>(<span class="number">1</span>), <span class="built_in">g</span>(<span class="number">1</span>), <span class="built_in">b</span>(<span class="number">1</span>), <span class="built_in">a</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line"><span class="built_in">color4</span>(<span class="type">float</span> R, <span class="type">float</span> G, <span class="type">float</span> B, <span class="type">float</span> A) : <span class="built_in">r</span>(R), <span class="built_in">g</span>(G), <span class="built_in">b</span>(B), <span class="built_in">a</span>(A) &#123;&#125;</span><br><span class="line">color4 <span class="keyword">operator</span>*(<span class="type">float</span> num) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r * num, g * num, b * num, a * num); &#125;</span><br><span class="line">color4 <span class="keyword">operator</span>*(color4 other) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r * other.r, g * other.g, b * other.b, a * other.a); &#125;</span><br><span class="line">color4 <span class="keyword">operator</span>+(color4 other) &#123; <span class="keyword">return</span> <span class="built_in">color4</span>(r + other.r, g + other.g, b + other.b, a + other.a); &#125;</span><br><span class="line"><span class="function">color4 <span class="title">AddContrast</span><span class="params">(<span class="type">float</span> power)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">color4</span>(std::<span class="built_in">pow</span>(r, power), std::<span class="built_in">pow</span>(g, power), std::<span class="built_in">pow</span>(b, power), <span class="number">1.f</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信息传递结构体">信息传递结构体</h3><h4 id="appdate-base">appdate_base</h4><p>用于将模型信息传输给顶点着色器</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">appdata_base</span></span><br><span class="line">&#123;</span><br><span class="line">Vec3f vertex;<span class="comment">//顶点数据</span></span><br><span class="line">Vec3f normal;<span class="comment">//顶点法线</span></span><br><span class="line">Vec2f texcoord;<span class="comment">//顶点UV坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="v2f">v2f</h4><p>用于将顶点着色器传出的数据发送给片元着色器</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">v2f</span></span><br><span class="line">&#123;</span><br><span class="line">Vec4f clipPos;<span class="comment">//裁剪空间坐标</span></span><br><span class="line">Vec3f worldPos;<span class="comment">//世界空间坐标</span></span><br><span class="line">Vec3f worldNromal;<span class="comment">//世界空间顶点法线</span></span><br><span class="line">Vec2f uv;<span class="comment">//顶点UV坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵变换">矩阵变换</h2><p>矩阵相关的内容在/scr/Support/Math中的Matrx.cpp中，只做了更常用的透视投影，没有做正交投影的矩阵变换</p><h3 id="Model-Matrix">Model Matrix</h3><p>将顶点数据从Model Space变换到World Space，处理顶点数据的平移、旋转和缩放</p><p>此处使用的变换顺序是旋转-缩放-平移，其中旋转传入的是角度值的数值，在内部进行了角度值到弧度制的转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetModelMatrix</span><span class="params">(<span class="type">const</span> Transform&amp; transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Vec3f <span class="title">rotateRadian</span><span class="params">(transform.rotate.x * <span class="number">3.14f</span> / <span class="number">180</span>, transform.rotate.y * <span class="number">3.14f</span> / <span class="number">180</span>, transform.rotate.z * <span class="number">3.14f</span> / <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetTransition</span>(transform.transition) * <span class="built_in">GetScale</span>(transform.scale) * <span class="built_in">GetRotation</span>(rotateRadian);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="View-Matrix">View Matrix</h3><p>将顶点数据从World Space变换到View Space中，处理摄像机的变换，获得顶点数据在View Space下的坐标信息，确定View Space时使用的是右手系</p><img src="https://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/e53ee5c1448108e2d5992e9c6e38126.jpg" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetViewMatrix</span><span class="params">(<span class="type">const</span> Camera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix t = mat&lt;<span class="number">4</span>, <span class="number">4</span>, <span class="type">float</span>&gt;::<span class="built_in">identity</span>();</span><br><span class="line">t[<span class="number">0</span>][<span class="number">3</span>] = -camera.position.x;</span><br><span class="line">t[<span class="number">1</span>][<span class="number">3</span>] = -camera.position.y;</span><br><span class="line">t[<span class="number">2</span>][<span class="number">3</span>] = -camera.position.z;</span><br><span class="line"></span><br><span class="line">Vec3f gxt = <span class="built_in">cross</span>(camera.g, camera.t);</span><br><span class="line"></span><br><span class="line">Matrix r;</span><br><span class="line">r[<span class="number">0</span>][<span class="number">0</span>] = gxt.x;       r[<span class="number">0</span>][<span class="number">1</span>] = gxt.y;       r[<span class="number">0</span>][<span class="number">2</span>] = gxt.z;</span><br><span class="line">r[<span class="number">1</span>][<span class="number">0</span>] = camera.t.x;  r[<span class="number">1</span>][<span class="number">1</span>] = camera.t.y;  r[<span class="number">1</span>][<span class="number">2</span>] = camera.t.z;</span><br><span class="line">r[<span class="number">2</span>][<span class="number">0</span>] = -camera.g.x; r[<span class="number">2</span>][<span class="number">1</span>] = -camera.g.y; r[<span class="number">2</span>][<span class="number">2</span>] = -camera.g.z;</span><br><span class="line">r[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r * t;<span class="comment">//先平移再旋转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Perspective-Matrix">Perspective Matrix</h3><p>将顶点数据从View Space变换到Clip Space裁剪空间中，待后续进行透视除法变换到齐次裁剪空间进行裁剪和屏幕映射</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> Camera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> cot = <span class="number">1.0f</span> / std::<span class="built_in">tan</span>((camera.FOV / <span class="number">2.0f</span>) * <span class="number">3.14f</span> / <span class="number">180</span>);</span><br><span class="line">Matrix ret;</span><br><span class="line">ret[<span class="number">0</span>][<span class="number">0</span>] = cot / camera.aspect;</span><br><span class="line">ret[<span class="number">1</span>][<span class="number">1</span>] = cot;</span><br><span class="line">ret[<span class="number">2</span>][<span class="number">2</span>] = -(camera.far + camera.near) / (camera.far - camera.near);</span><br><span class="line">ret[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-2</span> * camera.far * camera.near / (camera.far - camera.near);</span><br><span class="line">ret[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染流程">渲染流程</h2><p>Rasterizer类中的成员函数ExeRenderPipeline，流程和<a href="#%E6%B8%B2%E6%9F%93%E5%99%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">渲染器架构</a>部分的内容基本相同，只是项目源文件中放了很多用于deBug的宏定义，所以在此留一个纯净版</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rasterizer::ExeRenderPipeline</span><span class="params">(Model* model, TGAImage* diffuse, Vec3f light_dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">worldLightDir = light_dir * <span class="number">-1.f</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;diffuseTex = diffuse;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;|||||||||||||||||||ExeRenderPipeline 单帧开始|||||||||||||||||||&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;||||||||||||||||摄像机基本信息： &quot;</span> &lt;&lt; <span class="string">&quot;position: &quot;</span> &lt;&lt; camera.position &lt;&lt; <span class="string">&quot; LookAt: &quot;</span> &lt;&lt; camera.g &lt;&lt; <span class="string">&quot; LookUp: &quot;</span> &lt;&lt; camera.t &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;||||||||||||||||光照方向：&quot;</span> &lt;&lt; worldLightDir &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">v2f vertexout[<span class="number">3</span>];</span><br><span class="line">std::vector&lt;Vec3i&gt; face = model-&gt;<span class="built_in">face</span>(i);<span class="comment">//指定当前遍历到的面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历边上的每一个顶点，进行处理</span></span><br><span class="line">appdata_base VertexData = <span class="built_in">GetVertexData</span>(model, face[j]);</span><br><span class="line">vertexout[j] = <span class="built_in">VertexShader</span>(VertexData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="type">float</span> w[<span class="number">3</span>];<span class="comment">//存储透视除法系数</span></span><br><span class="line">Vec3f homogeneousClipPos[<span class="number">3</span>];<span class="comment">//齐次裁剪空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">w[j] = vertexout[j].clipPos.w;</span><br><span class="line">homogeneousClipPos[j] = (vertexout[j].clipPos / w[j]).<span class="built_in">xyz</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础齐次裁剪</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">canClip</span>(homogeneousClipPos)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕映射</span></span><br><span class="line">Vec3f screen_coords[<span class="number">3</span>] = &#123;</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">0</span>]),</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">1</span>]),</span><br><span class="line"><span class="built_in">ScreenMapping</span>(homogeneousClipPos[<span class="number">2</span>])</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形设置--&gt;基于三角形获取AABB</span></span><br><span class="line">std::tuple&lt;Vec2i,Vec2i&gt; bbox = <span class="built_in">GetBoudingBox</span>(screen_coords);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//------------------逐顶点的操作结束------------------//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//--------------至此，开始逐片元进行操作--------------//</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逐片元执行FragmentShader</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(bbox).y; y &lt;= std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(bbox).y; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(bbox).x; x &lt;= std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(bbox).x; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断是否在三角形内部，如果不在三角形内部，继续遍历下一个frag</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsInTriangle</span>(<span class="built_in">Vec2i</span>(x, y), screen_coords)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取片元中心的重心坐标</span></span><br><span class="line">Vec3f BarycentricCoordinate = <span class="built_in">GetBarycentricCoordinate</span>(screen_coords, <span class="built_in">Vec2f</span>(x+<span class="number">.5</span>, y+<span class="number">.5</span>));<span class="comment">//重心坐标分别对应vertexout[0],vertexout[1],vertexout[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值计算当前frag在candidate cube 中的z值</span></span><br><span class="line"><span class="type">float</span> vertexDepth[<span class="number">3</span>] = &#123; screen_coords[<span class="number">0</span>].z,screen_coords[<span class="number">1</span>].z,screen_coords[<span class="number">2</span>].z &#125;;</span><br><span class="line"><span class="type">float</span> homogeneousDepth = <span class="built_in">GetFragHomogeneousDepth</span>(vertexDepth, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形重心插值，获取当前frag的w值</span></span><br><span class="line"><span class="type">float</span> fragW = <span class="built_in">GetFragW</span>(w, BarycentricCoordinate);</span><br><span class="line"><span class="comment">//获取当前frag在线性空间下（此处用的是裁剪空间）深度值</span></span><br><span class="line"><span class="type">float</span> depth = homogeneousDepth * fragW;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度判断</span></span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">abs</span>(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//深度值更小，则更新ZBuffer，计算FragmentShader并渲染当前frag</span></span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = <span class="built_in">FragmentShader</span>(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line">fragCounter++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FragColor.r == <span class="number">-1</span> || FragColor.g == <span class="number">-1</span> || FragColor.b == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓存区</span></span><br><span class="line">std::<span class="built_in">fill</span>(ZBuffer.<span class="built_in">begin</span>(), ZBuffer.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line">std::<span class="built_in">fill</span>(FrameBuffer.<span class="built_in">begin</span>(), FrameBuffer.<span class="built_in">end</span>(), <span class="built_in">color4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">std::<span class="built_in">fill</span>(LuminanceBuffer.<span class="built_in">begin</span>(), LuminanceBuffer.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;执行Fragment Shader 数量：&quot;</span> &lt;&lt; fragCounter &lt;&lt; std::endl;</span><br><span class="line">fragCounter = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;|||||||||||||||||||ExeRenderPipeline 单帧结束|||||||||||||||||||&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>额外内容</h1><h2 id="Frame-Buffer">Frame Buffer</h2><p>最简易的版本将是直接将当前渲染到的像素直接绘制到屏幕上，后续加入了Frame Buffer，渲染器会先将颜色数据存储到Frame Buffer中，经过处理后再绘制到屏幕。</p><p>使用时直接在上方宏定义处定义#define DEFERREDRENDERING_ON即可</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (std::abs(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = FragmentShader(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line"></span><br><span class="line">fragCounter++;</span><br><span class="line"></span><br><span class="line">if (FragColor.r == -1 || FragColor.g == -1 || FragColor.b == -1) continue;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- DrawFrag(Vec2f(x + .5, y + .5), FragColor);</span></span><br><span class="line"><span class="addition">+FrameBuffer[y * screen.width + x] = FragColor;//写入FrameBuffer</span></span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line"><span class="addition">+for (int y = 0; y &lt; screen.height; y++)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+for (int x = 0; x &lt; screen.width; x++)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+DrawFrag(Vec2f(x + .5, y + .5), FrameBuffer[y * screen.width + x]);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure><h2 id="渲染深度图">渲染深度图</h2><p>简单的渲染ZBuffer中的信息，在这个渲染器中，我想做出Deferred Render的感觉，所以实现需要#define DEFERREDRENDERING_ON来实现</p><p>只是将绘制Frame Buffer替换成了绘制ZBuffer</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">for (int y = 0; y &lt; screen.height; y++)</span><br><span class="line">&#123;</span><br><span class="line">for (int x = 0; x &lt; screen.width; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="deletion">-DrawFrag(Vec2f(x + .5, y + .5), FrameBuffer[y * screen.width + x]);</span></span><br><span class="line"><span class="addition">+DrawFrag(Vec2f(x + .5, y + .5), color4(ZBuffer[y * screen.width + x] / 120, ZBuffer[y * screen.width + x] / 120, ZBuffer[y * screen.width + x] / 120, 1.f).AddContrast(.5));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="得到亮度图">得到亮度图</h2><p>亮度计算方法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>u</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mi>r</mi><mo>∗</mo><mn>0.2125</mn><mo>+</mo><mi>g</mi><mo>∗</mo><mn>0.7154</mn><mo>+</mo><mi>b</mi><mo>∗</mo><mn>0.0721</mn></mrow><annotation encoding="application/x-tex">Luminance = r * 0.2125 + g * 0.7154 + b * 0.0721</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lu</span><span class="mord mathnormal">minan</span><span class="mord mathnormal">ce</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.2125</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.7154</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0721</span></span></span></span></p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">if (std::abs(depth) &lt; ZBuffer[y * screen.width + x])</span><br><span class="line">&#123;</span><br><span class="line">ZBuffer[y * screen.width + x] = depth;</span><br><span class="line">color4 FragColor = FragmentShader(vertexout, fragW, BarycentricCoordinate);</span><br><span class="line">fragCounter++;</span><br><span class="line">if (FragColor.r == -1 || FragColor.g == -1 || FragColor.b == -1) continue;</span><br><span class="line">FrameBuffer[y * screen.width + x] = FragColor;</span><br><span class="line"><span class="addition">+LuminanceBuffer[y * screen.width + x] = FragColor.r * 0.2125 + FragColor.g * 0.7154 + FragColor.b * 0.0721;//写入亮度LuminanceBuffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于深度-亮度的简单描边效果">基于深度/亮度的简单描边效果</h2><p>绘制Frame Buffer时，遍历每个像素并判断是否应该进行描边绘制</p><p>此处我使用当前像素周围八个像素，对角及上下左右的颜色信息差距，通过相减除以像素差来模拟颜色信息差的二阶导数，来判断是否描边</p><h4 id="基于深度">基于深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">1</span> &amp;&amp; y &lt; screen.height - <span class="number">1</span> &amp;&amp; x &gt; <span class="number">1</span> &amp;&amp; x &lt; screen.width - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((std::<span class="built_in">abs</span>((ZBuffer[(y + <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - ZBuffer[(y - <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[(y - <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - ZBuffer[(y + <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[y * screen.width + x + <span class="number">1</span>] - ZBuffer[y * screen.width + x - <span class="number">1</span>])) / (<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.2</span>f)|| (std::<span class="built_in">abs</span>((ZBuffer[(y + <span class="number">1</span>) * screen.width + x] - ZBuffer[(y - <span class="number">1</span>) * screen.width + x])) / (<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.2</span>f))</span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), <span class="built_in">color4</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br></pre></td></tr></table></figure><h4 id="基于亮度">基于亮度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">1</span> &amp;&amp; y &lt; screen.height - <span class="number">1</span> &amp;&amp; x &gt; <span class="number">1</span> &amp;&amp; x &lt; screen.width - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((std::<span class="built_in">abs</span>((LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x + <span class="number">1</span> ] - LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x + <span class="number">1</span>] - LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2.8</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[y * screen.width + x + <span class="number">1</span>] - LuminanceBuffer[y * screen.width + x - <span class="number">1</span>]))/(<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.05</span>f)</span><br><span class="line">|| (std::<span class="built_in">abs</span>((LuminanceBuffer[(y + <span class="number">1</span>) * screen.width + x] - LuminanceBuffer[(y - <span class="number">1</span>) * screen.width + x]))/(<span class="type">float</span>)<span class="number">2</span> &gt; <span class="number">.05</span>f))</span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), <span class="built_in">color4</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DrawFrag</span>(<span class="built_in">Vec2f</span>(x + <span class="number">.5</span>, y + <span class="number">.5</span>), FrameBuffer[y * screen.width + x]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">除窗口创建和像素点的绘制外，不使用任何图形学API制作的软件光栅化渲染器</summary>
    
    
    
    <category term="作品集" scheme="https://himoqiuhan.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="图形学" scheme="https://himoqiuhan.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://himoqiuhan.github.io/tags/C/"/>
    
    <category term="造轮子" scheme="https://himoqiuhan.github.io/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>【Unity】《Unity Shader 入门精要》学习总结</title>
    <link href="https://himoqiuhan.github.io/2023/04/01/Projects-SummaryOfUnityShaderEssentials/"/>
    <id>https://himoqiuhan.github.io/2023/04/01/Projects-SummaryOfUnityShaderEssentials/</id>
    <published>2023-03-31T16:00:04.000Z</published>
    <updated>2023-09-02T10:53:13.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览">总览</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902102643500.png" alt="效果总览"></p><h2 id="基础光照模型">基础光照模型</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902093754351.png" alt="Basic Lighting"></p><ul><li>逐片元的光照计算</li><li>逐顶点的光照计算</li><li>Blinn-Phong着色模型</li><li>逐顶点的高光反射计算</li></ul><h2 id="纹理的使用">纹理的使用</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902094030537.png" alt="Basic Texture"></p><ul><li>基础的纹理使用</li><li>法线贴图在切线空间和世界空间下计算光照</li><li>Blinn-Phong光照模型结合贴图使用</li><li>Ramp图的使用</li></ul><h2 id="前向渲染">前向渲染</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902094235305.png" alt="Forward Rendering"></p><ul><li>Alpha Blend实现半透明效果</li><li>Alpha Test实现透明效果</li><li>built-in中前向渲染的多光源</li></ul><h2 id="环境贴图">环境贴图</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902095404409.png" alt="Cubemap"></p><ul><li>基于Cubemap的菲涅尔效果</li><li>基于Cubemap的环境反射</li><li>基于Cubemap的环境折射</li></ul><h2 id="基于RT的镜面反射">基于RT的镜面反射</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902095748936.png" alt="Mirror"></p><ul><li>基于摄像机动态更新RT实现镜子效果，更改C#代码使得镜子前后移动会更改镜面内容缩放（透视）</li></ul><h2 id="玻璃折射">玻璃折射</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902100142866.png" alt="Glass"></p><ul><li>使用GrabPass，通过法线扰乱贴图读取模拟玻璃折射效果；使用Cubemap模拟玻璃反射效果</li></ul><h2 id="顶点动画">顶点动画</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902101650408.png" alt="Vertex Animation"></p><ul><li>顶点动画（需重新ShadowCaster）</li></ul><h2 id="BillBoard">BillBoard</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902101841164.png" alt="BillBoard"></p><ul><li>永远面向摄像机<ul><li>通过重构向前的方向来重构顶点位置，使得模型看上去始终面向摄像机</li></ul></li></ul><h2 id="溶解效果">溶解效果</h2><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230902102220207.png" alt="Dissolve"></p><ul><li>通过噪声来对片元渲染进行Clip，实现溶解</li></ul>]]></content>
    
    
    <summary type="html">入门精要里的效果全部都动手实现了一遍，用这一篇总的记录一下学习这本书写出来的效果</summary>
    
    
    
    <category term="作品集" scheme="https://himoqiuhan.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
    <category term="Unity" scheme="https://himoqiuhan.github.io/tags/Unity/"/>
    
    <category term="Built-in管线" scheme="https://himoqiuhan.github.io/tags/Built-in%E7%AE%A1%E7%BA%BF/"/>
    
    <category term="CG" scheme="https://himoqiuhan.github.io/tags/CG/"/>
    
    <category term="技术美术" scheme="https://himoqiuhan.github.io/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《Unity Shader入门精要》笔记（四）</title>
    <link href="https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-4/"/>
    <id>https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-4/</id>
    <published>2023-03-31T16:00:03.000Z</published>
    <updated>2023-09-02T01:26:51.148Z</updated>
    
    <content type="html"><![CDATA[<h1>NPR</h1><p>因为我想将来重点研究NPR，所以NPR的部分统一放在之后的笔记整理</p><h1>使用噪声</h1><h2 id="消融效果">消融效果</h2><h3 id="原理">原理</h3><p>概括来说就是<strong>噪声纹理+透明度测试</strong>，使用噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用clip函数把它对应的像素裁剪掉，这些部分就对应“烧毁”的部分</p><h3 id="Shader实现">Shader实现</h3><ul><li><code>Cull Off</code>命令关闭了shader的面片剔除，也就是说模型的正面和背面都会被渲染。因为消融会导致模型内部裸露，如果只渲染正面会出现错误的效果</li><li>为了能正确投射消融效果的阴影，使用了自定义的阴影投射Pass，在这里面通常会使用Unity内提供的内置宏V2F_SHADOW_CASTER\TRANSFER_SHADOW_CASTER_NORMALOFFSET和SHADOW_CASTER_FRAGMENT来帮助我们计算投射阴影时需要的各种变量，我们可以只关注自定义计算的部分</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/Noise/Dissolve&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BumpMap(&quot;Bump Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _DissolveTex(&quot;Dissolve Texture&quot;, <span class="number">2</span>D) = &quot;black&quot;&#123;&#125;</span><br><span class="line">        _BurningLineWidth(&quot;Burning Line&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _BurnedAmount(&quot;Burned Amount&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.3</span></span><br><span class="line">        _BurningFirstColor(&quot;Burning First Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _BurningSecondColor(&quot;Burning Second Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            </span><br><span class="line">            Cull off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _DissolveTex;</span><br><span class="line">            float4 _DissolveTex_ST;</span><br><span class="line">            <span class="type">float</span> _BurningLineWidth;</span><br><span class="line">            <span class="type">float</span> _BurnedAmount;</span><br><span class="line">            fixed4 _BurningFirstColor;</span><br><span class="line">            fixed4 _BurningSecondColor;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 tangentLightDir : TEXCOORD0;</span><br><span class="line">                float2 uv_base : TEXCOORD1;</span><br><span class="line">                float2 uv_bump : TEXCOORD2;</span><br><span class="line">                float2 uv_noise : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;<span class="comment">//用来计算光照衰减</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_tan v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv_base = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                o.uv_bump = TRANSFORM_TEX(v.texcoord,_BumpMap);</span><br><span class="line">                o.uv_noise = TRANSFORM_TEX(v.texcoord,_DissolveTex);</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.tangentLightDir = mul(rotation,ObjSpaceLightDir(v.vertex));</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> burn = tex2D(_DissolveTex,i.uv_noise).r;</span><br><span class="line"></span><br><span class="line">                clip(burn.r - _BurnedAmount);<span class="comment">//剔除溶解掉的部分（值小则剔除）</span></span><br><span class="line"></span><br><span class="line">                float3 tangentLightDir = <span class="built_in">normalize</span>(i.tangentLightDir);</span><br><span class="line">                float3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv_bump));<span class="comment">//将法线信息从0 —— 1转换到 -1 —— 1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算正常的漫反射</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv_base);</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="built_in">dot</span>(tangentLightDir,tangentNormal));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算溶解效果（白色溶解：为了便于后续控制完全没溶解的情况）</span></span><br><span class="line">                fixed t = <span class="number">1</span> - <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,_BurningLineWidth,burn-_BurnedAmount);</span><br><span class="line">                t = <span class="built_in">pow</span>(t,<span class="number">2</span>);</span><br><span class="line">                fixed3 burningColor = lerp(_BurningFirstColor,_BurningSecondColor,t);</span><br><span class="line">                burningColor = <span class="built_in">pow</span>(burningColor,<span class="number">5</span>);<span class="comment">//指数计算加强溶解对比效果</span></span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burningColor,t*<span class="built_in">step</span>(<span class="number">0.0001</span>,_BurnedAmount));<span class="comment">//插值计算溶解部分和非溶解部分,step用于保证_BurnedAmount为0的时候没有溶解效果</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass    </span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot;=&quot;ShadowCaster&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> excluded shader from DX11; has structs without semantics (struct v2f members uv_BurnMap)</span></span><br><span class="line"><span class="meta">#pragma exclude_renderers d3d11</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _DissolveMap;</span><br><span class="line">            float4 _DissolveMap_ST;</span><br><span class="line">            <span class="type">float</span> _BurnedAmount;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">                float2 uv_BurnMap;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">                o.uv_BurnMap = TRANSFORM_TEX(v.texcoord, _DissolveMap);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 burn = tex2D(_DissolveMap, i.uv_BurnMap).rgb;</span><br><span class="line"></span><br><span class="line">                clip(burn.r - _BurnedAmount);</span><br><span class="line"></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水波效果">水波效果</h2><h3 id="原理-2">原理</h3><p>原理与使用反射和折射模拟透明玻璃效果的原理基本一致。此处使用Cubemao作为环境纹理模拟反射效果；使用GrabPass获取当前屏幕的渲染，并使用法线对像素进行偏移模拟折射效果</p><h3 id="Shader实现-2">Shader实现</h3><ul><li>其中将Queue设置成了Transparent，可以确保物体渲染时，其他所有不透明物体已经被渲染到屏幕上了</li><li>设置RenderType为Opaque是为了在使用着色器替换技术时，该物体可以在需要时被正确渲染（获取摄像机的深度和法线纹理时）</li><li>法线的扰动和计算是在世界空间下完成的（法线信息从世界空间转换到世界空间下进行计算），以便于对GrabPass读取到的贴图进行读取</li><li>使用了WaveXSpeed和WaveYSpeed两个属性，是为了模拟两层交叉的水面波动效果</li><li>计算偏移的屏幕坐标时，我们将偏移量和屏幕坐标的Z分量相乘，这是为了模拟深度越大，折射程度越大的效果</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/Noise/WaterWave&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">0</span>,<span class="number">0.15</span>,<span class="number">0.115</span>,<span class="number">1.0</span>)</span><br><span class="line">        _MainTex(&quot;Base(RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _WaveMap(&quot;Wave Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Cubemap(&quot;Environmental Cubemap&quot;, CUBE) = &quot;_Skybox&quot;&#123;&#125;</span><br><span class="line">        _WaveSpeedX(&quot;Wave Speed X&quot;, Range(<span class="number">-0.1</span>,<span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _WaveSpeedY(&quot;Wave Speed Y&quot;, Range(<span class="number">-0.1</span>,<span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _Distortion(&quot;Distortion&quot;, Range(<span class="number">0</span>,<span class="number">100</span>)) = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot;&#125;<span class="comment">//Queue设置为半透明为了确保这个物体是在场景内物体渲染完成之后才被渲染的，表现出“透过水”的效果；而RenderType设置为Opaque是为了在使用着色器替换时物体可以在需要时被正确渲染</span></span><br><span class="line">        </span><br><span class="line">    GrabPass&#123; &quot;_RefractionTex&quot; &#125; <span class="comment">//屏幕图像被存入RefractionTex中</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"><span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">fixed4 _Color;</span><br><span class="line"><span class="type">sampler2D</span> _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"><span class="type">sampler2D</span> _WaveMap;</span><br><span class="line">float4 _WaveMap_ST;</span><br><span class="line">samplerCUBE _Cubemap;</span><br><span class="line">fixed _WaveSpeedX;</span><br><span class="line">fixed _WaveSpeedY;</span><br><span class="line"><span class="type">float</span> _Distortion;</span><br><span class="line"><span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">float4 _RefractionTex_TexelSize;</span><br><span class="line"></span><br><span class="line">struct a2v &#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 tangent : TANGENT; </span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f &#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float4 scrPos : TEXCOORD0;</span><br><span class="line">float4 uv : TEXCOORD1;</span><br><span class="line">float4 TtoW0 : TEXCOORD2;  <span class="comment">//由于是咋世界空间下计算法线</span></span><br><span class="line">float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">float4 TtoW2 : TEXCOORD4; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">o.scrPos = ComputeGrabScreenPos(o.pos);<span class="comment">//来获取对应被抓取屏幕图像的采样坐标</span></span><br><span class="line"></span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line"></span><br><span class="line">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line"></span><br><span class="line">o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);</span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">float2 speed = _Time.y * float2(_WaveSpeedX, _WaveSpeedY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在切线空间下获取法线</span></span><br><span class="line">fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;<span class="comment">//</span></span><br><span class="line">fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;<span class="comment">//读取两次法线是为了能获取多层的水面波纹效果</span></span><br><span class="line">fixed3 bump = <span class="built_in">normalize</span>(bump1 + bump2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算切线空间的偏移</span></span><br><span class="line">float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">i.scrPos.xy += <span class="keyword">offset</span> * i.scrPos.z;<span class="comment">//把偏移量和屏幕坐标相乘是为了模拟深度越大折射越强的效果</span></span><br><span class="line">fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<span class="comment">//对scrPos进行透视除法后用于采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从切线空间转换到世界空间</span></span><br><span class="line">bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz,bump),<span class="built_in">dot</span>(i.TtoW1.xyz,bump),<span class="built_in">dot</span>(i.TtoW2.xyz,bump)));</span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">fixed3 reflDir = <span class="built_in">reflect</span>(-viewDir, bump);</span><br><span class="line">fixed3 reflCol = texCUBE(_Cubemap,reflDir).rgb * texColor.rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span>-saturate(<span class="built_in">dot</span>(viewDir,bump)),<span class="number">4</span>);</span><br><span class="line">fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span>-fresnel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用噪声纹理的灰度值生成法线信息">使用噪声纹理的灰度值生成法线信息</h2><p>在纹理面板中把纹理类型设置为Normal Map，并选中Create from grayscale即可</p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230613105817515.png"  /><h1>Unity中的渲染优化技术</h1><h2 id="移动平台的特点">移动平台的特点</h2><p>移动设备上的GPU架构专注于尽可能使用更小的带宽和功能</p><ul><li>为了减少overdraw的Tiled-based Deferred Rendering(TBDR)</li><li>Early-Z技术剔除那些不需要被渲染的片元</li></ul><h2 id="影响性能的因素">影响性能的因素</h2><p><strong>CPU主要保证帧率，GPU主要保证分辨率</strong></p><h3 id="性能瓶颈的原因">性能瓶颈的原因</h3><ul><li>CPU<ul><li>过多的draw call</li><li>复杂的脚本或者物理模拟</li></ul></li><li>GPU<ul><li>顶点处理<ul><li>过多的顶点</li><li>过多的逐顶点计算</li></ul></li><li>片元处理<ul><li>过多的片元（既可能是分辨率造成的，也可能是overdraw造成的）</li><li>过多的逐片元计算</li></ul></li></ul></li><li>带宽<ul><li>使用了尺寸很大且未被压缩的纹理</li><li>分辨率过高的帧缓存</li></ul></li></ul><h3 id="优化技术总览">优化技术总览</h3><ul><li>CPU优化<ul><li>使用批处理减少draw call数目</li></ul></li><li>GPU优化<ul><li>优化几何体</li><li>使用LOD技术</li><li>使用遮挡剔除（Occlusion Culling）技术</li></ul></li><li>减少需要处理的片元数目<ul><li>控制绘制顺序</li><li>警惕透明物体</li><li>减少实时光照</li></ul></li><li>减少计算复杂度<ul><li>使用shader的LOD技术</li><li>代码方面的优化</li></ul></li><li>节省内存带宽<ul><li>减少纹理大小</li><li>利用分辨率缩放</li></ul></li></ul><h2 id="减少draw-call数目">减少draw call数目</h2><p>处理思想：<strong>每次调用draw call时尽可能多地处理多个物体</strong></p><p>什么物体可以一起处理：使用同一个材质的物体——对于使用同一个材质的物体，他们之间的区别仅仅在于顶点数据的差别，我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理</p><ul><li><p>Unity支持两种批处理方式：动态批处理和静态批处理</p></li><li><p>不管是动态批处理还是静态批处理，它们的前提都是要使用<strong>同一个材质</strong>（是同一个，而不是使用了同一个shader的材质，相当于是UE中的同一个材质实例）</p></li></ul><h3 id="动态批处理">动态批处理</h3><p><strong>基本原理</strong>：每一帧把可以进行批处理的mesh进行合并，再把合并后的模型数据传递给GPU，然后使用同一个材质进行渲染。</p><p><strong>优势</strong>：实现方便，并且自由度高，经过批处理的物体仍然可以移动</p><p><strong>缺点</strong>：只有满足条件的模型和材质才可以被动态批处理</p><p>主要的<strong>限制条件</strong>：</p><ul><li>能够进行动态批处理的<strong>网格的顶点属性规模要小于900</strong>。比如说，如果shader中需要使用顶点位置、法线和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，他的顶点数目不能超过300（数据具有即时性，只需要记住顶点属性规模这个概念，并且其会限制动态批处理即可）</li><li>使用lightmap的物体需要小心处理。这些物体需要额外的渲染参数，例如，在光照纹理上的索引、偏移量和缩放信息等。因此为了能让这些物体可以被动态批处理，我们需要保证他们指向光照纹理中的同一个位置</li><li>多Pass的shader会中断批处理。前向渲染中，我们有时需要使用额外的Pass来为模型添加额外的光照效果，这样一来模型就不会被动态批处理了。</li></ul><h3 id="静态批处理">静态批处理</h3><p>静态批处理适用于任何大小的几何模型</p><p><strong>实现原理</strong>：只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运动时刻被移动。</p><p><strong>优势</strong>：但是由于它只进行一次合并操作，因此比动态批处理高效</p><p><strong>缺点</strong>：模型不可以在运动时刻被移动、需要占用更多的内存（存储合并的几何结构，其每一个物体会对应一个原本网格的复制体）</p><p><strong>操作</strong>：只需要勾选物体的<strong>Static</strong>即可</p><h3 id="共享材质">共享材质</h3><p>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中，即组成一张<strong>图集（atlas）</strong>。一旦使用了纹理，我们就可以使用同一个材质，再使用不同的采样坐标对纹理进行采样即可。</p><h2 id="减少需要处理的顶点数目">减少需要处理的顶点数目</h2><h3 id="优化几何体">优化几何体</h3><ul><li><p>建模时就要记住，尽可能<strong>减少模型中三角形面片的数目</strong>，一些对于模型没有影响的、或是肉眼难以察觉到区别的顶点都要尽可能去掉</p></li><li><p>unity中显示的顶点数目和三角形数目往往大于建模软件中所显示的数目，其原因是：</p><ul><li>建模软件更多地站在人的视角下理解顶点，而unity是在GPU的视角下理解顶点。GPU看来，有时需要把一个顶点拆分成多个顶点，原因主要有两个：一是为了<strong>分离纹理坐标（uv splits）</strong>，二是为了<strong>产生平滑的边界（smoothing splits）</strong>。两者的本质，其实都是因为对于GPU来说，顶点的每一个属性和顶点之间必须是一对一的关系。有些顶点的纹理坐标可能有多个（不同的面），这对GPU来说是不可理解的，因此它必须把这个顶点拆分成多个具有不同纹理坐标的顶点。平滑边也是类似，一个顶点可能会对应多个法线信息或切线信息，用于决定一个边是hard edge还是smooth edge</li></ul></li><li><p>优化：</p><ul><li>减少顶点数目</li><li>移除不必要的硬边以及纹理衔接，以此避免边界平滑和纹理分离</li></ul></li></ul><h3 id="模型的LOD">模型的LOD</h3><p>使用LOD Group组件为一个物体构建一个LOD</p><h2 id="减少需要处理的片元数目">减少需要处理的片元数目</h2><p>重点在于减少drawcall</p><h3 id="控制绘制顺序">控制绘制顺序</h3><p>由于深度测试的存在，如果我们能保证物体都是从<strong>前往后绘制</strong>的，那么就可以很大程度上减少overdraw</p><ul><li>unity中，<strong>Queue数目小于2500</strong>的(Background、Geometry和AlphaTest)的对象都会被认为是opaque的物体，这些物体总体上是从前往后绘制的。而其他的队列则是从后往前绘制。所以我们可以尽可能把物体的队列设置为不透明物体的渲染队列，而尽量避免使用半透明队列。</li><li>而且我们可以充分利用unity的渲染队列来控制绘制顺序：<ul><li>第一人称射击游戏中，对于游戏中的主要人物角色来说，他们使用的shader往往比较复杂，但是他们通常会<strong>挡住屏幕的很大一部分区域</strong>，因此可以<strong>先绘制</strong>他们（使用小的渲染队列）</li><li>对于敌人，他们通常会出现在各种掩体之后（<strong>任务渲染比场景复杂，且部分身体部位被遮挡</strong>，但是没有完全遮住，所以不会被剔除），因此可以在所有常规的不透明物体后面渲染他们</li><li>对于天空盒，它几乎覆盖了所有像素，而且它<strong>一定是在所有物体的后面</strong>，因此它的队列可以设置为“<strong>Geometry+1</strong>”，这样可以保证不会因为天空盒造成overdraw</li></ul></li></ul><h3 id="时刻警惕透明物体">时刻警惕透明物体</h3><ul><li><p>对于半透明物体来说，由于他没有开启深度写入，如果想要获取正确的效果，就必须从后往前渲染，这意味着半透明物体几乎一定会造成overdraw</p></li><li><p>移动平台上，AlphaTest也会影响性能。虽然他没有关闭深度写入，但是由于他的实现使用了discard或clip操作，这些操作会导致一些硬件的优化策略失效。</p><ul><li>例如，TBDR技术会在执行fragment shader之前就判断哪些瓦片被真正地渲染。但是由于透明度测试在片元着色器中使用了discard函数，改变了片元是否会被渲染的结果，只有在执行了所有的fragment shader之后，GPU才会知道哪些片元会被真正渲染到屏幕上。因此GPU就无法使用这个优化策略了。这种时候，使用透明度混合的性能往往比使用透明度测试更好。</li></ul></li></ul><h3 id="减少实时光照和阴影">减少实时光照和阴影</h3><ul><li>对于逐像素光源来说，被这些光源照亮的物体需要再被渲染一次，并且他们会中断批处理<ul><li>例如，一个场景里如果包含了3个逐像素的点光源，而且使用了逐像素的shader，那么很可能将drawcall的次数提升3倍（CPU的瓶颈），同时也会增加overdraw（GPU的瓶颈）</li></ul></li><li>实时阴影也是一个非常消耗性能的效果，不仅是CPU需要提交更多的draw call，GPU也要进行更多处理</li><li>优化<ul><li>使用烘焙lightmap作为替代，这样运行时只需要更具纹理采样即可</li><li>移动平台上，一个物体使用的逐像素光源数目应小于1（不包括平行光），如果要使用更多的平行光，可以选择用逐顶点光照来代替</li></ul></li></ul><h2 id="节省带宽">节省带宽</h2><h3 id="减少纹理大小">减少纹理大小</h3><ul><li><p>所有纹理的<strong>长宽比最好相同</strong>（正方形），而且<strong>长宽值最好是2的整数幂</strong>，因为有很多优化策略只有在这种时候才可以发挥最大效用。</p></li><li><p>尽可能<strong>使用mipmap</strong>（原理见百人计划2.9-深入理解GPU硬件架构及运行机制）</p></li><li><p>压缩纹理也可以节省带宽，只需要把压缩纹理格式设置为自动压缩即可</p></li></ul><h3 id="利用分辨率缩放">利用分辨率缩放</h3><p>性能和画面之间的trade off</p><h2 id="减少计算复杂度">减少计算复杂度</h2><h3 id="Shader中的LOD技术">Shader中的LOD技术</h3><p>与之前提到的模型的LOD技术类似，Shader的LOD技术可以控制使用的shader等级，其原理是，只有shader的LOD值小于某个设定的值，这个shader才会被使用，而使用了超过设定值的shader的物体不会被渲染</p><p>通常在SubShader中使用类似下面的语句指明该shader的LOD值：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot;&#125;</span><br><span class="line">    LOD <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码方面的优化">代码方面的优化</h3><ul><li>尽可能使用低精度的浮点值进行计算<ul><li>float/highp适用于存储诸如顶点坐标等变量，但他的计算速度使最慢的，我们应该尽量避免在fragment  shader中使用这种精度进行计算</li><li>half/mediump适用于一些标量、纹理坐标等变量，它的计算速度约是float的两倍</li><li>fixed/lowp适用于绝大多数颜色变量和归一化后的方向矢量，他的计算速度越是float的4倍<ul><li>但要尽量避免对这些低精度变量进行频繁的swizzle操作(如color.xwxw)</li><li>应当尽量避免在不同精度之间的转换，这有可能造成一定程度的性能下降</li></ul></li></ul></li><li>对于绝大多数GPU来说，使用插值寄存器把数据从vertex shader传给下一个阶段时，应该使用尽可能少的插值变量（把多个变量组合成一个）（PowerVR除外）</li><li>尽可能不要使用全屏幕的后处理效果</li><li>尽可能不要使用分支语句和循环语句</li><li>尽可能避免使用类似sin、tan、pow、log等较为复杂的数学运算，可以使用查找表进行替代</li><li>尽可能不要使用discard操作，这会影响硬件的某些优化（TBDR）</li></ul><h1>NEXT</h1><p>Book：</p><p>《Real-time Rendering》</p><p>《Physically based rendering：From theory to implementation》</p><p>《GPU Gem》1-3</p><p>《GPU Pro》1-7</p><p>Course：</p><p>Physically Based Shading in Theory and Practice</p><p>Advances in Real-Time Rendering</p>]]></content>
    
    
    <summary type="html">噪声的使用、Unity中的渲染优化技术</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
    <category term="Unity" scheme="https://himoqiuhan.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>《Unity Shader入门精要》笔记（三）</title>
    <link href="https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/"/>
    <id>https://himoqiuhan.github.io/2023/04/01/Notes-UnityShaderEssentials-3/</id>
    <published>2023-03-31T16:00:02.000Z</published>
    <updated>2023-09-02T01:26:47.922Z</updated>
    
    <content type="html"><![CDATA[<h1>基础动画</h1><h2 id="Unity内置的时间变量">Unity内置的时间变量</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">变量类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_Time</td><td style="text-align:center">float4</td><td style="text-align:center">t是场景加载开始持续的时间，变量类型表示为(t/20, t, 2t, 3t)</td></tr><tr><td style="text-align:center">_SinTime</td><td style="text-align:center">float4</td><td style="text-align:center">t是时间的正弦值，分别表示为(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:center">_CosTime</td><td style="text-align:center">float4</td><td style="text-align:center">t是时间的余弦值，分别表示为(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:center">unity_DeltaTime</td><td style="text-align:center">float4</td><td style="text-align:center">dt是时间增量，分别表示为(dt, 1/dt, smoothDt, 1/smoothDt)</td></tr></tbody></table><h2 id="纹理动画">纹理动画</h2><ul><li>关键帧图像存放一组动画序列帧的一张贴图</li><li>纹理动画的核心在于fragment shader中动态调整读取贴图的位置，计算不同时刻子图像的纹理坐标范围，实现关键帧动画</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/ImageSequence&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex(&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _HorizontalAmount(&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _VerticalAmount(&quot;Vertical Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _Speed(&quot;Play Speed&quot;, Range(<span class="number">1</span>,<span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">            Zwrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed);</span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time/_HorizontalAmount);<span class="comment">//通过商获取行索引</span></span><br><span class="line">                <span class="type">float</span> colum = time - row * _HorizontalAmount;<span class="comment">//通过余数获取列索引</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//half2 uv = float2(i.uv.x/_HorizontalAmount, i.uv.y/_VerticalAmount);//获取每个帧的读取的初始位置（知道是那个位置，类似于百分比的东西，然后再用行和列加到真正的位置</span></span><br><span class="line">                <span class="comment">//uv.x += colum/_HorizontalAmount;//相加获取正确的x位置</span></span><br><span class="line">                <span class="comment">//uv.y -= row/_VerticalAmount;//相加获取正确的y位置</span></span><br><span class="line">                </span><br><span class="line">                half2 uv = i.uv + half2(colum,-row);<span class="comment">//另一个理解方式：先获取正确的位置</span></span><br><span class="line">                uv.x /= _HorizontalAmount;<span class="comment">//再除到0-1区间内</span></span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以上row要以 - 的形式遍历，因为逐帧贴图是从上开始到下的</span></span><br><span class="line"></span><br><span class="line">                fixed4 color = tex2D(_MainTex, uv);</span><br><span class="line">                color.rgb *= _Color;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本质上就是将原本的0-1的贴图读取范围映射到对应当前帧的范围内</p></blockquote><h2 id="顶点动画">顶点动画</h2><ul><li><p>需要关闭批处理，因为顶点动画需要在模型空间下进行顶点位置偏移的计算，批处理会使得所有相关的模型合并，导致这些模型各自的模型空间丢失。</p></li><li><p>核心在于vertex中对模型顶点进行计算偏移</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">v2f vert(a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">    <span class="comment">//因为给到的water的模型在其坐标空间内x方向是上下方向，所以使用sin对模型空间内的x进行变换</span></span><br><span class="line">    <span class="comment">//实际上的模型为 A sin(at + b)，根据不同物体的不同对象空间来决定</span></span><br><span class="line">    <span class="comment">//在此案例下x为波动的方向（竖轴），z为横轴，*v.vertex.z是因为通过不同的z的位置来控制不同的波动，否则会没有起伏的海浪的效果，只会整体移动</span></span><br><span class="line">    <span class="comment">//所以b=z,而_InvWaveLength则是告诉z应该被分为几段</span></span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    o.uv += float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阴影投射Pass：vert中直接把偏移值加到顶点位置变量中，再使用TRANSFER_SHADOW_CASTER_NORMALOFFSET来让unity做剩下的事；frag中直接使用TRANSFER_SHADOW_CASTER_FRAGMENT来让unity自动完成阴影投射</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Pass to render object as a shadow caster</span></span><br><span class="line">   Tags</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">    &#125;<span class="comment">//将光照模式设置为阴影投射</span></span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#pragma vertex vert</span></span><br><span class="line">    <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#pragma multi_compile_shadowcaster//声明阴影投射的变体</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _Magnitude;</span><br><span class="line">    <span class="type">float</span> _Frequency;</span><br><span class="line">    <span class="type">float</span> _InvWaveLength;</span><br><span class="line"></span><br><span class="line">    struct v2f</span><br><span class="line">    &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     v2f vert(appdata_base v) <span class="comment">//阴影投射需要输入为v.normal和v.vertex的变量，所以可以直接使用appdata_base</span></span><br><span class="line">     &#123;</span><br><span class="line">         v2f o;</span><br><span class="line">         float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">         v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line">         TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">         <span class="keyword">return</span> o;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fixed4 frag(v2f i) : SV_Target</span><br><span class="line">      &#123;</span><br><span class="line">         SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/Water&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Magnitude(&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Frequency(&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _InvWaveLength(&quot;Distortion Inversal Wave Length&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Speed(&quot;Speed&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需要禁用批处理batching，因为本案例需要在模型空间下对顶点进行偏移，而批处理会合并所有相关的模型导致这些模型各自的模型空间丢失</span></span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Time.y * _Frequency  + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">                <span class="comment">//因为给到的water的模型在其坐标空间内x方向是上下方向，所以使用sin对模型空间内的x进行变换</span></span><br><span class="line">                <span class="comment">//实际上的模型为 A sin(at + b)，根据不同物体的不同对象空间来决定</span></span><br><span class="line">                <span class="comment">//在此案例下x为波动的方向（竖轴），z为横轴，*v.vertex.z是因为通过不同的z的位置来控制不同的波动，否则会没有起伏的海浪的效果，只会整体移动</span></span><br><span class="line">                <span class="comment">//所以b=z,而_InvWaveLength则是告诉z应该被分为几段</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv += float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 color = tex2D(_MainTex, i.uv) * _Color;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Pass to render object as a shadow caster</span></span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ShadowCaster&quot;</span><br><span class="line">            &#125;<span class="comment">//将光照模式设置为阴影投射</span></span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster//声明阴影投射的变体</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_base v) <span class="comment">//阴影投射需要输入为v.normal和v.vertex的变量，所以可以直接使用appdata_base</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                float4 <span class="keyword">offset</span> = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = _Magnitude * <span class="built_in">sin</span>(_Time.y * _Frequency * <span class="built_in">abs</span>(v.vertex.x) + _InvWaveLength * v.vertex.z);</span><br><span class="line">                v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Billboarding">Billboarding</h2><p>实现效果：让物体始终正面朝向摄像机</p><p>应用场所：面片草</p><p>计算原理：</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/UnityShaderEssentials11.png" alt="UnityShaderEssentials11"></p><ol><li>确定物体本地空间的轴朝向<ol><li>确定物体指向摄像机的方向为物体本地空间的法线（Z轴）朝向，得到确定的normal</li><li>通过利用物体本身向上的轴和法线，叉乘计算出物体本地坐标系向右方向的轴朝向，得到确定的right（其中需要判断UpDir会不会和Normal平行，如果平行会导致cross无效）</li><li>通过确定的normal和right叉乘计算出确定的up</li></ol></li><li>根据原始位置相对于锚点的偏移量以及三个正交基计算出新的顶点位置（x轴在right轴上投影，y轴在up轴上投影，z轴在normal轴上投影）</li></ol><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/MakeFrameMove/BillBoeard&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _VerticalBillboarding(&quot;Vertial Constraints&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;DisableBatching&quot;=&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;LightMode&quot;=&quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _VerticalBillboarding;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//选择以模型空间的原点为锚点</span></span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));<span class="comment">//注意不能用内置的UnityWorldToObjectDir，因为这个计算的只是方向，会做normalize，导致无法得到正确的position</span></span><br><span class="line">                <span class="comment">//获取假定的目标法线</span></span><br><span class="line">                float3 normalDir = viewer - center;</span><br><span class="line">                <span class="comment">//如果_VerticalBillboarding=0,则说明向上的方向被固定，法线的y分量为0</span></span><br><span class="line">                <span class="comment">//如果_VerticalBillboarding=1,则说明法线方向被固定，以视野看向物体中心的反方向为法线方向</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                normalDir = <span class="built_in">normalize</span>(normalDir); <span class="comment">//标准化为单位向量</span></span><br><span class="line">                <span class="comment">//获取大致的向上向量upDir，为了避免upDir和法线平行（导致cross无效），需要进行判断</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//如果法线指向正上方，则upDir就指向前方；否则upDir指向正上方</span></span><br><span class="line">                float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">                <span class="comment">//通过准确的rightDir和normalDir来叉乘获取准确的upDir，由此获得正交基向量</span></span><br><span class="line">                upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line">                <span class="comment">//通过原本坐标系中的偏移值来获取顶点的新坐标位置</span></span><br><span class="line">                float3 <span class="keyword">offset</span> = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * <span class="keyword">offset</span>.x + upDir * <span class="keyword">offset</span>.y + normalDir * <span class="keyword">offset</span>.z;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">                color.rgb *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><ul><li>顶点动画如果在模型空间下进行计算需要禁用批处理，但因此会带来一定的性能下降，增加Draw Call，因此我们应该尽量避免在模型空间下用一些绝对位置和方向进行计算</li><li>顶点动画需要我们自己提供shadowcaster</li></ul><h1>屏幕后处理</h1><h2 id="屏幕后处理基本脚本系统">屏幕后处理基本脚本系统</h2><h3 id="OnRenderImage函数——得到渲染后的屏幕图像">OnRenderImage函数——得到渲染后的屏幕图像</h3><ul><li>默认在所有的不透明和透明pass被执行完毕后调用</li><li>可以在OnRenderImage函数前添加ImageEffectOpaque属性来实现在不透明pass执行完毕、透明pass执行之前调用</li></ul><h3 id="Graphics-Blit——完成对渲染纹理的处理">Graphics.Blit——完成对渲染纹理的处理</h3><p>三种声明：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">public static <span class="type">void</span> Blit(Texture src, RenderTexture dest);</span><br><span class="line">public static <span class="type">void</span> Blit(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>);</span><br><span class="line">public static <span class="type">void</span> Blit(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li>src表示源纹理</li><li>dest表示渲染目标纹理，如果为null则结果会直接输出到屏幕上</li><li>mat表示用于渲染的材质</li><li>pass默认为-1，表示会依次调用所有的pass，否则会调用特定索引的pass</li></ul><h3 id="基类——检测兼容性">基类——检测兼容性</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个Base类用于处理子类所共有的check和construct material过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在调用start时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()<span class="comment">//在CheckResource中被调用来查看当前平台是否支持</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This Platform does not support image effects of render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()<span class="comment">//在不被当前平台支持时调用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;<span class="comment">//禁用这个组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)<span class="comment">//每个屏幕后处理效果通常需要指定一个shader来创建一个用于处理RT的材质，因此在基类提供这样的方法</span></span></span><br><span class="line"><span class="function">    <span class="comment">//其中参数shader制定了该特效需使用的shader，第二个参数则是用于后期处理的材质</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)<span class="comment">//检查shader的可用性，1.isSupported检查shader在当前GPU上是否被支持 2.material检查material是否为空 3.material.shader == shader检查当前材质的shader是否是传入的shader</span></span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础后处理效果">基础后处理效果</h2><h3 id="调整屏幕的HSL">调整屏幕的HSL</h3><p>后处理C#脚本：继承自PostEffectBase类的实际效果类模板</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明该效果需要的shader，并由此创建材质</span></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">public</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material<span class="comment">//注意看，这是一个属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span><span class="comment">//get函数调用基类的CheckShaderAndCreateMaterial函数来获得对应的材质</span></span><br><span class="line">        <span class="comment">//get是一个属性或索引器的一部分，返回属性的值或索引器的元素，作用是封装访问字段，提供更好的数据安全性和灵活性</span></span><br><span class="line">        &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader,briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供调整亮度。饱和度和对比度的参数，并用Range属性提供变化区间</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义OnRenderImage来进行真正的特效处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)<span class="comment">//屏幕后处理的基础在于得到渲染后的屏幕图像（抓取屏幕），Unity为我们提供了这样一个方便的接口——OnRenderImage函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>,saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>,contrast);</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src, dest, material);<span class="comment">//在OnRenderImage函数中通常利用Graphics.Blit函数来完成对Render Texture的处理，src纹理将会传递给shader中名为_MainTex的纹理属性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后处理shader：（重点在于fragment shader的处理）</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/BrightnessSaturationAndContrast&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Brightness(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Brightness&quot;, Range(<span class="number">0</span>,<span class="number">3</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Properties可以省略，对于屏幕特效来说，他们使用的材质都是临时创建的</span></span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v) <span class="comment">//使用unity内置的appdata_img结构体作为顶点着色器的输入，它只包含了图像处理时必须的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityWorldToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord; <span class="comment">//uv无需再进行变换</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv); <span class="comment">//首先得到对原屏幕图像的采样结果renderTex</span></span><br><span class="line"></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness; <span class="comment">//通过Brightness来调整亮度（只需要把原本颜色乘上亮度系数_Brightness即可）</span></span><br><span class="line"></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b; <span class="comment">//计算该像素对应的亮度值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance); <span class="comment">//由亮度值创建一个饱和度为0的颜色值</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation); <span class="comment">//进行插值，得到期望饱和度</span></span><br><span class="line"></span><br><span class="line">                fixed3 abgColor = fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(abgColor, finalColor, _Contrast);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于RGB值计算像素亮度信息：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>u</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mn>0.2125</mn><mo>∗</mo><mi>r</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>0.7154</mn><mo>∗</mo><mi>g</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>0.0721</mn><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Luminance = 0.2125 *r \ + \ 0.7154*g \ + \ 0.0721 * b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">Lu</span><span class="mord mathnormal">minan</span><span class="mord mathnormal">ce</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.2125</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.7154</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0721</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p><h3 id="高斯模糊">高斯模糊</h3><ul><li>原理：利用高斯核进行卷积运算</li></ul><p>C#代码：（注意其中对Render  Texture的内存处理）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> rtW = src.width / downSample;<span class="comment">//降低对原图的采样率，以减少开销；downSample越大性能越好，但是可能会导致图像的像素化</span></span><br><span class="line">            <span class="built_in">int</span> rtH = src.height / downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;<span class="comment">//设置纹理的滤波器模式为双线性滤波器</span></span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src, buffer0);<span class="comment">//把src的render texture写入buffer0中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++)<span class="comment">//通过for循环控制高斯模糊的迭代次数</span></span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);<span class="comment">//更改用于模糊的像素量</span></span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);<span class="comment">//为buffer1分配一个临时RT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//先处理第一个pass(pass0)--竖直方向的pass</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material,<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);<span class="comment">//</span></span><br><span class="line">                <span class="comment">/*如果是使用等号赋值，会造成内存泄露，所以在使用=前需要释放buffer0的内存；但是如果是用Graphics.Blit(buffer0,buffer1,...)的话:</span></span><br><span class="line"><span class="comment">                 ①当Graphics.Blit()接受两个参数时，它会将第一个参数（源纹理）复制到第二个参数（目标纹理），并且会自动释放目标纹理原来占用的内存空间。</span></span><br><span class="line"><span class="comment">                 ②当Graphics.Blit()接受三个参数时，它会将第一个参数（源纹理）经过第三个参数（材质）的处理后复制到第二个参数（目标纹理），并且也会自动释放目标纹理原来占用的内存空间*/</span></span><br><span class="line">                buffer0 = buffer1;<span class="comment">//再将buffer1的结果赋给buffer0,此时buffer1和buffer2指向同一个Render Texture</span></span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);<span class="comment">//所以需要为buffer1新指定一个Render Texture</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//处理第二个pass(pass1)--水平方向的pass</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1,material,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;<span class="comment">//buffer0和buffer1之后共同指向同一个内存，所以不需要release buffer1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Shader代码：</p><p>其中==使用了<strong>CGINCLUDE</strong>来组织代码==，并且在两个pass中分别计算竖直方向和水平方向的卷积</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/GuassianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//出错的地方：</span></span><br><span class="line">    <span class="comment">// 1.水平方向和竖直方向处理uv坐标时，float2的两个参数位置写错：写水平方向时直接复制了代码改了y-&gt;x，但是没有调换0.0和_MainTex_TexelSize.y * 1.0的位置</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="comment">//使用CGINCLUDE来组织代码，这些代码不需要包含在任何的Pass语义块中，在使用的时候我们只需要在Pass中直接指定需要使用的顶点着色器和片元着色器函数即可（类似于C++中的头文件）</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;<span class="comment">//因为要使用相邻像素的坐标</span></span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;<span class="comment">//使用5x5大小的高斯核对原图像进行高斯模糊处理，而一个5x5的高斯核可以拆分成两个大小为5的一维高斯核，因此我们只需要计算5个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//处理竖直方向</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理水平方向</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通用的fragment shader</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line"></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//应用卷积核</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fixed4(sum ,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;<span class="comment">//给pass命名，方便在其他地方调用该pass</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bloom效果">Bloom效果</h3><ul><li>实现原理<ul><li>根据一个阈值提取像素中较亮的区域，将他们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散，再将其和原图像进行混合</li><li>使用多个pass进行处理<ul><li>Pass0：提取高亮部分</li><li>Pass1，2：对亮度进行高斯模糊</li><li>Pass3：Bloom混合效果</li></ul></li></ul></li></ul><p>C#代码整体与高斯模糊相似，唯一区别在于进入高斯模糊处理前使用Pass1提取了亮度大于阈值的部分（后续Blit处理的pass依次往后推）</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> private void OnRenderImage(RenderTexture src, RenderTexture dest)</span><br><span class="line">    &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            </span><br><span class="line"><span class="deletion">-           Graphics.Blit(src, buffer0);</span></span><br><span class="line"><span class="addition">+           Graphics.Blit(src,buffer0,material,0);//第一个pass--&gt;处理提取亮度的过程</span></span><br><span class="line"></span><br><span class="line">            for (int i = 1;i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"><span class="addition">+           material.SetTexture(&quot;_Bloom&quot;,buffer0);</span></span><br><span class="line"><span class="deletion">-           Graphics.Blit(buffer0, dest); </span></span><br><span class="line"><span class="addition">+           raphics.Blit(src,dest,material,3); //将高斯模糊处理后的亮度图应用到原图上</span></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Shader代码：</p><p>==使用<strong>UsePass</strong>来复用之前高斯模糊的Pass==<strong>(Pass的名称要使用全大写)</strong></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/GuassianBlur&quot;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//出错的地方：</span></span><br><span class="line">    <span class="comment">// 1.水平方向和竖直方向处理uv坐标时，float2的两个参数位置写错：写水平方向时直接复制了代码改了y-&gt;x，但是没有调换0.0和_MainTex_TexelSize.y * 1.0的位置</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _BlurSize(&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        <span class="comment">//使用CGINCLUDE来组织代码，这些代码不需要包含在任何的Pass语义块中，在使用的时候我们只需要在Pass中直接指定需要使用的顶点着色器和片元着色器函数即可（类似于C++中的头文件）</span></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;<span class="comment">//因为要使用相邻像素的坐标</span></span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;<span class="comment">//使用5x5大小的高斯核对原图像进行高斯模糊处理，而一个5x5的高斯核可以拆分成两个大小为5的一维高斯核，因此我们只需要计算5个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//处理竖直方向</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理水平方向</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过把计算采样纹理坐标写在vertex shader中可以减少运算，因为vertex shader-&gt;fragment shader的计算是线性的，所以这样的计算并不会影响计算结果</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>,<span class="number">0.0</span>) * _BlurSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通用的fragment shader</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line"></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//应用卷积核</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fixed4(sum ,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;<span class="comment">//给pass命名，方便在其他地方调用该pass</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        pass</span><br><span class="line">        &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal</span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于颜色亮度的边缘检测">基于颜色亮度的边缘检测</h3><p>C#代码中只是简单地对shader中一些数值进行调整：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> edgeOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_OnlyEdge&quot;</span>,edgeOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>,edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src,dest,material);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shader描边关键在于用卷积核计算该像素周围的亮度差作为梯度（模拟二阶导），并基于梯度进行插值计算</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/EdgeDetection&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Main Texture&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _OnlyEdge(&quot;Only Edge&quot;, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _edgeColor(&quot;Edge Color&quot;, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _backgroundColor(&quot;Background Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            half4 _MainTex_TexelSize;</span><br><span class="line">            <span class="type">float</span> _OnlyEdge;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line"></span><br><span class="line">            struct v2f </span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            v2f vert(appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找到目标像素点及其四周的九个像素点</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2( <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed luminance(fixed4 color)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b;</span><br><span class="line">            &#125;</span><br><span class="line">            half Sobel(v2f i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                     <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;<span class="comment">//水平方向上的卷积核</span></span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;<span class="comment">//竖直方向上的卷积核</span></span><br><span class="line">                <span class="comment">//通过卷积核来计算梯度值</span></span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> it = <span class="number">0</span>;it &lt; <span class="number">9</span>;it++)</span><br><span class="line">                &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex,i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                half edge = <span class="built_in">abs</span>(edgeX) + <span class="built_in">abs</span>(edgeY);<span class="comment">//本来梯度应该是X和Y的平方根，但出于性能考虑，会用绝对值操作来代替开根</span></span><br><span class="line">                <span class="comment">//half edge = 1 - abs(edgeX) - abs(edgeY);//我不知道为什么要用一个OneMinus进行一次反向映射</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">                fixed4 withEdgeColor = lerp( tex2D(_MainTex, i.uv[<span class="number">4</span>]), _EdgeColor,edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp( _BackgroundColor, _EdgeColor, edge);</span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor,onlyEdgeColor,_OnlyEdge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>使用深度与法线纹理</h1><h2 id="获取深度与法线纹理">获取深度与法线纹理</h2><h3 id="Unity中的深度和法线纹理">Unity中的深度和法线纹理</h3><p>深度纹理里的深度范围是[0,1]，且因为这些深度来源于NDC，所以通常是非线性分布的</p><p>Unity对深度纹理的获取方法：</p><ul><li>延迟渲染：直接访问GBuffer</li><li>无法直接获取深度缓存时：深度和法线纹理通过一个单独的Pass渲染获得。Unity会使用Shader Replacement着色器替换技术选择那些渲染类型（RenderType）为Opaque的物体，判断他们使用的渲染队列是否小于等于2500（内置的Background、Geometry、AlphaTest均在内），如果满足条件，就把他们渲染到深度和法线纹理中。因此，<strong>想要让物体能出现在深度和法线纹理中，就必须在Shader中设置正确的RenderType（&lt;=2500)</strong></li><li>可以选择让摄像机生成一张深度纹理或深度+法线纹理<ul><li>生成一张深度纹理：Unity会直接获取深度缓存，或是使用着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的Pass（“LightMode” = “ShadowCaster”）来得到深度纹理。如果shader中不包含这样一个Pass，那这个物体就不会出现在深度纹理中（也不会投射阴影）</li><li>生成深度+法线纹理：Unity会创建一张和屏幕分辨率相同、精度为32（8*4）位的纹理，其中观察空间下的法线信息会被编码进纹理的R、G通道中，深度信息会被编码进B、A通道中（在获取法线纹理时，如果是延迟渲染，直接读取GBuffer即可；如果是前向渲染，unity会使用一个单独的Pass把场景再渲染一遍）</li></ul></li></ul><h3 id="如何获取">如何获取</h3><p>设置摄像机的depthTextureMode</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;<span class="comment">//获取深度+法线纹理</span></span><br><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;<span class="comment">//获取深度纹理</span></span><br></pre></td></tr></table></figure><blockquote><p>摄像机的depthTextureMode默认为DepthTextureMode.Depth</p></blockquote><p>shader中采样深度纹理</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sampler = tex2D(_CameraDepthNormalsTexture, i.uv);<span class="comment">//绝大多数情况直接使用tex2D函数即可</span></span><br><span class="line"><span class="type">float</span> d = SMAPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<span class="comment">//Unity提供的用于处理平台造成的差异的统一的宏</span></span><br></pre></td></tr></table></figure><p>当通过纹理采样获得深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。</p><p>不过Unity提供了LinearEyeDepth和Linear01Depth两个辅助函数：</p><ul><li>LinearEyeDepth负责把深度纹理的采样结果转换到视角空间下的深度值</li><li>Linear01Depth会返回一个范围在[0,1]的线性深度值</li></ul><p>如果我们需要获得深度+法线纹理，Unity提供了DecodeDepthNormal来为我们获得的采样结果进行解码：</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">void</span> DecodeDepthNormal(float4 enc, <span class="keyword">out</span> <span class="type">float</span> depth, <span class="keyword">out</span> float3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.zw);</span><br><span class="line">    normal = DecodeViewNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获得的深度值是[0,1]的线性深度值</li><li>得到的法线是视角空间下的法线方向</li></ul><h2 id="基于深度和法线的边缘检测">基于深度和法线的边缘检测</h2><p>C#中添加了控制采样距离的参数，和控制对深度和法线进行边缘检测时的灵敏度参数</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectionWithDepthAndNormal</span> : <span class="title">PostEffectsBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shader EdgeDetectionShader;</span><br><span class="line">    <span class="keyword">private</span> Material EdgeDetectionMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Material material</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            EdgeDetectionMaterial = CheckShaderAndCreateMaterial(EdgeDetectionShader, EdgeDetectionMaterial);</span><br><span class="line">            <span class="keyword">return</span> EdgeDetectionMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> EdgeOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color EdgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color BackgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormal = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode = DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]<span class="comment">//标明该属性实现在渲染半透明前就调用此函数进行描边</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, EdgeOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>,EdgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>,BackgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>,sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>,<span class="keyword">new</span> Vector4(sensitivityNormal,sensitivityDepth,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">            </span><br><span class="line">            Graphics.Blit(src,dest,material);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics.Blit(src,dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>其中在OnRenderImage前添加了ImageEffectOpaque属性，实现在渲染半透明前就调用此函数（不给半透明物体描边）</p></blockquote><p>shader中则是使用了Roberts算子，其本质是计算左上角和右下角的差值，乘以右上角和左下角的差值，以此作为评估边缘的依据</p><p><img src="http://qiuhanblog-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20230612165636754.png" alt=""></p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderLearning/PostProcess/EdgeDetectionWithDepthAndNormal&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(&quot;Base (RGB)&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _EdgeColor(&quot;Edge Color&quot;,Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _BackgroundColor(&quot;Background Color&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _SampleDistance(&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity(&quot;Sensitivity(ND00)&quot;,Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _EdgeOnly(&quot;Edge Only&quot;, Float) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        vector _Sensitivity;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line"></span><br><span class="line">        struct v2f</span><br><span class="line">        &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>] : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f vert(appdata_img v)</span><br><span class="line">        &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize * half2(<span class="number">1</span>, <span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize * half2(<span class="number">-1</span>, <span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize * half2(<span class="number">1</span>, <span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize * half2(<span class="number">-1</span>, <span class="number">1</span>) * _SampleDistance;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half CheckSame(half4 center, half4 <span class="keyword">sample</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用Roberts算子进行边缘检测</span></span><br><span class="line"></span><br><span class="line">            half2 centerNormal = center.xy;</span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">            half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line"></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">            half2 diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="type">int</span> isSameDepth = <span class="built_in">abs</span>(diffDepth.x + diffDepth.y) &lt; <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (isSameDepth * isSameNormal) ? <span class="number">1.0</span> : <span class="number">0.0</span>; <span class="comment">//如果法线和深度都满足差距极小，则不加描边；否则进行描边处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            edge *= CheckSame(sample1, sample2);</span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line"></span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ZTest Always ZWrite Off Cull Off</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基础动画、屏幕后处理、使用深度和法线纹理</summary>
    
    
    
    <category term="学习笔记" scheme="https://himoqiuhan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TA" scheme="https://himoqiuhan.github.io/tags/TA/"/>
    
    <category term="Shader" scheme="https://himoqiuhan.github.io/tags/Shader/"/>
    
    <category term="Unity" scheme="https://himoqiuhan.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
